// This is the @generated code for the A2l specification.
//
// The original proc-macro form of this file is preserved as specification_orig.rs
// Unfortunately the proc macro breaks rust-analyzer, which makes using the a2lfile crate quite inconvenient

#![allow(clippy::type_complexity)]
#![allow(clippy::new_without_default)]

use crate::a2ml;
use crate::ifdata;
use crate::parser::{A2lVersion, ParseContext, ParserError, ParserState};
use crate::tokenizer::A2lTokenType;
use crate::writer;

/// Describes the location and formatting of an a2l block within a file
#[derive(Clone, PartialEq, Eq)]
pub struct BlockInfo<T> {
    pub incfile: Option<String>,
    pub line: u32,
    pub uid: u32,
    pub start_offset: u32,
    pub end_offset: u32,
    pub item_location: T,
}

/// The trait `A2lObject` is implemented for all a2l objects as well as all objects generated by the `a2ml_specification`! macro.
/// It gives access to layout and location data which is tracked for each object in an a2l file.
pub trait A2lObject<T> {
    /// get a reference to the `BlockInfo` that describes the layout of the a2l object
    fn get_layout(&self) -> &BlockInfo<T>;
    /// get a mutable reference to the `BlockInfo` that describes the layout of the a2l object
    fn get_layout_mut(&mut self) -> &mut BlockInfo<T>;
    /// reset the location information on the a2l object. It will be treated like a new object when writing a file
    fn reset_location(&mut self);
    /// reset the reference to an include file on this objct and its children.
    /// This causes the object to be written into the output file instead of referenced through /include "filename"
    fn merge_includes(&mut self);
    /// get the source line number from which the current a2l object was loaded.
    /// Returns 0 if the object was newly created and not loaded from a file
    fn get_line(&self) -> u32;
}

/// The trait `A2lObjectName` is automatically implemented for named a2l objects
pub trait A2lObjectName {
    /// get the name of an a2l object.
    /// this trait is only implemented for those objects that have names, which is a subset of all objects
    fn get_name(&self) -> &str;
}

pub(crate) trait PositionRestricted {
    fn pos_restrict(&self) -> Option<u16> {
        None
    }
}

pub(crate) trait ParseableA2lObject: Sized {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        start_offset: u32,
    ) -> Result<Self, ParserError>;
}

/// Contains all the objects of an A2lfile
///
/// An instance of this struct is returned when an a2l file is loaded successfully
#[derive(Clone)]
pub struct A2lFile {
    pub asap2_version: Option<Asap2Version>,
    pub a2ml_version: Option<A2mlVersion>,
    pub project: Project,
    pub(crate) __block_info: BlockInfo<()>,
}

impl std::fmt::Debug for A2lFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("A2lFile")
            .field("asap2_version", &self.asap2_version)
            .field("a2ml_version", &self.a2ml_version)
            .field("project", &self.project)
            .finish()
    }
}

impl A2lFile {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(project: Project) -> Self {
        Self {
            asap2_version: None,
            a2ml_version: None,
            project,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (),
            },
        }
    }
}

impl PartialEq for A2lFile {
    fn eq(&self, other: &Self) -> bool {
        (self.asap2_version == other.asap2_version)
            && (self.a2ml_version == other.a2ml_version)
            && (self.project == other.project)
    }
}

impl A2lObject<()> for A2lFile {
    fn get_layout(&self) -> &BlockInfo<()> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<()> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(asap2_version) = &mut self.asap2_version {
            asap2_version.merge_includes();
        }
        if let Some(a2ml_version) = &mut self.a2ml_version {
            a2ml_version.merge_includes();
        }
        self.project.merge_includes();
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for A2lFile {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut asap2_version: Option<Asap2Version> = None;
        let mut a2ml_version: Option<A2mlVersion> = None;
        let mut __tmp_required_project: Option<Project> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            match tag {
                "ASAP2_VERSION" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Asap2Version::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, asap2_version.is_some())?;
                    asap2_version = Some(newitem);
                }
                "A2ML_VERSION" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = A2mlVersion::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, a2ml_version.is_some())?;
                    a2ml_version = Some(newitem);
                }
                "PROJECT" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Project::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        __tmp_required_project.is_some(),
                    )?;
                    __tmp_required_project = Some(newitem);
                }
                _ => {
                    if is_block {
                        parser.undo_get_token();
                    }
                    parser.undo_get_token();
                    break;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let project = if let Some(value) = __tmp_required_project {
            value
        } else {
            return Err(ParserError::InvalidMultiplicityNotPresent {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                tag: "PROJECT".to_string(),
                block: context.element.clone(),
                block_line: context.line,
            });
        };
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (),
            },
            asap2_version,
            a2ml_version,
            project,
        })
    }
}

impl A2lFile {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(asap2_version) = &self.asap2_version {
            let asap2_version_out = asap2_version.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ASAP2_VERSION",
                item_text: asap2_version_out,
                is_block: false,
                incfile: &asap2_version.__block_info.incfile,
                uid: asap2_version.__block_info.uid,
                line: asap2_version.__block_info.line,
                start_offset: asap2_version.__block_info.start_offset,
                end_offset: asap2_version.__block_info.end_offset,
                position_restriction: asap2_version.pos_restrict(),
            });
        }
        if let Some(a2ml_version) = &self.a2ml_version {
            let a2ml_version_out = a2ml_version.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "A2ML_VERSION",
                item_text: a2ml_version_out,
                is_block: false,
                incfile: &a2ml_version.__block_info.incfile,
                uid: a2ml_version.__block_info.uid,
                line: a2ml_version.__block_info.line,
                start_offset: a2ml_version.__block_info.start_offset,
                end_offset: a2ml_version.__block_info.end_offset,
                position_restriction: a2ml_version.pos_restrict(),
            });
        }
        let project_out = self.project.stringify(indent + 1);
        tgroup.push(writer::TaggedItemInfo {
            tag: "PROJECT",
            item_text: project_out,
            is_block: true,
            incfile: &self.project.__block_info.incfile,
            uid: self.project.__block_info.uid,
            line: self.project.__block_info.line,
            start_offset: self.project.__block_info.start_offset,
            end_offset: self.project.__block_info.end_offset,
            position_restriction: self.project.pos_restrict(),
        });
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Contains AML code for description of interface specific description data.
///
/// Specification: 3.5.2
/// `A2ML_VERSION` is currently ignored
#[derive(Clone)]
pub struct A2mlVersion {
    pub version_no: u16,
    pub upgrade_no: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), (u32, bool))>,
}

impl std::fmt::Debug for A2mlVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("A2mlVersion")
            .field("version_no", &self.version_no)
            .field("upgrade_no", &self.upgrade_no)
            .finish()
    }
}

impl A2mlVersion {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(version_no: u16, upgrade_no: u16) -> Self {
        Self {
            version_no,
            upgrade_no,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), (0u32, false)),
            },
        }
    }
}

impl PartialEq for A2mlVersion {
    fn eq(&self, other: &Self) -> bool {
        (self.version_no == other.version_no) && (self.upgrade_no == other.upgrade_no)
    }
}

impl A2lObject<((u32, bool), (u32, bool))> for A2mlVersion {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), (u32, bool))> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), (u32, bool))> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for A2mlVersion {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__version_no_location, version_no) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__upgrade_no_location, upgrade_no) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__version_no_location, __upgrade_no_location),
            },
            version_no,
            upgrade_no,
        })
    }
}

impl A2mlVersion {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.version_no,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_integer(
            self.upgrade_no,
            self.__block_info.item_location.1 .1,
            self.__block_info.item_location.1 .0,
        );
        writer.finish()
    }
}

/// Address of the EPROM identifier
#[derive(Clone)]
pub struct AddrEpk {
    pub address: u32,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for AddrEpk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AddrEpk")
            .field("address", &self.address)
            .finish()
    }
}

impl AddrEpk {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(address: u32) -> Self {
        Self {
            address,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for AddrEpk {
    fn eq(&self, other: &Self) -> bool {
        self.address == other.address
    }
}

impl A2lObject<((u32, bool), ())> for AddrEpk {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AddrEpk {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__address_location, address) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__address_location, __dummy),
            },
            address,
        })
    }
}

impl AddrEpk {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.address,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// Description of the addressing of table values or axis point values.
///
/// Specification: predefined data types
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AddrType {
    Pbyte,
    Pword,
    Plong,
    Plonglong,
    Direct,
}

impl ParseableA2lObject for AddrType {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "PBYTE" => Ok(Self::Pbyte),
            "PWORD" => Ok(Self::Pword),
            "PLONG" => Ok(Self::Plong),
            "PLONGLONG" => {
                parser.check_enumitem_version_lower(context, "PLONGLONG", A2lVersion::V1_7_0)?;
                Ok(Self::Plonglong)
            }
            "DIRECT" => Ok(Self::Direct),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for AddrType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::Pbyte => "PBYTE",
            Self::Pword => "PWORD",
            Self::Plong => "PLONG",
            Self::Plonglong => "PLONGLONG",
            Self::Direct => "DIRECT",
        };
        f.write_str(tag)
    }
}

/// Description of the addressing of table values or axis point values.
#[derive(Clone)]
pub struct AddressType {
    pub address_type: AddrType,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for AddressType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AddressType")
            .field("address_type", &self.address_type)
            .finish()
    }
}

impl AddressType {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(address_type: AddrType) -> Self {
        Self {
            address_type,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for AddressType {
    fn eq(&self, other: &Self) -> bool {
        self.address_type == other.address_type
    }
}

impl A2lObject<(u32, ())> for AddressType {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AddressType {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__address_type_location, address_type) = (
            parser.get_current_line_offset(),
            AddrType::parse(parser, context, 0)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__address_type_location, __dummy),
            },
            address_type,
        })
    }
}

impl AddressType {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(
            &self.address_type.to_string(),
            self.__block_info.item_location.0,
        );
        writer.finish()
    }
}

/// Defines the alignment of byte-sized values in complex objects (maps and axis)
#[derive(Clone)]
pub struct AlignmentByte {
    pub alignment_border: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for AlignmentByte {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AlignmentByte")
            .field("alignment_border", &self.alignment_border)
            .finish()
    }
}

impl AlignmentByte {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(alignment_border: u16) -> Self {
        Self {
            alignment_border,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for AlignmentByte {
    fn eq(&self, other: &Self) -> bool {
        self.alignment_border == other.alignment_border
    }
}

impl A2lObject<((u32, bool), ())> for AlignmentByte {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AlignmentByte {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__alignment_border_location, alignment_border) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__alignment_border_location, __dummy),
            },
            alignment_border,
        })
    }
}

impl AlignmentByte {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.alignment_border,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// Defines the alignment of 16bit floats in complex objects (maps and axis)
#[derive(Clone)]
pub struct AlignmentFloat16Ieee {
    pub alignment_border: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for AlignmentFloat16Ieee {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AlignmentFloat16Ieee")
            .field("alignment_border", &self.alignment_border)
            .finish()
    }
}

impl AlignmentFloat16Ieee {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(alignment_border: u16) -> Self {
        Self {
            alignment_border,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for AlignmentFloat16Ieee {
    fn eq(&self, other: &Self) -> bool {
        self.alignment_border == other.alignment_border
    }
}

impl A2lObject<((u32, bool), ())> for AlignmentFloat16Ieee {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AlignmentFloat16Ieee {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__alignment_border_location, alignment_border) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__alignment_border_location, __dummy),
            },
            alignment_border,
        })
    }
}

impl AlignmentFloat16Ieee {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.alignment_border,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// Defines the alignment of 32bit floats in complex objects (maps and axis)
#[derive(Clone)]
pub struct AlignmentFloat32Ieee {
    pub alignment_border: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for AlignmentFloat32Ieee {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AlignmentFloat32Ieee")
            .field("alignment_border", &self.alignment_border)
            .finish()
    }
}

impl AlignmentFloat32Ieee {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(alignment_border: u16) -> Self {
        Self {
            alignment_border,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for AlignmentFloat32Ieee {
    fn eq(&self, other: &Self) -> bool {
        self.alignment_border == other.alignment_border
    }
}

impl A2lObject<((u32, bool), ())> for AlignmentFloat32Ieee {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AlignmentFloat32Ieee {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__alignment_border_location, alignment_border) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__alignment_border_location, __dummy),
            },
            alignment_border,
        })
    }
}

impl AlignmentFloat32Ieee {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.alignment_border,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// Defines the alignment of 64bit floats in complex objects (maps and axis)
#[derive(Clone)]
pub struct AlignmentFloat64Ieee {
    pub alignment_border: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for AlignmentFloat64Ieee {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AlignmentFloat64Ieee")
            .field("alignment_border", &self.alignment_border)
            .finish()
    }
}

impl AlignmentFloat64Ieee {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(alignment_border: u16) -> Self {
        Self {
            alignment_border,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for AlignmentFloat64Ieee {
    fn eq(&self, other: &Self) -> bool {
        self.alignment_border == other.alignment_border
    }
}

impl A2lObject<((u32, bool), ())> for AlignmentFloat64Ieee {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AlignmentFloat64Ieee {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__alignment_border_location, alignment_border) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__alignment_border_location, __dummy),
            },
            alignment_border,
        })
    }
}

impl AlignmentFloat64Ieee {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.alignment_border,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// Defines the alignment of int64 values in complex objects (maps and axis)
#[derive(Clone)]
pub struct AlignmentInt64 {
    pub alignment_border: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for AlignmentInt64 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AlignmentInt64")
            .field("alignment_border", &self.alignment_border)
            .finish()
    }
}

impl AlignmentInt64 {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(alignment_border: u16) -> Self {
        Self {
            alignment_border,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for AlignmentInt64 {
    fn eq(&self, other: &Self) -> bool {
        self.alignment_border == other.alignment_border
    }
}

impl A2lObject<((u32, bool), ())> for AlignmentInt64 {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AlignmentInt64 {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__alignment_border_location, alignment_border) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__alignment_border_location, __dummy),
            },
            alignment_border,
        })
    }
}

impl AlignmentInt64 {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.alignment_border,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// Defines the alignment of long-sized values in complex objects (maps and axis)
#[derive(Clone)]
pub struct AlignmentLong {
    pub alignment_border: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for AlignmentLong {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AlignmentLong")
            .field("alignment_border", &self.alignment_border)
            .finish()
    }
}

impl AlignmentLong {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(alignment_border: u16) -> Self {
        Self {
            alignment_border,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for AlignmentLong {
    fn eq(&self, other: &Self) -> bool {
        self.alignment_border == other.alignment_border
    }
}

impl A2lObject<((u32, bool), ())> for AlignmentLong {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AlignmentLong {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__alignment_border_location, alignment_border) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__alignment_border_location, __dummy),
            },
            alignment_border,
        })
    }
}

impl AlignmentLong {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.alignment_border,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// Defines the alignment of word-sized values in complex objects (maps and axis)
#[derive(Clone)]
pub struct AlignmentWord {
    pub alignment_border: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for AlignmentWord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AlignmentWord")
            .field("alignment_border", &self.alignment_border)
            .finish()
    }
}

impl AlignmentWord {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(alignment_border: u16) -> Self {
        Self {
            alignment_border,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for AlignmentWord {
    fn eq(&self, other: &Self) -> bool {
        self.alignment_border == other.alignment_border
    }
}

impl A2lObject<((u32, bool), ())> for AlignmentWord {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AlignmentWord {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__alignment_border_location, alignment_border) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__alignment_border_location, __dummy),
            },
            alignment_border,
        })
    }
}

impl AlignmentWord {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.alignment_border,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// An extended description text
///
/// One ANNOTATION may represent a voluminous description. Its purpose is to be e.g.
/// an application note which explains the function of an identifier for the calibration
/// engineer.
#[derive(Clone)]
pub struct Annotation {
    pub annotation_label: Option<AnnotationLabel>,
    pub annotation_origin: Option<AnnotationOrigin>,
    pub annotation_text: Option<AnnotationText>,
    pub(crate) __block_info: BlockInfo<()>,
}

impl std::fmt::Debug for Annotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Annotation")
            .field("annotation_label", &self.annotation_label)
            .field("annotation_origin", &self.annotation_origin)
            .field("annotation_text", &self.annotation_text)
            .finish()
    }
}

impl Annotation {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            annotation_label: None,
            annotation_origin: None,
            annotation_text: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (),
            },
        }
    }
}

impl PartialEq for Annotation {
    fn eq(&self, other: &Self) -> bool {
        (self.annotation_label == other.annotation_label)
            && (self.annotation_origin == other.annotation_origin)
            && (self.annotation_text == other.annotation_text)
    }
}

impl A2lObject<()> for Annotation {
    fn get_layout(&self) -> &BlockInfo<()> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<()> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(annotation_label) = &mut self.annotation_label {
            annotation_label.merge_includes();
        }
        if let Some(annotation_origin) = &mut self.annotation_origin {
            annotation_origin.merge_includes();
        }
        if let Some(annotation_text) = &mut self.annotation_text {
            annotation_text.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Annotation {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut annotation_label: Option<AnnotationLabel> = None;
        let mut annotation_origin: Option<AnnotationOrigin> = None;
        let mut annotation_text: Option<AnnotationText> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 3usize] =
                ["ANNOTATION_LABEL", "ANNOTATION_ORIGIN", "ANNOTATION_TEXT"];
            match tag {
                "ANNOTATION_LABEL" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AnnotationLabel::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, annotation_label.is_some())?;
                    annotation_label = Some(newitem);
                }
                "ANNOTATION_ORIGIN" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AnnotationOrigin::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, annotation_origin.is_some())?;
                    annotation_origin = Some(newitem);
                }
                "ANNOTATION_TEXT" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = AnnotationText::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, annotation_text.is_some())?;
                    annotation_text = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (),
            },
            annotation_label,
            annotation_origin,
            annotation_text,
        })
    }
}

impl Annotation {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(annotation_label) = &self.annotation_label {
            let annotation_label_out = annotation_label.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ANNOTATION_LABEL",
                item_text: annotation_label_out,
                is_block: false,
                incfile: &annotation_label.__block_info.incfile,
                uid: annotation_label.__block_info.uid,
                line: annotation_label.__block_info.line,
                start_offset: annotation_label.__block_info.start_offset,
                end_offset: annotation_label.__block_info.end_offset,
                position_restriction: annotation_label.pos_restrict(),
            });
        }
        if let Some(annotation_origin) = &self.annotation_origin {
            let annotation_origin_out = annotation_origin.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ANNOTATION_ORIGIN",
                item_text: annotation_origin_out,
                is_block: false,
                incfile: &annotation_origin.__block_info.incfile,
                uid: annotation_origin.__block_info.uid,
                line: annotation_origin.__block_info.line,
                start_offset: annotation_origin.__block_info.start_offset,
                end_offset: annotation_origin.__block_info.end_offset,
                position_restriction: annotation_origin.pos_restrict(),
            });
        }
        if let Some(annotation_text) = &self.annotation_text {
            let annotation_text_out = annotation_text.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ANNOTATION_TEXT",
                item_text: annotation_text_out,
                is_block: true,
                incfile: &annotation_text.__block_info.incfile,
                uid: annotation_text.__block_info.uid,
                line: annotation_text.__block_info.line,
                start_offset: annotation_text.__block_info.start_offset,
                end_offset: annotation_text.__block_info.end_offset,
                position_restriction: annotation_text.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// The label or title of an annotation
#[derive(Clone)]
pub struct AnnotationLabel {
    pub label: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for AnnotationLabel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AnnotationLabel")
            .field("label", &self.label)
            .finish()
    }
}

impl AnnotationLabel {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(label: String) -> Self {
        Self {
            label,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for AnnotationLabel {
    fn eq(&self, other: &Self) -> bool {
        self.label == other.label
    }
}

impl A2lObject<(u32, ())> for AnnotationLabel {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AnnotationLabel {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__label_location, label) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__label_location, __dummy),
            },
            label,
        })
    }
}

impl AnnotationLabel {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.label, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Identify who or which system has created an annotation
#[derive(Clone)]
pub struct AnnotationOrigin {
    pub origin: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for AnnotationOrigin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AnnotationOrigin")
            .field("origin", &self.origin)
            .finish()
    }
}

impl AnnotationOrigin {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(origin: String) -> Self {
        Self {
            origin,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for AnnotationOrigin {
    fn eq(&self, other: &Self) -> bool {
        self.origin == other.origin
    }
}

impl A2lObject<(u32, ())> for AnnotationOrigin {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AnnotationOrigin {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__origin_location, origin) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__origin_location, __dummy),
            },
            origin,
        })
    }
}

impl AnnotationOrigin {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.origin, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Text of an annotation
///
/// One `ANNOTATION_TEXT` may represent a multi-line description text.
#[derive(Clone)]
pub struct AnnotationText {
    pub annotation_text_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for AnnotationText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AnnotationText")
            .field("annotation_text_list", &self.annotation_text_list)
            .finish()
    }
}

impl AnnotationText {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            annotation_text_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for AnnotationText {
    fn eq(&self, other: &Self) -> bool {
        self.annotation_text_list == other.annotation_text_list
    }
}

impl A2lObject<(Vec<u32>, ())> for AnnotationText {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AnnotationText {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut annotation_text_list = Vec::new();
        let mut __annotation_text_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_string(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    annotation_text_list.push(value);
                    __annotation_text_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__annotation_text_list_location, __dummy),
            },
            annotation_text_list,
        })
    }
}

impl AnnotationText {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.annotation_text_list.iter().enumerate() {
            writer.add_quoted_string(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// describes the Autosar component type of a function
#[derive(Clone)]
pub struct ArComponent {
    pub component_type: String,
    pub ar_prototype_of: Option<ArPrototypeOf>,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for ArComponent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ArComponent")
            .field("component_type", &self.component_type)
            .field("ar_prototype_of", &self.ar_prototype_of)
            .finish()
    }
}

impl ArComponent {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(component_type: String) -> Self {
        Self {
            component_type,
            ar_prototype_of: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (1u32, ()),
            },
        }
    }
}

impl PartialEq for ArComponent {
    fn eq(&self, other: &Self) -> bool {
        (self.component_type == other.component_type)
            && (self.ar_prototype_of == other.ar_prototype_of)
    }
}

impl A2lObject<(u32, ())> for ArComponent {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(ar_prototype_of) = &mut self.ar_prototype_of {
            ar_prototype_of.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for ArComponent {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__component_type_location, component_type) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let mut ar_prototype_of: Option<ArPrototypeOf> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 1usize] = ["AR_PROTOTYPE_OF"];
            match tag {
                "AR_PROTOTYPE_OF" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ArPrototypeOf::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, ar_prototype_of.is_some())?;
                    ar_prototype_of = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__component_type_location, __dummy),
            },
            component_type,
            ar_prototype_of,
        })
    }
}

impl ArComponent {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.component_type, self.__block_info.item_location.0);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(ar_prototype_of) = &self.ar_prototype_of {
            let ar_prototype_of_out = ar_prototype_of.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AR_PROTOTYPE_OF",
                item_text: ar_prototype_of_out,
                is_block: false,
                incfile: &ar_prototype_of.__block_info.incfile,
                uid: ar_prototype_of.__block_info.uid,
                line: ar_prototype_of.__block_info.line,
                start_offset: ar_prototype_of.__block_info.start_offset,
                end_offset: ar_prototype_of.__block_info.end_offset,
                position_restriction: ar_prototype_of.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Describes the resationship of the component type to to a component prototype in the Autosar system
#[derive(Clone)]
pub struct ArPrototypeOf {
    pub name: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for ArPrototypeOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ArPrototypeOf")
            .field("name", &self.name)
            .finish()
    }
}

impl ArPrototypeOf {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String) -> Self {
        Self {
            name,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for ArPrototypeOf {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name
    }
}

impl A2lObject<(u32, ())> for ArPrototypeOf {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for ArPrototypeOf {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for ArPrototypeOf {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __dummy),
            },
            name,
        })
    }
}

impl ArPrototypeOf {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// marks a measurement object as an array of `<Number>` measurement values
///
/// `ARRAY_SIZE` is obsolete: `MATRIX_DIM` should be used instead.
#[derive(Clone)]
pub struct ArraySize {
    pub number: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for ArraySize {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ArraySize")
            .field("number", &self.number)
            .finish()
    }
}

impl ArraySize {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(number: u16) -> Self {
        Self {
            number,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for ArraySize {
    fn eq(&self, other: &Self) -> bool {
        self.number == other.number
    }
}

impl A2lObject<((u32, bool), ())> for ArraySize {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for ArraySize {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__number_location, number) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__number_location, __dummy),
            },
            number,
        })
    }
}

impl ArraySize {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.number,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// Version of the ASAM MCD-2MC standard used by this file
///
/// This keyword is mandatory. Example:
///     `ASAP2_VERSION` 1 61
#[derive(Clone)]
pub struct Asap2Version {
    pub version_no: u16,
    pub upgrade_no: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), (u32, bool))>,
}

impl std::fmt::Debug for Asap2Version {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Asap2Version")
            .field("version_no", &self.version_no)
            .field("upgrade_no", &self.upgrade_no)
            .finish()
    }
}

impl Asap2Version {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(version_no: u16, upgrade_no: u16) -> Self {
        Self {
            version_no,
            upgrade_no,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), (0u32, false)),
            },
        }
    }
}

impl PartialEq for Asap2Version {
    fn eq(&self, other: &Self) -> bool {
        (self.version_no == other.version_no) && (self.upgrade_no == other.upgrade_no)
    }
}

impl A2lObject<((u32, bool), (u32, bool))> for Asap2Version {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), (u32, bool))> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), (u32, bool))> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Asap2Version {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__version_no_location, version_no) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__upgrade_no_location, upgrade_no) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__version_no_location, __upgrade_no_location),
            },
            version_no,
            upgrade_no,
        })
    }
}

impl Asap2Version {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.version_no,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_integer(
            self.upgrade_no,
            self.__block_info.item_location.1 .1,
            self.__block_info.item_location.1 .0,
        );
        writer.finish()
    }
}

/// Axis description within an adjustable object
#[derive(Clone)]
pub struct AxisDescr {
    pub attribute: AxisDescrAttribute,
    pub input_quantity: String,
    pub conversion: String,
    pub max_axis_points: u16,
    pub lower_limit: f64,
    pub upper_limit: f64,
    pub annotation: Vec<Annotation>,
    pub axis_pts_ref: Option<AxisPtsRef>,
    pub byte_order: Option<ByteOrder>,
    pub curve_axis_ref: Option<CurveAxisRef>,
    pub deposit: Option<Deposit>,
    pub extended_limits: Option<ExtendedLimits>,
    pub fix_axis_par: Option<FixAxisPar>,
    pub fix_axis_par_dist: Option<FixAxisParDist>,
    pub fix_axis_par_list: Option<FixAxisParList>,
    pub format: Option<Format>,
    pub max_grad: Option<MaxGrad>,
    pub monotony: Option<Monotony>,
    pub phys_unit: Option<PhysUnit>,
    pub read_only: Option<ReadOnly>,
    pub step_size: Option<StepSize>,
    pub(crate) __block_info: BlockInfo<(u32, u32, u32, (u32, bool), u32, u32)>,
}

impl std::fmt::Debug for AxisDescr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AxisDescr")
            .field("attribute", &self.attribute)
            .field("input_quantity", &self.input_quantity)
            .field("conversion", &self.conversion)
            .field("max_axis_points", &self.max_axis_points)
            .field("lower_limit", &self.lower_limit)
            .field("upper_limit", &self.upper_limit)
            .field("annotation", &self.annotation)
            .field("axis_pts_ref", &self.axis_pts_ref)
            .field("byte_order", &self.byte_order)
            .field("curve_axis_ref", &self.curve_axis_ref)
            .field("deposit", &self.deposit)
            .field("extended_limits", &self.extended_limits)
            .field("fix_axis_par", &self.fix_axis_par)
            .field("fix_axis_par_dist", &self.fix_axis_par_dist)
            .field("fix_axis_par_list", &self.fix_axis_par_list)
            .field("format", &self.format)
            .field("max_grad", &self.max_grad)
            .field("monotony", &self.monotony)
            .field("phys_unit", &self.phys_unit)
            .field("read_only", &self.read_only)
            .field("step_size", &self.step_size)
            .finish()
    }
}

impl AxisDescr {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        attribute: AxisDescrAttribute,
        input_quantity: String,
        conversion: String,
        max_axis_points: u16,
        lower_limit: f64,
        upper_limit: f64,
    ) -> Self {
        Self {
            attribute,
            input_quantity,
            conversion,
            max_axis_points,
            lower_limit,
            upper_limit,
            annotation: Vec::new(),
            axis_pts_ref: None,
            byte_order: None,
            curve_axis_ref: None,
            deposit: None,
            extended_limits: None,
            fix_axis_par: None,
            fix_axis_par_dist: None,
            fix_axis_par_list: None,
            format: None,
            max_grad: None,
            monotony: None,
            phys_unit: None,
            read_only: None,
            step_size: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (1u32, 0u32, 0u32, (0u32, false), 0u32, 0u32),
            },
        }
    }
}

impl PartialEq for AxisDescr {
    fn eq(&self, other: &Self) -> bool {
        (self.attribute == other.attribute)
            && (self.input_quantity == other.input_quantity)
            && (self.conversion == other.conversion)
            && (self.max_axis_points == other.max_axis_points)
            && (self.lower_limit == other.lower_limit)
            && (self.upper_limit == other.upper_limit)
            && (self.annotation == other.annotation)
            && (self.axis_pts_ref == other.axis_pts_ref)
            && (self.byte_order == other.byte_order)
            && (self.curve_axis_ref == other.curve_axis_ref)
            && (self.deposit == other.deposit)
            && (self.extended_limits == other.extended_limits)
            && (self.fix_axis_par == other.fix_axis_par)
            && (self.fix_axis_par_dist == other.fix_axis_par_dist)
            && (self.fix_axis_par_list == other.fix_axis_par_list)
            && (self.format == other.format)
            && (self.max_grad == other.max_grad)
            && (self.monotony == other.monotony)
            && (self.phys_unit == other.phys_unit)
            && (self.read_only == other.read_only)
            && (self.step_size == other.step_size)
    }
}

impl A2lObject<(u32, u32, u32, (u32, bool), u32, u32)> for AxisDescr {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, u32, (u32, bool), u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, u32, (u32, bool), u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        for annotation in &mut self.annotation {
            annotation.merge_includes();
        }
        if let Some(axis_pts_ref) = &mut self.axis_pts_ref {
            axis_pts_ref.merge_includes();
        }
        if let Some(byte_order) = &mut self.byte_order {
            byte_order.merge_includes();
        }
        if let Some(curve_axis_ref) = &mut self.curve_axis_ref {
            curve_axis_ref.merge_includes();
        }
        if let Some(deposit) = &mut self.deposit {
            deposit.merge_includes();
        }
        if let Some(extended_limits) = &mut self.extended_limits {
            extended_limits.merge_includes();
        }
        if let Some(fix_axis_par) = &mut self.fix_axis_par {
            fix_axis_par.merge_includes();
        }
        if let Some(fix_axis_par_dist) = &mut self.fix_axis_par_dist {
            fix_axis_par_dist.merge_includes();
        }
        if let Some(fix_axis_par_list) = &mut self.fix_axis_par_list {
            fix_axis_par_list.merge_includes();
        }
        if let Some(format) = &mut self.format {
            format.merge_includes();
        }
        if let Some(max_grad) = &mut self.max_grad {
            max_grad.merge_includes();
        }
        if let Some(monotony) = &mut self.monotony {
            monotony.merge_includes();
        }
        if let Some(phys_unit) = &mut self.phys_unit {
            phys_unit.merge_includes();
        }
        if let Some(read_only) = &mut self.read_only {
            read_only.merge_includes();
        }
        if let Some(step_size) = &mut self.step_size {
            step_size.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AxisDescr {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__attribute_location, attribute) = (
            parser.get_current_line_offset(),
            AxisDescrAttribute::parse(parser, context, 0)?,
        );
        let (__input_quantity_location, input_quantity) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__conversion_location, conversion) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__max_axis_points_location, max_axis_points) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__lower_limit_location, lower_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__upper_limit_location, upper_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let mut annotation: Vec<Annotation> = Vec::new();
        let mut axis_pts_ref: Option<AxisPtsRef> = None;
        let mut byte_order: Option<ByteOrder> = None;
        let mut curve_axis_ref: Option<CurveAxisRef> = None;
        let mut deposit: Option<Deposit> = None;
        let mut extended_limits: Option<ExtendedLimits> = None;
        let mut fix_axis_par: Option<FixAxisPar> = None;
        let mut fix_axis_par_dist: Option<FixAxisParDist> = None;
        let mut fix_axis_par_list: Option<FixAxisParList> = None;
        let mut format: Option<Format> = None;
        let mut max_grad: Option<MaxGrad> = None;
        let mut monotony: Option<Monotony> = None;
        let mut phys_unit: Option<PhysUnit> = None;
        let mut read_only: Option<ReadOnly> = None;
        let mut step_size: Option<StepSize> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 15usize] = [
                "ANNOTATION",
                "AXIS_PTS_REF",
                "BYTE_ORDER",
                "CURVE_AXIS_REF",
                "DEPOSIT",
                "EXTENDED_LIMITS",
                "FIX_AXIS_PAR",
                "FIX_AXIS_PAR_DIST",
                "FIX_AXIS_PAR_LIST",
                "FORMAT",
                "MAX_GRAD",
                "MONOTONY",
                "PHYS_UNIT",
                "READ_ONLY",
                "STEP_SIZE",
            ];
            match tag {
                "ANNOTATION" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Annotation::parse(parser, &newcontext, line_offset)?;
                    annotation.push(newitem);
                }
                "AXIS_PTS_REF" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AxisPtsRef::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, axis_pts_ref.is_some())?;
                    axis_pts_ref = Some(newitem);
                }
                "BYTE_ORDER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ByteOrder::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, byte_order.is_some())?;
                    byte_order = Some(newitem);
                }
                "CURVE_AXIS_REF" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = CurveAxisRef::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, curve_axis_ref.is_some())?;
                    curve_axis_ref = Some(newitem);
                }
                "DEPOSIT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Deposit::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, deposit.is_some())?;
                    deposit = Some(newitem);
                }
                "EXTENDED_LIMITS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ExtendedLimits::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, extended_limits.is_some())?;
                    extended_limits = Some(newitem);
                }
                "FIX_AXIS_PAR" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = FixAxisPar::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, fix_axis_par.is_some())?;
                    fix_axis_par = Some(newitem);
                }
                "FIX_AXIS_PAR_DIST" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = FixAxisParDist::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, fix_axis_par_dist.is_some())?;
                    fix_axis_par_dist = Some(newitem);
                }
                "FIX_AXIS_PAR_LIST" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = FixAxisParList::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, fix_axis_par_list.is_some())?;
                    fix_axis_par_list = Some(newitem);
                }
                "FORMAT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Format::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, format.is_some())?;
                    format = Some(newitem);
                }
                "MAX_GRAD" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = MaxGrad::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, max_grad.is_some())?;
                    max_grad = Some(newitem);
                }
                "MONOTONY" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Monotony::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, monotony.is_some())?;
                    monotony = Some(newitem);
                }
                "PHYS_UNIT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "PHYS_UNIT", A2lVersion::V1_6_0)?;
                    let newitem = PhysUnit::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, phys_unit.is_some())?;
                    phys_unit = Some(newitem);
                }
                "READ_ONLY" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ReadOnly::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, read_only.is_some())?;
                    read_only = Some(newitem);
                }
                "STEP_SIZE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "STEP_SIZE", A2lVersion::V1_6_0)?;
                    let newitem = StepSize::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, step_size.is_some())?;
                    step_size = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __attribute_location,
                    __input_quantity_location,
                    __conversion_location,
                    __max_axis_points_location,
                    __lower_limit_location,
                    __upper_limit_location,
                ),
            },
            attribute,
            input_quantity,
            conversion,
            max_axis_points,
            lower_limit,
            upper_limit,
            annotation,
            axis_pts_ref,
            byte_order,
            curve_axis_ref,
            deposit,
            extended_limits,
            fix_axis_par,
            fix_axis_par_dist,
            fix_axis_par_list,
            format,
            max_grad,
            monotony,
            phys_unit,
            read_only,
            step_size,
        })
    }
}

impl AxisDescr {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(
            &self.attribute.to_string(),
            self.__block_info.item_location.0,
        );
        writer.add_str(&self.input_quantity, self.__block_info.item_location.1);
        writer.add_str(&self.conversion, self.__block_info.item_location.2);
        writer.add_integer(
            self.max_axis_points,
            self.__block_info.item_location.3 .1,
            self.__block_info.item_location.3 .0,
        );
        writer.add_float(self.lower_limit, self.__block_info.item_location.4);
        writer.add_float(self.upper_limit, self.__block_info.item_location.5);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        for annotation in &self.annotation {
            let annotation_out = annotation.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ANNOTATION",
                item_text: annotation_out,
                is_block: true,
                incfile: &annotation.__block_info.incfile,
                uid: annotation.__block_info.uid,
                line: annotation.__block_info.line,
                start_offset: annotation.__block_info.start_offset,
                end_offset: annotation.__block_info.end_offset,
                position_restriction: annotation.pos_restrict(),
            });
        }
        if let Some(axis_pts_ref) = &self.axis_pts_ref {
            let axis_pts_ref_out = axis_pts_ref.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AXIS_PTS_REF",
                item_text: axis_pts_ref_out,
                is_block: false,
                incfile: &axis_pts_ref.__block_info.incfile,
                uid: axis_pts_ref.__block_info.uid,
                line: axis_pts_ref.__block_info.line,
                start_offset: axis_pts_ref.__block_info.start_offset,
                end_offset: axis_pts_ref.__block_info.end_offset,
                position_restriction: axis_pts_ref.pos_restrict(),
            });
        }
        if let Some(byte_order) = &self.byte_order {
            let byte_order_out = byte_order.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "BYTE_ORDER",
                item_text: byte_order_out,
                is_block: false,
                incfile: &byte_order.__block_info.incfile,
                uid: byte_order.__block_info.uid,
                line: byte_order.__block_info.line,
                start_offset: byte_order.__block_info.start_offset,
                end_offset: byte_order.__block_info.end_offset,
                position_restriction: byte_order.pos_restrict(),
            });
        }
        if let Some(curve_axis_ref) = &self.curve_axis_ref {
            let curve_axis_ref_out = curve_axis_ref.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "CURVE_AXIS_REF",
                item_text: curve_axis_ref_out,
                is_block: false,
                incfile: &curve_axis_ref.__block_info.incfile,
                uid: curve_axis_ref.__block_info.uid,
                line: curve_axis_ref.__block_info.line,
                start_offset: curve_axis_ref.__block_info.start_offset,
                end_offset: curve_axis_ref.__block_info.end_offset,
                position_restriction: curve_axis_ref.pos_restrict(),
            });
        }
        if let Some(deposit) = &self.deposit {
            let deposit_out = deposit.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DEPOSIT",
                item_text: deposit_out,
                is_block: false,
                incfile: &deposit.__block_info.incfile,
                uid: deposit.__block_info.uid,
                line: deposit.__block_info.line,
                start_offset: deposit.__block_info.start_offset,
                end_offset: deposit.__block_info.end_offset,
                position_restriction: deposit.pos_restrict(),
            });
        }
        if let Some(extended_limits) = &self.extended_limits {
            let extended_limits_out = extended_limits.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "EXTENDED_LIMITS",
                item_text: extended_limits_out,
                is_block: false,
                incfile: &extended_limits.__block_info.incfile,
                uid: extended_limits.__block_info.uid,
                line: extended_limits.__block_info.line,
                start_offset: extended_limits.__block_info.start_offset,
                end_offset: extended_limits.__block_info.end_offset,
                position_restriction: extended_limits.pos_restrict(),
            });
        }
        if let Some(fix_axis_par) = &self.fix_axis_par {
            let fix_axis_par_out = fix_axis_par.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FIX_AXIS_PAR",
                item_text: fix_axis_par_out,
                is_block: false,
                incfile: &fix_axis_par.__block_info.incfile,
                uid: fix_axis_par.__block_info.uid,
                line: fix_axis_par.__block_info.line,
                start_offset: fix_axis_par.__block_info.start_offset,
                end_offset: fix_axis_par.__block_info.end_offset,
                position_restriction: fix_axis_par.pos_restrict(),
            });
        }
        if let Some(fix_axis_par_dist) = &self.fix_axis_par_dist {
            let fix_axis_par_dist_out = fix_axis_par_dist.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FIX_AXIS_PAR_DIST",
                item_text: fix_axis_par_dist_out,
                is_block: false,
                incfile: &fix_axis_par_dist.__block_info.incfile,
                uid: fix_axis_par_dist.__block_info.uid,
                line: fix_axis_par_dist.__block_info.line,
                start_offset: fix_axis_par_dist.__block_info.start_offset,
                end_offset: fix_axis_par_dist.__block_info.end_offset,
                position_restriction: fix_axis_par_dist.pos_restrict(),
            });
        }
        if let Some(fix_axis_par_list) = &self.fix_axis_par_list {
            let fix_axis_par_list_out = fix_axis_par_list.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FIX_AXIS_PAR_LIST",
                item_text: fix_axis_par_list_out,
                is_block: true,
                incfile: &fix_axis_par_list.__block_info.incfile,
                uid: fix_axis_par_list.__block_info.uid,
                line: fix_axis_par_list.__block_info.line,
                start_offset: fix_axis_par_list.__block_info.start_offset,
                end_offset: fix_axis_par_list.__block_info.end_offset,
                position_restriction: fix_axis_par_list.pos_restrict(),
            });
        }
        if let Some(format) = &self.format {
            let format_out = format.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FORMAT",
                item_text: format_out,
                is_block: false,
                incfile: &format.__block_info.incfile,
                uid: format.__block_info.uid,
                line: format.__block_info.line,
                start_offset: format.__block_info.start_offset,
                end_offset: format.__block_info.end_offset,
                position_restriction: format.pos_restrict(),
            });
        }
        if let Some(max_grad) = &self.max_grad {
            let max_grad_out = max_grad.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MAX_GRAD",
                item_text: max_grad_out,
                is_block: false,
                incfile: &max_grad.__block_info.incfile,
                uid: max_grad.__block_info.uid,
                line: max_grad.__block_info.line,
                start_offset: max_grad.__block_info.start_offset,
                end_offset: max_grad.__block_info.end_offset,
                position_restriction: max_grad.pos_restrict(),
            });
        }
        if let Some(monotony) = &self.monotony {
            let monotony_out = monotony.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MONOTONY",
                item_text: monotony_out,
                is_block: false,
                incfile: &monotony.__block_info.incfile,
                uid: monotony.__block_info.uid,
                line: monotony.__block_info.line,
                start_offset: monotony.__block_info.start_offset,
                end_offset: monotony.__block_info.end_offset,
                position_restriction: monotony.pos_restrict(),
            });
        }
        if let Some(phys_unit) = &self.phys_unit {
            let phys_unit_out = phys_unit.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "PHYS_UNIT",
                item_text: phys_unit_out,
                is_block: false,
                incfile: &phys_unit.__block_info.incfile,
                uid: phys_unit.__block_info.uid,
                line: phys_unit.__block_info.line,
                start_offset: phys_unit.__block_info.start_offset,
                end_offset: phys_unit.__block_info.end_offset,
                position_restriction: phys_unit.pos_restrict(),
            });
        }
        if let Some(read_only) = &self.read_only {
            let read_only_out = read_only.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "READ_ONLY",
                item_text: read_only_out,
                is_block: false,
                incfile: &read_only.__block_info.incfile,
                uid: read_only.__block_info.uid,
                line: read_only.__block_info.line,
                start_offset: read_only.__block_info.start_offset,
                end_offset: read_only.__block_info.end_offset,
                position_restriction: read_only.pos_restrict(),
            });
        }
        if let Some(step_size) = &self.step_size {
            let step_size_out = step_size.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "STEP_SIZE",
                item_text: step_size_out,
                is_block: false,
                incfile: &step_size.__block_info.incfile,
                uid: step_size.__block_info.uid,
                line: step_size.__block_info.line,
                start_offset: step_size.__block_info.start_offset,
                end_offset: step_size.__block_info.end_offset,
                position_restriction: step_size.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Description of the axis points
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AxisDescrAttribute {
    CurveAxis,
    ComAxis,
    FixAxis,
    ResAxis,
    StdAxis,
}

impl ParseableA2lObject for AxisDescrAttribute {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "CURVE_AXIS" => Ok(Self::CurveAxis),
            "COM_AXIS" => Ok(Self::ComAxis),
            "FIX_AXIS" => Ok(Self::FixAxis),
            "RES_AXIS" => Ok(Self::ResAxis),
            "STD_AXIS" => Ok(Self::StdAxis),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for AxisDescrAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::CurveAxis => "CURVE_AXIS",
            Self::ComAxis => "COM_AXIS",
            Self::FixAxis => "FIX_AXIS",
            Self::ResAxis => "RES_AXIS",
            Self::StdAxis => "STD_AXIS",
        };
        f.write_str(tag)
    }
}

/// Parameters for the handling of an axis points distribution
#[derive(Clone)]
pub struct AxisPts {
    pub name: String,
    pub long_identifier: String,
    pub address: u32,
    pub input_quantity: String,
    pub deposit_record: String,
    pub max_diff: f64,
    pub conversion: String,
    pub max_axis_points: u16,
    pub lower_limit: f64,
    pub upper_limit: f64,
    pub annotation: Vec<Annotation>,
    pub byte_order: Option<ByteOrder>,
    pub calibration_access: Option<CalibrationAccess>,
    pub deposit: Option<Deposit>,
    pub display_identifier: Option<DisplayIdentifier>,
    pub ecu_address_extension: Option<EcuAddressExtension>,
    pub extended_limits: Option<ExtendedLimits>,
    pub format: Option<Format>,
    pub function_list: Option<FunctionList>,
    pub guard_rails: Option<GuardRails>,
    pub if_data: Vec<IfData>,
    pub max_refresh: Option<MaxRefresh>,
    pub model_link: Option<ModelLink>,
    pub monotony: Option<Monotony>,
    pub phys_unit: Option<PhysUnit>,
    pub read_only: Option<ReadOnly>,
    pub ref_memory_segment: Option<RefMemorySegment>,
    pub step_size: Option<StepSize>,
    pub symbol_link: Option<SymbolLink>,
    pub(crate) __block_info: BlockInfo<(
        u32,
        u32,
        (u32, bool),
        u32,
        u32,
        u32,
        u32,
        (u32, bool),
        u32,
        u32,
    )>,
}

impl std::fmt::Debug for AxisPts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AxisPts")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("address", &self.address)
            .field("input_quantity", &self.input_quantity)
            .field("deposit_record", &self.deposit_record)
            .field("max_diff", &self.max_diff)
            .field("conversion", &self.conversion)
            .field("max_axis_points", &self.max_axis_points)
            .field("lower_limit", &self.lower_limit)
            .field("upper_limit", &self.upper_limit)
            .field("annotation", &self.annotation)
            .field("byte_order", &self.byte_order)
            .field("calibration_access", &self.calibration_access)
            .field("deposit", &self.deposit)
            .field("display_identifier", &self.display_identifier)
            .field("ecu_address_extension", &self.ecu_address_extension)
            .field("extended_limits", &self.extended_limits)
            .field("format", &self.format)
            .field("function_list", &self.function_list)
            .field("guard_rails", &self.guard_rails)
            .field("if_data", &self.if_data)
            .field("max_refresh", &self.max_refresh)
            .field("model_link", &self.model_link)
            .field("monotony", &self.monotony)
            .field("phys_unit", &self.phys_unit)
            .field("read_only", &self.read_only)
            .field("ref_memory_segment", &self.ref_memory_segment)
            .field("step_size", &self.step_size)
            .field("symbol_link", &self.symbol_link)
            .finish()
    }
}

impl AxisPts {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        name: String,
        long_identifier: String,
        address: u32,
        input_quantity: String,
        deposit_record: String,
        max_diff: f64,
        conversion: String,
        max_axis_points: u16,
        lower_limit: f64,
        upper_limit: f64,
    ) -> Self {
        Self {
            name,
            long_identifier,
            address,
            input_quantity,
            deposit_record,
            max_diff,
            conversion,
            max_axis_points,
            lower_limit,
            upper_limit,
            annotation: Vec::new(),
            byte_order: None,
            calibration_access: None,
            deposit: None,
            display_identifier: None,
            ecu_address_extension: None,
            extended_limits: None,
            format: None,
            function_list: None,
            guard_rails: None,
            if_data: Vec::new(),
            max_refresh: None,
            model_link: None,
            monotony: None,
            phys_unit: None,
            read_only: None,
            ref_memory_segment: None,
            step_size: None,
            symbol_link: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (
                    0u32,
                    0u32,
                    (1u32, false),
                    0u32,
                    0u32,
                    0u32,
                    0u32,
                    (0u32, false),
                    0u32,
                    0u32,
                ),
            },
        }
    }
}

impl PartialEq for AxisPts {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.address == other.address)
            && (self.input_quantity == other.input_quantity)
            && (self.deposit_record == other.deposit_record)
            && (self.max_diff == other.max_diff)
            && (self.conversion == other.conversion)
            && (self.max_axis_points == other.max_axis_points)
            && (self.lower_limit == other.lower_limit)
            && (self.upper_limit == other.upper_limit)
            && (self.annotation == other.annotation)
            && (self.byte_order == other.byte_order)
            && (self.calibration_access == other.calibration_access)
            && (self.deposit == other.deposit)
            && (self.display_identifier == other.display_identifier)
            && (self.ecu_address_extension == other.ecu_address_extension)
            && (self.extended_limits == other.extended_limits)
            && (self.format == other.format)
            && (self.function_list == other.function_list)
            && (self.guard_rails == other.guard_rails)
            && (self.if_data == other.if_data)
            && (self.max_refresh == other.max_refresh)
            && (self.model_link == other.model_link)
            && (self.monotony == other.monotony)
            && (self.phys_unit == other.phys_unit)
            && (self.read_only == other.read_only)
            && (self.ref_memory_segment == other.ref_memory_segment)
            && (self.step_size == other.step_size)
            && (self.symbol_link == other.symbol_link)
    }
}

impl
    A2lObject<(
        u32,
        u32,
        (u32, bool),
        u32,
        u32,
        u32,
        u32,
        (u32, bool),
        u32,
        u32,
    )> for AxisPts
{
    fn get_layout(
        &self,
    ) -> &BlockInfo<(
        u32,
        u32,
        (u32, bool),
        u32,
        u32,
        u32,
        u32,
        (u32, bool),
        u32,
        u32,
    )> {
        &self.__block_info
    }
    fn get_layout_mut(
        &mut self,
    ) -> &mut BlockInfo<(
        u32,
        u32,
        (u32, bool),
        u32,
        u32,
        u32,
        u32,
        (u32, bool),
        u32,
        u32,
    )> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        for annotation in &mut self.annotation {
            annotation.merge_includes();
        }
        if let Some(byte_order) = &mut self.byte_order {
            byte_order.merge_includes();
        }
        if let Some(calibration_access) = &mut self.calibration_access {
            calibration_access.merge_includes();
        }
        if let Some(deposit) = &mut self.deposit {
            deposit.merge_includes();
        }
        if let Some(display_identifier) = &mut self.display_identifier {
            display_identifier.merge_includes();
        }
        if let Some(ecu_address_extension) = &mut self.ecu_address_extension {
            ecu_address_extension.merge_includes();
        }
        if let Some(extended_limits) = &mut self.extended_limits {
            extended_limits.merge_includes();
        }
        if let Some(format) = &mut self.format {
            format.merge_includes();
        }
        if let Some(function_list) = &mut self.function_list {
            function_list.merge_includes();
        }
        if let Some(guard_rails) = &mut self.guard_rails {
            guard_rails.merge_includes();
        }
        for if_data in &mut self.if_data {
            if_data.merge_includes();
        }
        if let Some(max_refresh) = &mut self.max_refresh {
            max_refresh.merge_includes();
        }
        if let Some(model_link) = &mut self.model_link {
            model_link.merge_includes();
        }
        if let Some(monotony) = &mut self.monotony {
            monotony.merge_includes();
        }
        if let Some(phys_unit) = &mut self.phys_unit {
            phys_unit.merge_includes();
        }
        if let Some(read_only) = &mut self.read_only {
            read_only.merge_includes();
        }
        if let Some(ref_memory_segment) = &mut self.ref_memory_segment {
            ref_memory_segment.merge_includes();
        }
        if let Some(step_size) = &mut self.step_size {
            step_size.merge_includes();
        }
        if let Some(symbol_link) = &mut self.symbol_link {
            symbol_link.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for AxisPts {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for AxisPts {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__address_location, address) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let (__input_quantity_location, input_quantity) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__deposit_record_location, deposit_record) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__max_diff_location, max_diff) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__conversion_location, conversion) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__max_axis_points_location, max_axis_points) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__lower_limit_location, lower_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__upper_limit_location, upper_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let mut annotation: Vec<Annotation> = Vec::new();
        let mut byte_order: Option<ByteOrder> = None;
        let mut calibration_access: Option<CalibrationAccess> = None;
        let mut deposit: Option<Deposit> = None;
        let mut display_identifier: Option<DisplayIdentifier> = None;
        let mut ecu_address_extension: Option<EcuAddressExtension> = None;
        let mut extended_limits: Option<ExtendedLimits> = None;
        let mut format: Option<Format> = None;
        let mut function_list: Option<FunctionList> = None;
        let mut guard_rails: Option<GuardRails> = None;
        let mut if_data: Vec<IfData> = Vec::new();
        let mut max_refresh: Option<MaxRefresh> = None;
        let mut model_link: Option<ModelLink> = None;
        let mut monotony: Option<Monotony> = None;
        let mut phys_unit: Option<PhysUnit> = None;
        let mut read_only: Option<ReadOnly> = None;
        let mut ref_memory_segment: Option<RefMemorySegment> = None;
        let mut step_size: Option<StepSize> = None;
        let mut symbol_link: Option<SymbolLink> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 19usize] = [
                "ANNOTATION",
                "BYTE_ORDER",
                "CALIBRATION_ACCESS",
                "DEPOSIT",
                "DISPLAY_IDENTIFIER",
                "ECU_ADDRESS_EXTENSION",
                "EXTENDED_LIMITS",
                "FORMAT",
                "FUNCTION_LIST",
                "GUARD_RAILS",
                "IF_DATA",
                "MAX_REFRESH",
                "MODEL_LINK",
                "MONOTONY",
                "PHYS_UNIT",
                "READ_ONLY",
                "REF_MEMORY_SEGMENT",
                "STEP_SIZE",
                "SYMBOL_LINK",
            ];
            match tag {
                "ANNOTATION" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Annotation::parse(parser, &newcontext, line_offset)?;
                    annotation.push(newitem);
                }
                "BYTE_ORDER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ByteOrder::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, byte_order.is_some())?;
                    byte_order = Some(newitem);
                }
                "CALIBRATION_ACCESS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = CalibrationAccess::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, calibration_access.is_some())?;
                    calibration_access = Some(newitem);
                }
                "DEPOSIT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Deposit::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, deposit.is_some())?;
                    deposit = Some(newitem);
                }
                "DISPLAY_IDENTIFIER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = DisplayIdentifier::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, display_identifier.is_some())?;
                    display_identifier = Some(newitem);
                }
                "ECU_ADDRESS_EXTENSION" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = EcuAddressExtension::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        ecu_address_extension.is_some(),
                    )?;
                    ecu_address_extension = Some(newitem);
                }
                "EXTENDED_LIMITS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ExtendedLimits::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, extended_limits.is_some())?;
                    extended_limits = Some(newitem);
                }
                "FORMAT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Format::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, format.is_some())?;
                    format = Some(newitem);
                }
                "FUNCTION_LIST" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = FunctionList::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, function_list.is_some())?;
                    function_list = Some(newitem);
                }
                "GUARD_RAILS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = GuardRails::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, guard_rails.is_some())?;
                    guard_rails = Some(newitem);
                }
                "IF_DATA" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = IfData::parse(parser, &newcontext, line_offset)?;
                    if_data.push(newitem);
                }
                "MAX_REFRESH" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "MAX_REFRESH", A2lVersion::V1_7_0)?;
                    let newitem = MaxRefresh::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, max_refresh.is_some())?;
                    max_refresh = Some(newitem);
                }
                "MODEL_LINK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "MODEL_LINK", A2lVersion::V1_7_0)?;
                    let newitem = ModelLink::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, model_link.is_some())?;
                    model_link = Some(newitem);
                }
                "MONOTONY" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Monotony::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, monotony.is_some())?;
                    monotony = Some(newitem);
                }
                "PHYS_UNIT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "PHYS_UNIT", A2lVersion::V1_6_0)?;
                    let newitem = PhysUnit::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, phys_unit.is_some())?;
                    phys_unit = Some(newitem);
                }
                "READ_ONLY" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ReadOnly::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, read_only.is_some())?;
                    read_only = Some(newitem);
                }
                "REF_MEMORY_SEGMENT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = RefMemorySegment::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, ref_memory_segment.is_some())?;
                    ref_memory_segment = Some(newitem);
                }
                "STEP_SIZE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "STEP_SIZE", A2lVersion::V1_6_0)?;
                    let newitem = StepSize::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, step_size.is_some())?;
                    step_size = Some(newitem);
                }
                "SYMBOL_LINK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = SymbolLink::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, symbol_link.is_some())?;
                    symbol_link = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __address_location,
                    __input_quantity_location,
                    __deposit_record_location,
                    __max_diff_location,
                    __conversion_location,
                    __max_axis_points_location,
                    __lower_limit_location,
                    __upper_limit_location,
                ),
            },
            name,
            long_identifier,
            address,
            input_quantity,
            deposit_record,
            max_diff,
            conversion,
            max_axis_points,
            lower_limit,
            upper_limit,
            annotation,
            byte_order,
            calibration_access,
            deposit,
            display_identifier,
            ecu_address_extension,
            extended_limits,
            format,
            function_list,
            guard_rails,
            if_data,
            max_refresh,
            model_link,
            monotony,
            phys_unit,
            read_only,
            ref_memory_segment,
            step_size,
            symbol_link,
        })
    }
}

impl AxisPts {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_integer(
            self.address,
            self.__block_info.item_location.2 .1,
            self.__block_info.item_location.2 .0,
        );
        writer.add_str(&self.input_quantity, self.__block_info.item_location.3);
        writer.add_str(&self.deposit_record, self.__block_info.item_location.4);
        writer.add_float(self.max_diff, self.__block_info.item_location.5);
        writer.add_str(&self.conversion, self.__block_info.item_location.6);
        writer.add_integer(
            self.max_axis_points,
            self.__block_info.item_location.7 .1,
            self.__block_info.item_location.7 .0,
        );
        writer.add_float(self.lower_limit, self.__block_info.item_location.8);
        writer.add_float(self.upper_limit, self.__block_info.item_location.9);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        for annotation in &self.annotation {
            let annotation_out = annotation.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ANNOTATION",
                item_text: annotation_out,
                is_block: true,
                incfile: &annotation.__block_info.incfile,
                uid: annotation.__block_info.uid,
                line: annotation.__block_info.line,
                start_offset: annotation.__block_info.start_offset,
                end_offset: annotation.__block_info.end_offset,
                position_restriction: annotation.pos_restrict(),
            });
        }
        if let Some(byte_order) = &self.byte_order {
            let byte_order_out = byte_order.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "BYTE_ORDER",
                item_text: byte_order_out,
                is_block: false,
                incfile: &byte_order.__block_info.incfile,
                uid: byte_order.__block_info.uid,
                line: byte_order.__block_info.line,
                start_offset: byte_order.__block_info.start_offset,
                end_offset: byte_order.__block_info.end_offset,
                position_restriction: byte_order.pos_restrict(),
            });
        }
        if let Some(calibration_access) = &self.calibration_access {
            let calibration_access_out = calibration_access.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "CALIBRATION_ACCESS",
                item_text: calibration_access_out,
                is_block: false,
                incfile: &calibration_access.__block_info.incfile,
                uid: calibration_access.__block_info.uid,
                line: calibration_access.__block_info.line,
                start_offset: calibration_access.__block_info.start_offset,
                end_offset: calibration_access.__block_info.end_offset,
                position_restriction: calibration_access.pos_restrict(),
            });
        }
        if let Some(deposit) = &self.deposit {
            let deposit_out = deposit.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DEPOSIT",
                item_text: deposit_out,
                is_block: false,
                incfile: &deposit.__block_info.incfile,
                uid: deposit.__block_info.uid,
                line: deposit.__block_info.line,
                start_offset: deposit.__block_info.start_offset,
                end_offset: deposit.__block_info.end_offset,
                position_restriction: deposit.pos_restrict(),
            });
        }
        if let Some(display_identifier) = &self.display_identifier {
            let display_identifier_out = display_identifier.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DISPLAY_IDENTIFIER",
                item_text: display_identifier_out,
                is_block: false,
                incfile: &display_identifier.__block_info.incfile,
                uid: display_identifier.__block_info.uid,
                line: display_identifier.__block_info.line,
                start_offset: display_identifier.__block_info.start_offset,
                end_offset: display_identifier.__block_info.end_offset,
                position_restriction: display_identifier.pos_restrict(),
            });
        }
        if let Some(ecu_address_extension) = &self.ecu_address_extension {
            let ecu_address_extension_out = ecu_address_extension.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ECU_ADDRESS_EXTENSION",
                item_text: ecu_address_extension_out,
                is_block: false,
                incfile: &ecu_address_extension.__block_info.incfile,
                uid: ecu_address_extension.__block_info.uid,
                line: ecu_address_extension.__block_info.line,
                start_offset: ecu_address_extension.__block_info.start_offset,
                end_offset: ecu_address_extension.__block_info.end_offset,
                position_restriction: ecu_address_extension.pos_restrict(),
            });
        }
        if let Some(extended_limits) = &self.extended_limits {
            let extended_limits_out = extended_limits.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "EXTENDED_LIMITS",
                item_text: extended_limits_out,
                is_block: false,
                incfile: &extended_limits.__block_info.incfile,
                uid: extended_limits.__block_info.uid,
                line: extended_limits.__block_info.line,
                start_offset: extended_limits.__block_info.start_offset,
                end_offset: extended_limits.__block_info.end_offset,
                position_restriction: extended_limits.pos_restrict(),
            });
        }
        if let Some(format) = &self.format {
            let format_out = format.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FORMAT",
                item_text: format_out,
                is_block: false,
                incfile: &format.__block_info.incfile,
                uid: format.__block_info.uid,
                line: format.__block_info.line,
                start_offset: format.__block_info.start_offset,
                end_offset: format.__block_info.end_offset,
                position_restriction: format.pos_restrict(),
            });
        }
        if let Some(function_list) = &self.function_list {
            let function_list_out = function_list.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FUNCTION_LIST",
                item_text: function_list_out,
                is_block: true,
                incfile: &function_list.__block_info.incfile,
                uid: function_list.__block_info.uid,
                line: function_list.__block_info.line,
                start_offset: function_list.__block_info.start_offset,
                end_offset: function_list.__block_info.end_offset,
                position_restriction: function_list.pos_restrict(),
            });
        }
        if let Some(guard_rails) = &self.guard_rails {
            let guard_rails_out = guard_rails.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "GUARD_RAILS",
                item_text: guard_rails_out,
                is_block: false,
                incfile: &guard_rails.__block_info.incfile,
                uid: guard_rails.__block_info.uid,
                line: guard_rails.__block_info.line,
                start_offset: guard_rails.__block_info.start_offset,
                end_offset: guard_rails.__block_info.end_offset,
                position_restriction: guard_rails.pos_restrict(),
            });
        }
        for if_data in &self.if_data {
            let if_data_out = if_data.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "IF_DATA",
                item_text: if_data_out,
                is_block: true,
                incfile: &if_data.__block_info.incfile,
                uid: if_data.__block_info.uid,
                line: if_data.__block_info.line,
                start_offset: if_data.__block_info.start_offset,
                end_offset: if_data.__block_info.end_offset,
                position_restriction: if_data.pos_restrict(),
            });
        }
        if let Some(max_refresh) = &self.max_refresh {
            let max_refresh_out = max_refresh.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MAX_REFRESH",
                item_text: max_refresh_out,
                is_block: false,
                incfile: &max_refresh.__block_info.incfile,
                uid: max_refresh.__block_info.uid,
                line: max_refresh.__block_info.line,
                start_offset: max_refresh.__block_info.start_offset,
                end_offset: max_refresh.__block_info.end_offset,
                position_restriction: max_refresh.pos_restrict(),
            });
        }
        if let Some(model_link) = &self.model_link {
            let model_link_out = model_link.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MODEL_LINK",
                item_text: model_link_out,
                is_block: false,
                incfile: &model_link.__block_info.incfile,
                uid: model_link.__block_info.uid,
                line: model_link.__block_info.line,
                start_offset: model_link.__block_info.start_offset,
                end_offset: model_link.__block_info.end_offset,
                position_restriction: model_link.pos_restrict(),
            });
        }
        if let Some(monotony) = &self.monotony {
            let monotony_out = monotony.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MONOTONY",
                item_text: monotony_out,
                is_block: false,
                incfile: &monotony.__block_info.incfile,
                uid: monotony.__block_info.uid,
                line: monotony.__block_info.line,
                start_offset: monotony.__block_info.start_offset,
                end_offset: monotony.__block_info.end_offset,
                position_restriction: monotony.pos_restrict(),
            });
        }
        if let Some(phys_unit) = &self.phys_unit {
            let phys_unit_out = phys_unit.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "PHYS_UNIT",
                item_text: phys_unit_out,
                is_block: false,
                incfile: &phys_unit.__block_info.incfile,
                uid: phys_unit.__block_info.uid,
                line: phys_unit.__block_info.line,
                start_offset: phys_unit.__block_info.start_offset,
                end_offset: phys_unit.__block_info.end_offset,
                position_restriction: phys_unit.pos_restrict(),
            });
        }
        if let Some(read_only) = &self.read_only {
            let read_only_out = read_only.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "READ_ONLY",
                item_text: read_only_out,
                is_block: false,
                incfile: &read_only.__block_info.incfile,
                uid: read_only.__block_info.uid,
                line: read_only.__block_info.line,
                start_offset: read_only.__block_info.start_offset,
                end_offset: read_only.__block_info.end_offset,
                position_restriction: read_only.pos_restrict(),
            });
        }
        if let Some(ref_memory_segment) = &self.ref_memory_segment {
            let ref_memory_segment_out = ref_memory_segment.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "REF_MEMORY_SEGMENT",
                item_text: ref_memory_segment_out,
                is_block: false,
                incfile: &ref_memory_segment.__block_info.incfile,
                uid: ref_memory_segment.__block_info.uid,
                line: ref_memory_segment.__block_info.line,
                start_offset: ref_memory_segment.__block_info.start_offset,
                end_offset: ref_memory_segment.__block_info.end_offset,
                position_restriction: ref_memory_segment.pos_restrict(),
            });
        }
        if let Some(step_size) = &self.step_size {
            let step_size_out = step_size.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "STEP_SIZE",
                item_text: step_size_out,
                is_block: false,
                incfile: &step_size.__block_info.incfile,
                uid: step_size.__block_info.uid,
                line: step_size.__block_info.line,
                start_offset: step_size.__block_info.start_offset,
                end_offset: step_size.__block_info.end_offset,
                position_restriction: step_size.pos_restrict(),
            });
        }
        if let Some(symbol_link) = &self.symbol_link {
            let symbol_link_out = symbol_link.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SYMBOL_LINK",
                item_text: symbol_link_out,
                is_block: false,
                incfile: &symbol_link.__block_info.incfile,
                uid: symbol_link.__block_info.uid,
                line: symbol_link.__block_info.line,
                start_offset: symbol_link.__block_info.start_offset,
                end_offset: symbol_link.__block_info.end_offset,
                position_restriction: symbol_link.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Description of the X, Y, Z, Z4 or Z5 axis points in memory
#[derive(Clone)]
pub struct AxisPtsDim {
    pub position: u16,
    pub datatype: DataType,
    pub index_incr: IndexOrder,
    pub addressing: AddrType,
    pub(crate) __block_info: BlockInfo<((u32, bool), u32, u32, u32)>,
}

impl std::fmt::Debug for AxisPtsDim {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AxisPtsDim")
            .field("position", &self.position)
            .field("datatype", &self.datatype)
            .field("index_incr", &self.index_incr)
            .field("addressing", &self.addressing)
            .finish()
    }
}

impl AxisPtsDim {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        position: u16,
        datatype: DataType,
        index_incr: IndexOrder,
        addressing: AddrType,
    ) -> Self {
        Self {
            position,
            datatype,
            index_incr,
            addressing,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), 0u32, 0u32, 0u32),
            },
        }
    }
}

impl PartialEq for AxisPtsDim {
    fn eq(&self, other: &Self) -> bool {
        (self.position == other.position)
            && (self.datatype == other.datatype)
            && (self.index_incr == other.index_incr)
            && (self.addressing == other.addressing)
    }
}

impl A2lObject<((u32, bool), u32, u32, u32)> for AxisPtsDim {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), u32, u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), u32, u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AxisPtsDim {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__position_location, position) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__datatype_location, datatype) = (
            parser.get_current_line_offset(),
            DataType::parse(parser, context, 0)?,
        );
        let (__index_incr_location, index_incr) = (
            parser.get_current_line_offset(),
            IndexOrder::parse(parser, context, 0)?,
        );
        let (__addressing_location, addressing) = (
            parser.get_current_line_offset(),
            AddrType::parse(parser, context, 0)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __position_location,
                    __datatype_location,
                    __index_incr_location,
                    __addressing_location,
                ),
            },
            position,
            datatype,
            index_incr,
            addressing,
        })
    }
}

impl AxisPtsDim {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.position,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_str(
            &self.datatype.to_string(),
            self.__block_info.item_location.1,
        );
        writer.add_str(
            &self.index_incr.to_string(),
            self.__block_info.item_location.2,
        );
        writer.add_str(
            &self.addressing.to_string(),
            self.__block_info.item_location.3,
        );
        writer.finish()
    }
}

/// Reference to an `AXIS_PTS` record
#[derive(Clone)]
pub struct AxisPtsRef {
    pub axis_points: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for AxisPtsRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AxisPtsRef")
            .field("axis_points", &self.axis_points)
            .finish()
    }
}

impl AxisPtsRef {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(axis_points: String) -> Self {
        Self {
            axis_points,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for AxisPtsRef {
    fn eq(&self, other: &Self) -> bool {
        self.axis_points == other.axis_points
    }
}

impl A2lObject<(u32, ())> for AxisPtsRef {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AxisPtsRef {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__axis_points_location, axis_points) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__axis_points_location, __dummy),
            },
            axis_points,
        })
    }
}

impl AxisPtsRef {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.axis_points, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Description of rescaling the axis values of an adjustable object
#[derive(Clone)]
pub struct AxisRescaleDim {
    pub position: u16,
    pub datatype: DataType,
    pub max_number_of_rescale_pairs: u16,
    pub index_incr: IndexOrder,
    pub addressing: AddrType,
    pub(crate) __block_info: BlockInfo<((u32, bool), u32, (u32, bool), u32, u32)>,
}

impl std::fmt::Debug for AxisRescaleDim {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AxisRescaleDim")
            .field("position", &self.position)
            .field("datatype", &self.datatype)
            .field(
                "max_number_of_rescale_pairs",
                &self.max_number_of_rescale_pairs,
            )
            .field("index_incr", &self.index_incr)
            .field("addressing", &self.addressing)
            .finish()
    }
}

impl AxisRescaleDim {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        position: u16,
        datatype: DataType,
        max_number_of_rescale_pairs: u16,
        index_incr: IndexOrder,
        addressing: AddrType,
    ) -> Self {
        Self {
            position,
            datatype,
            max_number_of_rescale_pairs,
            index_incr,
            addressing,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), 0u32, (0u32, false), 0u32, 0u32),
            },
        }
    }
}

impl PartialEq for AxisRescaleDim {
    fn eq(&self, other: &Self) -> bool {
        (self.position == other.position)
            && (self.datatype == other.datatype)
            && (self.max_number_of_rescale_pairs == other.max_number_of_rescale_pairs)
            && (self.index_incr == other.index_incr)
            && (self.addressing == other.addressing)
    }
}

impl A2lObject<((u32, bool), u32, (u32, bool), u32, u32)> for AxisRescaleDim {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), u32, (u32, bool), u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), u32, (u32, bool), u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for AxisRescaleDim {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__position_location, position) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__datatype_location, datatype) = (
            parser.get_current_line_offset(),
            DataType::parse(parser, context, 0)?,
        );
        let (__max_number_of_rescale_pairs_location, max_number_of_rescale_pairs) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__index_incr_location, index_incr) = (
            parser.get_current_line_offset(),
            IndexOrder::parse(parser, context, 0)?,
        );
        let (__addressing_location, addressing) = (
            parser.get_current_line_offset(),
            AddrType::parse(parser, context, 0)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __position_location,
                    __datatype_location,
                    __max_number_of_rescale_pairs_location,
                    __index_incr_location,
                    __addressing_location,
                ),
            },
            position,
            datatype,
            max_number_of_rescale_pairs,
            index_incr,
            addressing,
        })
    }
}

impl AxisRescaleDim {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.position,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_str(
            &self.datatype.to_string(),
            self.__block_info.item_location.1,
        );
        writer.add_integer(
            self.max_number_of_rescale_pairs,
            self.__block_info.item_location.2 .1,
            self.__block_info.item_location.2 .0,
        );
        writer.add_str(
            &self.index_incr.to_string(),
            self.__block_info.item_location.3,
        );
        writer.add_str(
            &self.addressing.to_string(),
            self.__block_info.item_location.4,
        );
        writer.finish()
    }
}

/// The `BIT_MASK` keyword can be used to mask out single bits of the value to be processed.
#[derive(Clone)]
pub struct BitMask {
    pub mask: u64,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for BitMask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("BitMask").field("mask", &self.mask).finish()
    }
}

impl BitMask {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(mask: u64) -> Self {
        Self {
            mask,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for BitMask {
    fn eq(&self, other: &Self) -> bool {
        self.mask == other.mask
    }
}

impl A2lObject<((u32, bool), ())> for BitMask {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for BitMask {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__mask_location, mask) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u64>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__mask_location, __dummy),
            },
            mask,
        })
    }
}

impl BitMask {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.mask,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// Used to perform bit operation on a value
#[derive(Clone)]
pub struct BitOperation {
    pub left_shift: Option<LeftShift>,
    pub right_shift: Option<RightShift>,
    pub sign_extend: Option<SignExtend>,
    pub(crate) __block_info: BlockInfo<()>,
}

impl std::fmt::Debug for BitOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("BitOperation")
            .field("left_shift", &self.left_shift)
            .field("right_shift", &self.right_shift)
            .field("sign_extend", &self.sign_extend)
            .finish()
    }
}

impl BitOperation {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            left_shift: None,
            right_shift: None,
            sign_extend: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (),
            },
        }
    }
}

impl PartialEq for BitOperation {
    fn eq(&self, other: &Self) -> bool {
        (self.left_shift == other.left_shift)
            && (self.right_shift == other.right_shift)
            && (self.sign_extend == other.sign_extend)
    }
}

impl A2lObject<()> for BitOperation {
    fn get_layout(&self) -> &BlockInfo<()> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<()> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(left_shift) = &mut self.left_shift {
            left_shift.merge_includes();
        }
        if let Some(right_shift) = &mut self.right_shift {
            right_shift.merge_includes();
        }
        if let Some(sign_extend) = &mut self.sign_extend {
            sign_extend.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for BitOperation {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut left_shift: Option<LeftShift> = None;
        let mut right_shift: Option<RightShift> = None;
        let mut sign_extend: Option<SignExtend> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 3usize] = ["LEFT_SHIFT", "RIGHT_SHIFT", "SIGN_EXTEND"];
            match tag {
                "LEFT_SHIFT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = LeftShift::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, left_shift.is_some())?;
                    left_shift = Some(newitem);
                }
                "RIGHT_SHIFT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = RightShift::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, right_shift.is_some())?;
                    right_shift = Some(newitem);
                }
                "SIGN_EXTEND" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = SignExtend::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, sign_extend.is_some())?;
                    sign_extend = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (),
            },
            left_shift,
            right_shift,
            sign_extend,
        })
    }
}

impl BitOperation {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(left_shift) = &self.left_shift {
            let left_shift_out = left_shift.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "LEFT_SHIFT",
                item_text: left_shift_out,
                is_block: false,
                incfile: &left_shift.__block_info.incfile,
                uid: left_shift.__block_info.uid,
                line: left_shift.__block_info.line,
                start_offset: left_shift.__block_info.start_offset,
                end_offset: left_shift.__block_info.end_offset,
                position_restriction: left_shift.pos_restrict(),
            });
        }
        if let Some(right_shift) = &self.right_shift {
            let right_shift_out = right_shift.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "RIGHT_SHIFT",
                item_text: right_shift_out,
                is_block: false,
                incfile: &right_shift.__block_info.incfile,
                uid: right_shift.__block_info.uid,
                line: right_shift.__block_info.line,
                start_offset: right_shift.__block_info.start_offset,
                end_offset: right_shift.__block_info.end_offset,
                position_restriction: right_shift.pos_restrict(),
            });
        }
        if let Some(sign_extend) = &self.sign_extend {
            let sign_extend_out = sign_extend.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SIGN_EXTEND",
                item_text: sign_extend_out,
                is_block: false,
                incfile: &sign_extend.__block_info.incfile,
                uid: sign_extend.__block_info.uid,
                line: sign_extend.__block_info.line,
                start_offset: sign_extend.__block_info.start_offset,
                end_offset: sign_extend.__block_info.end_offset,
                position_restriction: sign_extend.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Special data object that can be used to handle domain specific data, which are processed inside the ECU in a dedicated way
///
/// To the MCD system a blob is just an array of bytes without any interpretation
#[derive(Clone)]
pub struct Blob {
    pub name: String,
    pub long_identifier: String,
    pub start_address: u32,
    pub size: u32,
    pub address_type: Option<AddressType>,
    pub annotation: Vec<Annotation>,
    pub calibration_access: Option<CalibrationAccess>,
    pub display_identifier: Option<DisplayIdentifier>,
    pub ecu_address_extension: Option<EcuAddressExtension>,
    pub if_data: Vec<IfData>,
    pub max_refresh: Option<MaxRefresh>,
    pub model_link: Option<ModelLink>,
    pub symbol_link: Option<SymbolLink>,
    pub(crate) __block_info: BlockInfo<(u32, u32, (u32, bool), (u32, bool))>,
}

impl std::fmt::Debug for Blob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Blob")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("start_address", &self.start_address)
            .field("size", &self.size)
            .field("address_type", &self.address_type)
            .field("annotation", &self.annotation)
            .field("calibration_access", &self.calibration_access)
            .field("display_identifier", &self.display_identifier)
            .field("ecu_address_extension", &self.ecu_address_extension)
            .field("if_data", &self.if_data)
            .field("max_refresh", &self.max_refresh)
            .field("model_link", &self.model_link)
            .field("symbol_link", &self.symbol_link)
            .finish()
    }
}

impl Blob {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String, long_identifier: String, start_address: u32, size: u32) -> Self {
        Self {
            name,
            long_identifier,
            start_address,
            size,
            address_type: None,
            annotation: Vec::new(),
            calibration_access: None,
            display_identifier: None,
            ecu_address_extension: None,
            if_data: Vec::new(),
            max_refresh: None,
            model_link: None,
            symbol_link: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32, (1u32, false), (0u32, false)),
            },
        }
    }
}

impl PartialEq for Blob {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.start_address == other.start_address)
            && (self.size == other.size)
            && (self.address_type == other.address_type)
            && (self.annotation == other.annotation)
            && (self.calibration_access == other.calibration_access)
            && (self.display_identifier == other.display_identifier)
            && (self.ecu_address_extension == other.ecu_address_extension)
            && (self.if_data == other.if_data)
            && (self.max_refresh == other.max_refresh)
            && (self.model_link == other.model_link)
            && (self.symbol_link == other.symbol_link)
    }
}

impl A2lObject<(u32, u32, (u32, bool), (u32, bool))> for Blob {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, (u32, bool), (u32, bool))> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, (u32, bool), (u32, bool))> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(address_type) = &mut self.address_type {
            address_type.merge_includes();
        }
        for annotation in &mut self.annotation {
            annotation.merge_includes();
        }
        if let Some(calibration_access) = &mut self.calibration_access {
            calibration_access.merge_includes();
        }
        if let Some(display_identifier) = &mut self.display_identifier {
            display_identifier.merge_includes();
        }
        if let Some(ecu_address_extension) = &mut self.ecu_address_extension {
            ecu_address_extension.merge_includes();
        }
        for if_data in &mut self.if_data {
            if_data.merge_includes();
        }
        if let Some(max_refresh) = &mut self.max_refresh {
            max_refresh.merge_includes();
        }
        if let Some(model_link) = &mut self.model_link {
            model_link.merge_includes();
        }
        if let Some(symbol_link) = &mut self.symbol_link {
            symbol_link.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for Blob {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for Blob {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__start_address_location, start_address) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let (__size_location, size) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let mut address_type: Option<AddressType> = None;
        let mut annotation: Vec<Annotation> = Vec::new();
        let mut calibration_access: Option<CalibrationAccess> = None;
        let mut display_identifier: Option<DisplayIdentifier> = None;
        let mut ecu_address_extension: Option<EcuAddressExtension> = None;
        let mut if_data: Vec<IfData> = Vec::new();
        let mut max_refresh: Option<MaxRefresh> = None;
        let mut model_link: Option<ModelLink> = None;
        let mut symbol_link: Option<SymbolLink> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 9usize] = [
                "ADDRESS_TYPE",
                "ANNOTATION",
                "CALIBRATION_ACCESS",
                "DISPLAY_IDENTIFIER",
                "ECU_ADDRESS_EXTENSION",
                "IF_DATA",
                "MAX_REFRESH",
                "MODEL_LINK",
                "SYMBOL_LINK",
            ];
            match tag {
                "ADDRESS_TYPE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AddressType::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, address_type.is_some())?;
                    address_type = Some(newitem);
                }
                "ANNOTATION" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Annotation::parse(parser, &newcontext, line_offset)?;
                    annotation.push(newitem);
                }
                "CALIBRATION_ACCESS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = CalibrationAccess::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, calibration_access.is_some())?;
                    calibration_access = Some(newitem);
                }
                "DISPLAY_IDENTIFIER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = DisplayIdentifier::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, display_identifier.is_some())?;
                    display_identifier = Some(newitem);
                }
                "ECU_ADDRESS_EXTENSION" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = EcuAddressExtension::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        ecu_address_extension.is_some(),
                    )?;
                    ecu_address_extension = Some(newitem);
                }
                "IF_DATA" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = IfData::parse(parser, &newcontext, line_offset)?;
                    if_data.push(newitem);
                }
                "MAX_REFRESH" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = MaxRefresh::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, max_refresh.is_some())?;
                    max_refresh = Some(newitem);
                }
                "MODEL_LINK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ModelLink::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, model_link.is_some())?;
                    model_link = Some(newitem);
                }
                "SYMBOL_LINK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = SymbolLink::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, symbol_link.is_some())?;
                    symbol_link = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __start_address_location,
                    __size_location,
                ),
            },
            name,
            long_identifier,
            start_address,
            size,
            address_type,
            annotation,
            calibration_access,
            display_identifier,
            ecu_address_extension,
            if_data,
            max_refresh,
            model_link,
            symbol_link,
        })
    }
}

impl Blob {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_integer(
            self.start_address,
            self.__block_info.item_location.2 .1,
            self.__block_info.item_location.2 .0,
        );
        writer.add_integer(
            self.size,
            self.__block_info.item_location.3 .1,
            self.__block_info.item_location.3 .0,
        );
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(address_type) = &self.address_type {
            let address_type_out = address_type.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ADDRESS_TYPE",
                item_text: address_type_out,
                is_block: false,
                incfile: &address_type.__block_info.incfile,
                uid: address_type.__block_info.uid,
                line: address_type.__block_info.line,
                start_offset: address_type.__block_info.start_offset,
                end_offset: address_type.__block_info.end_offset,
                position_restriction: address_type.pos_restrict(),
            });
        }
        for annotation in &self.annotation {
            let annotation_out = annotation.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ANNOTATION",
                item_text: annotation_out,
                is_block: true,
                incfile: &annotation.__block_info.incfile,
                uid: annotation.__block_info.uid,
                line: annotation.__block_info.line,
                start_offset: annotation.__block_info.start_offset,
                end_offset: annotation.__block_info.end_offset,
                position_restriction: annotation.pos_restrict(),
            });
        }
        if let Some(calibration_access) = &self.calibration_access {
            let calibration_access_out = calibration_access.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "CALIBRATION_ACCESS",
                item_text: calibration_access_out,
                is_block: false,
                incfile: &calibration_access.__block_info.incfile,
                uid: calibration_access.__block_info.uid,
                line: calibration_access.__block_info.line,
                start_offset: calibration_access.__block_info.start_offset,
                end_offset: calibration_access.__block_info.end_offset,
                position_restriction: calibration_access.pos_restrict(),
            });
        }
        if let Some(display_identifier) = &self.display_identifier {
            let display_identifier_out = display_identifier.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DISPLAY_IDENTIFIER",
                item_text: display_identifier_out,
                is_block: false,
                incfile: &display_identifier.__block_info.incfile,
                uid: display_identifier.__block_info.uid,
                line: display_identifier.__block_info.line,
                start_offset: display_identifier.__block_info.start_offset,
                end_offset: display_identifier.__block_info.end_offset,
                position_restriction: display_identifier.pos_restrict(),
            });
        }
        if let Some(ecu_address_extension) = &self.ecu_address_extension {
            let ecu_address_extension_out = ecu_address_extension.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ECU_ADDRESS_EXTENSION",
                item_text: ecu_address_extension_out,
                is_block: false,
                incfile: &ecu_address_extension.__block_info.incfile,
                uid: ecu_address_extension.__block_info.uid,
                line: ecu_address_extension.__block_info.line,
                start_offset: ecu_address_extension.__block_info.start_offset,
                end_offset: ecu_address_extension.__block_info.end_offset,
                position_restriction: ecu_address_extension.pos_restrict(),
            });
        }
        for if_data in &self.if_data {
            let if_data_out = if_data.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "IF_DATA",
                item_text: if_data_out,
                is_block: true,
                incfile: &if_data.__block_info.incfile,
                uid: if_data.__block_info.uid,
                line: if_data.__block_info.line,
                start_offset: if_data.__block_info.start_offset,
                end_offset: if_data.__block_info.end_offset,
                position_restriction: if_data.pos_restrict(),
            });
        }
        if let Some(max_refresh) = &self.max_refresh {
            let max_refresh_out = max_refresh.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MAX_REFRESH",
                item_text: max_refresh_out,
                is_block: false,
                incfile: &max_refresh.__block_info.incfile,
                uid: max_refresh.__block_info.uid,
                line: max_refresh.__block_info.line,
                start_offset: max_refresh.__block_info.start_offset,
                end_offset: max_refresh.__block_info.end_offset,
                position_restriction: max_refresh.pos_restrict(),
            });
        }
        if let Some(model_link) = &self.model_link {
            let model_link_out = model_link.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MODEL_LINK",
                item_text: model_link_out,
                is_block: false,
                incfile: &model_link.__block_info.incfile,
                uid: model_link.__block_info.uid,
                line: model_link.__block_info.line,
                start_offset: model_link.__block_info.start_offset,
                end_offset: model_link.__block_info.end_offset,
                position_restriction: model_link.pos_restrict(),
            });
        }
        if let Some(symbol_link) = &self.symbol_link {
            let symbol_link_out = symbol_link.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SYMBOL_LINK",
                item_text: symbol_link_out,
                is_block: false,
                incfile: &symbol_link.__block_info.incfile,
                uid: symbol_link.__block_info.uid,
                line: symbol_link.__block_info.line,
                start_offset: symbol_link.__block_info.start_offset,
                end_offset: symbol_link.__block_info.end_offset,
                position_restriction: symbol_link.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Where the standard value does not apply this parameter can be used to specify the byte order
///
/// Specification: 3.5.24
#[derive(Clone)]
pub struct ByteOrder {
    pub byte_order: ByteOrderEnum,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for ByteOrder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ByteOrder")
            .field("byte_order", &self.byte_order)
            .finish()
    }
}

impl ByteOrder {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(byte_order: ByteOrderEnum) -> Self {
        Self {
            byte_order,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for ByteOrder {
    fn eq(&self, other: &Self) -> bool {
        self.byte_order == other.byte_order
    }
}

impl A2lObject<(u32, ())> for ByteOrder {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for ByteOrder {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__byte_order_location, byte_order) = (
            parser.get_current_line_offset(),
            ByteOrderEnum::parse(parser, context, 0)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__byte_order_location, __dummy),
            },
            byte_order,
        })
    }
}

impl ByteOrder {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(
            &self.byte_order.to_string(),
            self.__block_info.item_location.0,
        );
        writer.finish()
    }
}

/// Byte ordering of a value on the ECU
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ByteOrderEnum {
    LittleEndian,
    BigEndian,
    MsbLast,
    MsbFirst,
    MsbFirstMswLast,
    MsbLastMswFirst,
}

impl ParseableA2lObject for ByteOrderEnum {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "LITTLE_ENDIAN" => {
                parser.check_enumitem_version_upper(context, "LITTLE_ENDIAN", A2lVersion::V1_5_1);
                Ok(Self::LittleEndian)
            }
            "BIG_ENDIAN" => {
                parser.check_enumitem_version_upper(context, "BIG_ENDIAN", A2lVersion::V1_5_1);
                Ok(Self::BigEndian)
            }
            "MSB_LAST" => Ok(Self::MsbLast),
            "MSB_FIRST" => Ok(Self::MsbFirst),
            "MSB_FIRST_MSW_LAST" => {
                parser.check_enumitem_version_lower(
                    context,
                    "MSB_FIRST_MSW_LAST",
                    A2lVersion::V1_7_0,
                )?;
                Ok(Self::MsbFirstMswLast)
            }
            "MSB_LAST_MSW_FIRST" => {
                parser.check_enumitem_version_lower(
                    context,
                    "MSB_LAST_MSW_FIRST",
                    A2lVersion::V1_7_0,
                )?;
                Ok(Self::MsbLastMswFirst)
            }
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for ByteOrderEnum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::LittleEndian => "LITTLE_ENDIAN",
            Self::BigEndian => "BIG_ENDIAN",
            Self::MsbLast => "MSB_LAST",
            Self::MsbFirst => "MSB_FIRST",
            Self::MsbFirstMswLast => "MSB_FIRST_MSW_LAST",
            Self::MsbLastMswFirst => "MSB_LAST_MSW_FIRST",
        };
        f.write_str(tag)
    }
}

/// Specifies the access of a CHARACTERISTIC or `AXIS_PTS` for calibration
#[derive(Clone)]
pub struct CalibrationAccess {
    pub calibration_access: CalibrationAccessEnum,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for CalibrationAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CalibrationAccess")
            .field("calibration_access", &self.calibration_access)
            .finish()
    }
}

impl CalibrationAccess {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(calibration_access: CalibrationAccessEnum) -> Self {
        Self {
            calibration_access,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for CalibrationAccess {
    fn eq(&self, other: &Self) -> bool {
        self.calibration_access == other.calibration_access
    }
}

impl A2lObject<(u32, ())> for CalibrationAccess {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for CalibrationAccess {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__calibration_access_location, calibration_access) = (
            parser.get_current_line_offset(),
            CalibrationAccessEnum::parse(parser, context, 0)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__calibration_access_location, __dummy),
            },
            calibration_access,
        })
    }
}

impl CalibrationAccess {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(
            &self.calibration_access.to_string(),
            self.__block_info.item_location.0,
        );
        writer.finish()
    }
}

/// Type of access that is possible for a CHARACTERISTIC or `AXIS_PTS` object
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CalibrationAccessEnum {
    Calibration,
    NoCalibration,
    NotInMcdSystem,
    OfflineCalibration,
}

impl ParseableA2lObject for CalibrationAccessEnum {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "CALIBRATION" => Ok(Self::Calibration),
            "NO_CALIBRATION" => Ok(Self::NoCalibration),
            "NOT_IN_MCD_SYSTEM" => Ok(Self::NotInMcdSystem),
            "OFFLINE_CALIBRATION" => Ok(Self::OfflineCalibration),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for CalibrationAccessEnum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::Calibration => "CALIBRATION",
            Self::NoCalibration => "NO_CALIBRATION",
            Self::NotInMcdSystem => "NOT_IN_MCD_SYSTEM",
            Self::OfflineCalibration => "OFFLINE_CALIBRATION",
        };
        f.write_str(tag)
    }
}

/// calibration method specific data
#[derive(Clone)]
pub struct CalibrationHandle {
    pub handle_list: Vec<i32>,
    pub calibration_handle_text: Option<CalibrationHandleText>,
    pub(crate) __block_info: BlockInfo<(Vec<(u32, bool)>, ())>,
}

impl std::fmt::Debug for CalibrationHandle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CalibrationHandle")
            .field("handle_list", &self.handle_list)
            .field("calibration_handle_text", &self.calibration_handle_text)
            .finish()
    }
}

impl CalibrationHandle {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            handle_list: Vec::new(),
            calibration_handle_text: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<(u32, bool)>::new(), ()),
            },
        }
    }
}

impl PartialEq for CalibrationHandle {
    fn eq(&self, other: &Self) -> bool {
        (self.handle_list == other.handle_list)
            && (self.calibration_handle_text == other.calibration_handle_text)
    }
}

impl A2lObject<(Vec<(u32, bool)>, ())> for CalibrationHandle {
    fn get_layout(&self) -> &BlockInfo<(Vec<(u32, bool)>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<(u32, bool)>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(calibration_handle_text) = &mut self.calibration_handle_text {
            calibration_handle_text.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for CalibrationHandle {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut handle_list = Vec::new();
        let mut __handle_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok({
                        let line = parser.get_current_line_offset();
                        let (value, is_hex) = parser.get_integer::<i32>(context)?;
                        ((line, is_hex), value)
                    })
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    handle_list.push(value);
                    __handle_list_location.push(location);
                }
            }
        }
        let mut calibration_handle_text: Option<CalibrationHandleText> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 1usize] = ["CALIBRATION_HANDLE_TEXT"];
            match tag {
                "CALIBRATION_HANDLE_TEXT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "CALIBRATION_HANDLE_TEXT",
                        A2lVersion::V1_6_0,
                    )?;
                    let newitem = CalibrationHandleText::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        calibration_handle_text.is_some(),
                    )?;
                    calibration_handle_text = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__handle_list_location, __dummy),
            },
            handle_list,
            calibration_handle_text,
        })
    }
}

impl CalibrationHandle {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.handle_list.iter().enumerate() {
            writer.add_integer(
                *seqitem0,
                self.__block_info
                    .item_location
                    .0
                    .get(seqidx0)
                    .unwrap_or(&(0, false))
                    .1,
                self.__block_info
                    .item_location
                    .0
                    .get(seqidx0)
                    .unwrap_or(&(0, false))
                    .0,
            );
        }
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(calibration_handle_text) = &self.calibration_handle_text {
            let calibration_handle_text_out = calibration_handle_text.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "CALIBRATION_HANDLE_TEXT",
                item_text: calibration_handle_text_out,
                is_block: false,
                incfile: &calibration_handle_text.__block_info.incfile,
                uid: calibration_handle_text.__block_info.uid,
                line: calibration_handle_text.__block_info.line,
                start_offset: calibration_handle_text.__block_info.start_offset,
                end_offset: calibration_handle_text.__block_info.end_offset,
                position_restriction: calibration_handle_text.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Additional text for a calibration handle
///
/// Specification: 3.5.27
#[derive(Clone)]
pub struct CalibrationHandleText {
    pub text: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for CalibrationHandleText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CalibrationHandleText")
            .field("text", &self.text)
            .finish()
    }
}

impl CalibrationHandleText {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(text: String) -> Self {
        Self {
            text,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for CalibrationHandleText {
    fn eq(&self, other: &Self) -> bool {
        self.text == other.text
    }
}

impl A2lObject<(u32, ())> for CalibrationHandleText {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for CalibrationHandleText {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__text_location, text) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__text_location, __dummy),
            },
            text,
        })
    }
}

impl CalibrationHandleText {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.text, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Indicates the different methods of access that are implemented in the ECU
///
/// Valid method strings are: \"`InCircuit`\", \"SERAM\", \"DSERAP\", \"BSERAP\"
#[derive(Clone)]
pub struct CalibrationMethod {
    pub method: String,
    pub version: u32,
    pub calibration_handle: Option<CalibrationHandle>,
    pub(crate) __block_info: BlockInfo<(u32, (u32, bool))>,
}

impl std::fmt::Debug for CalibrationMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CalibrationMethod")
            .field("method", &self.method)
            .field("version", &self.version)
            .field("calibration_handle", &self.calibration_handle)
            .finish()
    }
}

impl CalibrationMethod {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(method: String, version: u32) -> Self {
        Self {
            method,
            version,
            calibration_handle: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (1u32, (0u32, false)),
            },
        }
    }
}

impl PartialEq for CalibrationMethod {
    fn eq(&self, other: &Self) -> bool {
        (self.method == other.method)
            && (self.version == other.version)
            && (self.calibration_handle == other.calibration_handle)
    }
}

impl A2lObject<(u32, (u32, bool))> for CalibrationMethod {
    fn get_layout(&self) -> &BlockInfo<(u32, (u32, bool))> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, (u32, bool))> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(calibration_handle) = &mut self.calibration_handle {
            calibration_handle.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for CalibrationMethod {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__method_location, method) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__version_location, version) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let mut calibration_handle: Option<CalibrationHandle> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 1usize] = ["CALIBRATION_HANDLE"];
            match tag {
                "CALIBRATION_HANDLE" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = CalibrationHandle::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, calibration_handle.is_some())?;
                    calibration_handle = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__method_location, __version_location),
            },
            method,
            version,
            calibration_handle,
        })
    }
}

impl CalibrationMethod {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.method, self.__block_info.item_location.0);
        writer.add_integer(
            self.version,
            self.__block_info.item_location.1 .1,
            self.__block_info.item_location.1 .0,
        );
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(calibration_handle) = &self.calibration_handle {
            let calibration_handle_out = calibration_handle.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "CALIBRATION_HANDLE",
                item_text: calibration_handle_out,
                is_block: true,
                incfile: &calibration_handle.__block_info.incfile,
                uid: calibration_handle.__block_info.uid,
                line: calibration_handle.__block_info.line,
                start_offset: calibration_handle.__block_info.start_offset,
                end_offset: calibration_handle.__block_info.end_offset,
                position_restriction: calibration_handle.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Describes the encoding of a string, if it is not ASCII
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CharacterEncoding {
    Utf8,
    Utf16,
    Utf32,
}

impl ParseableA2lObject for CharacterEncoding {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "UTF8" => Ok(Self::Utf8),
            "UTF16" => Ok(Self::Utf16),
            "UTF32" => Ok(Self::Utf32),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for CharacterEncoding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::Utf8 => "UTF8",
            Self::Utf16 => "UTF16",
            Self::Utf32 => "UTF32",
        };
        f.write_str(tag)
    }
}

/// Specifies all the parameters of an adjustable object
#[derive(Clone)]
pub struct Characteristic {
    pub name: String,
    pub long_identifier: String,
    pub characteristic_type: CharacteristicType,
    pub address: u32,
    pub deposit: String,
    pub max_diff: f64,
    pub conversion: String,
    pub lower_limit: f64,
    pub upper_limit: f64,
    pub annotation: Vec<Annotation>,
    pub axis_descr: Vec<AxisDescr>,
    pub bit_mask: Option<BitMask>,
    pub byte_order: Option<ByteOrder>,
    pub calibration_access: Option<CalibrationAccess>,
    pub comparison_quantity: Option<ComparisonQuantity>,
    pub dependent_characteristic: Option<DependentCharacteristic>,
    pub discrete: Option<Discrete>,
    pub display_identifier: Option<DisplayIdentifier>,
    pub ecu_address_extension: Option<EcuAddressExtension>,
    pub encoding: Option<Encoding>,
    pub extended_limits: Option<ExtendedLimits>,
    pub format: Option<Format>,
    pub function_list: Option<FunctionList>,
    pub guard_rails: Option<GuardRails>,
    pub if_data: Vec<IfData>,
    pub map_list: Option<MapList>,
    pub matrix_dim: Option<MatrixDim>,
    pub max_refresh: Option<MaxRefresh>,
    pub model_link: Option<ModelLink>,
    pub number: Option<Number>,
    pub phys_unit: Option<PhysUnit>,
    pub read_only: Option<ReadOnly>,
    pub ref_memory_segment: Option<RefMemorySegment>,
    pub step_size: Option<StepSize>,
    pub symbol_link: Option<SymbolLink>,
    pub virtual_characteristic: Option<VirtualCharacteristic>,
    pub(crate) __block_info: BlockInfo<(u32, u32, u32, (u32, bool), u32, u32, u32, u32, u32)>,
}

impl std::fmt::Debug for Characteristic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Characteristic")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("characteristic_type", &self.characteristic_type)
            .field("address", &self.address)
            .field("deposit", &self.deposit)
            .field("max_diff", &self.max_diff)
            .field("conversion", &self.conversion)
            .field("lower_limit", &self.lower_limit)
            .field("upper_limit", &self.upper_limit)
            .field("annotation", &self.annotation)
            .field("axis_descr", &self.axis_descr)
            .field("bit_mask", &self.bit_mask)
            .field("byte_order", &self.byte_order)
            .field("calibration_access", &self.calibration_access)
            .field("comparison_quantity", &self.comparison_quantity)
            .field("dependent_characteristic", &self.dependent_characteristic)
            .field("discrete", &self.discrete)
            .field("display_identifier", &self.display_identifier)
            .field("ecu_address_extension", &self.ecu_address_extension)
            .field("encoding", &self.encoding)
            .field("extended_limits", &self.extended_limits)
            .field("format", &self.format)
            .field("function_list", &self.function_list)
            .field("guard_rails", &self.guard_rails)
            .field("if_data", &self.if_data)
            .field("map_list", &self.map_list)
            .field("matrix_dim", &self.matrix_dim)
            .field("max_refresh", &self.max_refresh)
            .field("model_link", &self.model_link)
            .field("number", &self.number)
            .field("phys_unit", &self.phys_unit)
            .field("read_only", &self.read_only)
            .field("ref_memory_segment", &self.ref_memory_segment)
            .field("step_size", &self.step_size)
            .field("symbol_link", &self.symbol_link)
            .field("virtual_characteristic", &self.virtual_characteristic)
            .finish()
    }
}

impl Characteristic {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        name: String,
        long_identifier: String,
        characteristic_type: CharacteristicType,
        address: u32,
        deposit: String,
        max_diff: f64,
        conversion: String,
        lower_limit: f64,
        upper_limit: f64,
    ) -> Self {
        Self {
            name,
            long_identifier,
            characteristic_type,
            address,
            deposit,
            max_diff,
            conversion,
            lower_limit,
            upper_limit,
            annotation: Vec::new(),
            axis_descr: Vec::new(),
            bit_mask: None,
            byte_order: None,
            calibration_access: None,
            comparison_quantity: None,
            dependent_characteristic: None,
            discrete: None,
            display_identifier: None,
            ecu_address_extension: None,
            encoding: None,
            extended_limits: None,
            format: None,
            function_list: None,
            guard_rails: None,
            if_data: Vec::new(),
            map_list: None,
            matrix_dim: None,
            max_refresh: None,
            model_link: None,
            number: None,
            phys_unit: None,
            read_only: None,
            ref_memory_segment: None,
            step_size: None,
            symbol_link: None,
            virtual_characteristic: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (
                    0u32,
                    0u32,
                    1u32,
                    (0u32, false),
                    0u32,
                    0u32,
                    0u32,
                    0u32,
                    0u32,
                ),
            },
        }
    }
}

impl PartialEq for Characteristic {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.characteristic_type == other.characteristic_type)
            && (self.address == other.address)
            && (self.deposit == other.deposit)
            && (self.max_diff == other.max_diff)
            && (self.conversion == other.conversion)
            && (self.lower_limit == other.lower_limit)
            && (self.upper_limit == other.upper_limit)
            && (self.annotation == other.annotation)
            && (self.axis_descr == other.axis_descr)
            && (self.bit_mask == other.bit_mask)
            && (self.byte_order == other.byte_order)
            && (self.calibration_access == other.calibration_access)
            && (self.comparison_quantity == other.comparison_quantity)
            && (self.dependent_characteristic == other.dependent_characteristic)
            && (self.discrete == other.discrete)
            && (self.display_identifier == other.display_identifier)
            && (self.ecu_address_extension == other.ecu_address_extension)
            && (self.encoding == other.encoding)
            && (self.extended_limits == other.extended_limits)
            && (self.format == other.format)
            && (self.function_list == other.function_list)
            && (self.guard_rails == other.guard_rails)
            && (self.if_data == other.if_data)
            && (self.map_list == other.map_list)
            && (self.matrix_dim == other.matrix_dim)
            && (self.max_refresh == other.max_refresh)
            && (self.model_link == other.model_link)
            && (self.number == other.number)
            && (self.phys_unit == other.phys_unit)
            && (self.read_only == other.read_only)
            && (self.ref_memory_segment == other.ref_memory_segment)
            && (self.step_size == other.step_size)
            && (self.symbol_link == other.symbol_link)
            && (self.virtual_characteristic == other.virtual_characteristic)
    }
}

impl A2lObject<(u32, u32, u32, (u32, bool), u32, u32, u32, u32, u32)> for Characteristic {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, u32, (u32, bool), u32, u32, u32, u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(
        &mut self,
    ) -> &mut BlockInfo<(u32, u32, u32, (u32, bool), u32, u32, u32, u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        for annotation in &mut self.annotation {
            annotation.merge_includes();
        }
        for axis_descr in &mut self.axis_descr {
            axis_descr.merge_includes();
        }
        if let Some(bit_mask) = &mut self.bit_mask {
            bit_mask.merge_includes();
        }
        if let Some(byte_order) = &mut self.byte_order {
            byte_order.merge_includes();
        }
        if let Some(calibration_access) = &mut self.calibration_access {
            calibration_access.merge_includes();
        }
        if let Some(comparison_quantity) = &mut self.comparison_quantity {
            comparison_quantity.merge_includes();
        }
        if let Some(dependent_characteristic) = &mut self.dependent_characteristic {
            dependent_characteristic.merge_includes();
        }
        if let Some(discrete) = &mut self.discrete {
            discrete.merge_includes();
        }
        if let Some(display_identifier) = &mut self.display_identifier {
            display_identifier.merge_includes();
        }
        if let Some(ecu_address_extension) = &mut self.ecu_address_extension {
            ecu_address_extension.merge_includes();
        }
        if let Some(encoding) = &mut self.encoding {
            encoding.merge_includes();
        }
        if let Some(extended_limits) = &mut self.extended_limits {
            extended_limits.merge_includes();
        }
        if let Some(format) = &mut self.format {
            format.merge_includes();
        }
        if let Some(function_list) = &mut self.function_list {
            function_list.merge_includes();
        }
        if let Some(guard_rails) = &mut self.guard_rails {
            guard_rails.merge_includes();
        }
        for if_data in &mut self.if_data {
            if_data.merge_includes();
        }
        if let Some(map_list) = &mut self.map_list {
            map_list.merge_includes();
        }
        if let Some(matrix_dim) = &mut self.matrix_dim {
            matrix_dim.merge_includes();
        }
        if let Some(max_refresh) = &mut self.max_refresh {
            max_refresh.merge_includes();
        }
        if let Some(model_link) = &mut self.model_link {
            model_link.merge_includes();
        }
        if let Some(number) = &mut self.number {
            number.merge_includes();
        }
        if let Some(phys_unit) = &mut self.phys_unit {
            phys_unit.merge_includes();
        }
        if let Some(read_only) = &mut self.read_only {
            read_only.merge_includes();
        }
        if let Some(ref_memory_segment) = &mut self.ref_memory_segment {
            ref_memory_segment.merge_includes();
        }
        if let Some(step_size) = &mut self.step_size {
            step_size.merge_includes();
        }
        if let Some(symbol_link) = &mut self.symbol_link {
            symbol_link.merge_includes();
        }
        if let Some(virtual_characteristic) = &mut self.virtual_characteristic {
            virtual_characteristic.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for Characteristic {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for Characteristic {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__characteristic_type_location, characteristic_type) = (
            parser.get_current_line_offset(),
            CharacteristicType::parse(parser, context, 0)?,
        );
        let (__address_location, address) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let (__deposit_location, deposit) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__max_diff_location, max_diff) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__conversion_location, conversion) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__lower_limit_location, lower_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__upper_limit_location, upper_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let mut annotation: Vec<Annotation> = Vec::new();
        let mut axis_descr: Vec<AxisDescr> = Vec::new();
        let mut bit_mask: Option<BitMask> = None;
        let mut byte_order: Option<ByteOrder> = None;
        let mut calibration_access: Option<CalibrationAccess> = None;
        let mut comparison_quantity: Option<ComparisonQuantity> = None;
        let mut dependent_characteristic: Option<DependentCharacteristic> = None;
        let mut discrete: Option<Discrete> = None;
        let mut display_identifier: Option<DisplayIdentifier> = None;
        let mut ecu_address_extension: Option<EcuAddressExtension> = None;
        let mut encoding: Option<Encoding> = None;
        let mut extended_limits: Option<ExtendedLimits> = None;
        let mut format: Option<Format> = None;
        let mut function_list: Option<FunctionList> = None;
        let mut guard_rails: Option<GuardRails> = None;
        let mut if_data: Vec<IfData> = Vec::new();
        let mut map_list: Option<MapList> = None;
        let mut matrix_dim: Option<MatrixDim> = None;
        let mut max_refresh: Option<MaxRefresh> = None;
        let mut model_link: Option<ModelLink> = None;
        let mut number: Option<Number> = None;
        let mut phys_unit: Option<PhysUnit> = None;
        let mut read_only: Option<ReadOnly> = None;
        let mut ref_memory_segment: Option<RefMemorySegment> = None;
        let mut step_size: Option<StepSize> = None;
        let mut symbol_link: Option<SymbolLink> = None;
        let mut virtual_characteristic: Option<VirtualCharacteristic> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 27usize] = [
                "ANNOTATION",
                "AXIS_DESCR",
                "BIT_MASK",
                "BYTE_ORDER",
                "CALIBRATION_ACCESS",
                "COMPARISON_QUANTITY",
                "DEPENDENT_CHARACTERISTIC",
                "DISCRETE",
                "DISPLAY_IDENTIFIER",
                "ECU_ADDRESS_EXTENSION",
                "ENCODING",
                "EXTENDED_LIMITS",
                "FORMAT",
                "FUNCTION_LIST",
                "GUARD_RAILS",
                "IF_DATA",
                "MAP_LIST",
                "MATRIX_DIM",
                "MAX_REFRESH",
                "MODEL_LINK",
                "NUMBER",
                "PHYS_UNIT",
                "READ_ONLY",
                "REF_MEMORY_SEGMENT",
                "STEP_SIZE",
                "SYMBOL_LINK",
                "VIRTUAL_CHARACTERISTIC",
            ];
            match tag {
                "ANNOTATION" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Annotation::parse(parser, &newcontext, line_offset)?;
                    annotation.push(newitem);
                }
                "AXIS_DESCR" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = AxisDescr::parse(parser, &newcontext, line_offset)?;
                    axis_descr.push(newitem);
                }
                "BIT_MASK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = BitMask::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, bit_mask.is_some())?;
                    bit_mask = Some(newitem);
                }
                "BYTE_ORDER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ByteOrder::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, byte_order.is_some())?;
                    byte_order = Some(newitem);
                }
                "CALIBRATION_ACCESS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = CalibrationAccess::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, calibration_access.is_some())?;
                    calibration_access = Some(newitem);
                }
                "COMPARISON_QUANTITY" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ComparisonQuantity::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        comparison_quantity.is_some(),
                    )?;
                    comparison_quantity = Some(newitem);
                }
                "DEPENDENT_CHARACTERISTIC" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = DependentCharacteristic::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        dependent_characteristic.is_some(),
                    )?;
                    dependent_characteristic = Some(newitem);
                }
                "DISCRETE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "DISCRETE", A2lVersion::V1_6_0)?;
                    let newitem = Discrete::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, discrete.is_some())?;
                    discrete = Some(newitem);
                }
                "DISPLAY_IDENTIFIER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = DisplayIdentifier::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, display_identifier.is_some())?;
                    display_identifier = Some(newitem);
                }
                "ECU_ADDRESS_EXTENSION" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = EcuAddressExtension::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        ecu_address_extension.is_some(),
                    )?;
                    ecu_address_extension = Some(newitem);
                }
                "ENCODING" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "ENCODING", A2lVersion::V1_7_0)?;
                    let newitem = Encoding::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, encoding.is_some())?;
                    encoding = Some(newitem);
                }
                "EXTENDED_LIMITS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ExtendedLimits::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, extended_limits.is_some())?;
                    extended_limits = Some(newitem);
                }
                "FORMAT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Format::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, format.is_some())?;
                    format = Some(newitem);
                }
                "FUNCTION_LIST" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = FunctionList::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, function_list.is_some())?;
                    function_list = Some(newitem);
                }
                "GUARD_RAILS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = GuardRails::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, guard_rails.is_some())?;
                    guard_rails = Some(newitem);
                }
                "IF_DATA" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = IfData::parse(parser, &newcontext, line_offset)?;
                    if_data.push(newitem);
                }
                "MAP_LIST" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = MapList::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, map_list.is_some())?;
                    map_list = Some(newitem);
                }
                "MATRIX_DIM" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = MatrixDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, matrix_dim.is_some())?;
                    matrix_dim = Some(newitem);
                }
                "MAX_REFRESH" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = MaxRefresh::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, max_refresh.is_some())?;
                    max_refresh = Some(newitem);
                }
                "MODEL_LINK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "MODEL_LINK", A2lVersion::V1_7_0)?;
                    let newitem = ModelLink::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, model_link.is_some())?;
                    model_link = Some(newitem);
                }
                "NUMBER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Number::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, number.is_some())?;
                    number = Some(newitem);
                }
                "PHYS_UNIT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "PHYS_UNIT", A2lVersion::V1_6_0)?;
                    let newitem = PhysUnit::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, phys_unit.is_some())?;
                    phys_unit = Some(newitem);
                }
                "READ_ONLY" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ReadOnly::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, read_only.is_some())?;
                    read_only = Some(newitem);
                }
                "REF_MEMORY_SEGMENT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = RefMemorySegment::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, ref_memory_segment.is_some())?;
                    ref_memory_segment = Some(newitem);
                }
                "STEP_SIZE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "STEP_SIZE", A2lVersion::V1_6_0)?;
                    let newitem = StepSize::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, step_size.is_some())?;
                    step_size = Some(newitem);
                }
                "SYMBOL_LINK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "SYMBOL_LINK", A2lVersion::V1_6_0)?;
                    let newitem = SymbolLink::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, symbol_link.is_some())?;
                    symbol_link = Some(newitem);
                }
                "VIRTUAL_CHARACTERISTIC" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = VirtualCharacteristic::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        virtual_characteristic.is_some(),
                    )?;
                    virtual_characteristic = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __characteristic_type_location,
                    __address_location,
                    __deposit_location,
                    __max_diff_location,
                    __conversion_location,
                    __lower_limit_location,
                    __upper_limit_location,
                ),
            },
            name,
            long_identifier,
            characteristic_type,
            address,
            deposit,
            max_diff,
            conversion,
            lower_limit,
            upper_limit,
            annotation,
            axis_descr,
            bit_mask,
            byte_order,
            calibration_access,
            comparison_quantity,
            dependent_characteristic,
            discrete,
            display_identifier,
            ecu_address_extension,
            encoding,
            extended_limits,
            format,
            function_list,
            guard_rails,
            if_data,
            map_list,
            matrix_dim,
            max_refresh,
            model_link,
            number,
            phys_unit,
            read_only,
            ref_memory_segment,
            step_size,
            symbol_link,
            virtual_characteristic,
        })
    }
}

impl Characteristic {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_str(
            &self.characteristic_type.to_string(),
            self.__block_info.item_location.2,
        );
        writer.add_integer(
            self.address,
            self.__block_info.item_location.3 .1,
            self.__block_info.item_location.3 .0,
        );
        writer.add_str(&self.deposit, self.__block_info.item_location.4);
        writer.add_float(self.max_diff, self.__block_info.item_location.5);
        writer.add_str(&self.conversion, self.__block_info.item_location.6);
        writer.add_float(self.lower_limit, self.__block_info.item_location.7);
        writer.add_float(self.upper_limit, self.__block_info.item_location.8);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        for annotation in &self.annotation {
            let annotation_out = annotation.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ANNOTATION",
                item_text: annotation_out,
                is_block: true,
                incfile: &annotation.__block_info.incfile,
                uid: annotation.__block_info.uid,
                line: annotation.__block_info.line,
                start_offset: annotation.__block_info.start_offset,
                end_offset: annotation.__block_info.end_offset,
                position_restriction: annotation.pos_restrict(),
            });
        }
        for axis_descr in &self.axis_descr {
            let axis_descr_out = axis_descr.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AXIS_DESCR",
                item_text: axis_descr_out,
                is_block: true,
                incfile: &axis_descr.__block_info.incfile,
                uid: axis_descr.__block_info.uid,
                line: axis_descr.__block_info.line,
                start_offset: axis_descr.__block_info.start_offset,
                end_offset: axis_descr.__block_info.end_offset,
                position_restriction: axis_descr.pos_restrict(),
            });
        }
        if let Some(bit_mask) = &self.bit_mask {
            let bit_mask_out = bit_mask.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "BIT_MASK",
                item_text: bit_mask_out,
                is_block: false,
                incfile: &bit_mask.__block_info.incfile,
                uid: bit_mask.__block_info.uid,
                line: bit_mask.__block_info.line,
                start_offset: bit_mask.__block_info.start_offset,
                end_offset: bit_mask.__block_info.end_offset,
                position_restriction: bit_mask.pos_restrict(),
            });
        }
        if let Some(byte_order) = &self.byte_order {
            let byte_order_out = byte_order.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "BYTE_ORDER",
                item_text: byte_order_out,
                is_block: false,
                incfile: &byte_order.__block_info.incfile,
                uid: byte_order.__block_info.uid,
                line: byte_order.__block_info.line,
                start_offset: byte_order.__block_info.start_offset,
                end_offset: byte_order.__block_info.end_offset,
                position_restriction: byte_order.pos_restrict(),
            });
        }
        if let Some(calibration_access) = &self.calibration_access {
            let calibration_access_out = calibration_access.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "CALIBRATION_ACCESS",
                item_text: calibration_access_out,
                is_block: false,
                incfile: &calibration_access.__block_info.incfile,
                uid: calibration_access.__block_info.uid,
                line: calibration_access.__block_info.line,
                start_offset: calibration_access.__block_info.start_offset,
                end_offset: calibration_access.__block_info.end_offset,
                position_restriction: calibration_access.pos_restrict(),
            });
        }
        if let Some(comparison_quantity) = &self.comparison_quantity {
            let comparison_quantity_out = comparison_quantity.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "COMPARISON_QUANTITY",
                item_text: comparison_quantity_out,
                is_block: false,
                incfile: &comparison_quantity.__block_info.incfile,
                uid: comparison_quantity.__block_info.uid,
                line: comparison_quantity.__block_info.line,
                start_offset: comparison_quantity.__block_info.start_offset,
                end_offset: comparison_quantity.__block_info.end_offset,
                position_restriction: comparison_quantity.pos_restrict(),
            });
        }
        if let Some(dependent_characteristic) = &self.dependent_characteristic {
            let dependent_characteristic_out = dependent_characteristic.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DEPENDENT_CHARACTERISTIC",
                item_text: dependent_characteristic_out,
                is_block: true,
                incfile: &dependent_characteristic.__block_info.incfile,
                uid: dependent_characteristic.__block_info.uid,
                line: dependent_characteristic.__block_info.line,
                start_offset: dependent_characteristic.__block_info.start_offset,
                end_offset: dependent_characteristic.__block_info.end_offset,
                position_restriction: dependent_characteristic.pos_restrict(),
            });
        }
        if let Some(discrete) = &self.discrete {
            let discrete_out = discrete.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DISCRETE",
                item_text: discrete_out,
                is_block: false,
                incfile: &discrete.__block_info.incfile,
                uid: discrete.__block_info.uid,
                line: discrete.__block_info.line,
                start_offset: discrete.__block_info.start_offset,
                end_offset: discrete.__block_info.end_offset,
                position_restriction: discrete.pos_restrict(),
            });
        }
        if let Some(display_identifier) = &self.display_identifier {
            let display_identifier_out = display_identifier.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DISPLAY_IDENTIFIER",
                item_text: display_identifier_out,
                is_block: false,
                incfile: &display_identifier.__block_info.incfile,
                uid: display_identifier.__block_info.uid,
                line: display_identifier.__block_info.line,
                start_offset: display_identifier.__block_info.start_offset,
                end_offset: display_identifier.__block_info.end_offset,
                position_restriction: display_identifier.pos_restrict(),
            });
        }
        if let Some(ecu_address_extension) = &self.ecu_address_extension {
            let ecu_address_extension_out = ecu_address_extension.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ECU_ADDRESS_EXTENSION",
                item_text: ecu_address_extension_out,
                is_block: false,
                incfile: &ecu_address_extension.__block_info.incfile,
                uid: ecu_address_extension.__block_info.uid,
                line: ecu_address_extension.__block_info.line,
                start_offset: ecu_address_extension.__block_info.start_offset,
                end_offset: ecu_address_extension.__block_info.end_offset,
                position_restriction: ecu_address_extension.pos_restrict(),
            });
        }
        if let Some(encoding) = &self.encoding {
            let encoding_out = encoding.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ENCODING",
                item_text: encoding_out,
                is_block: false,
                incfile: &encoding.__block_info.incfile,
                uid: encoding.__block_info.uid,
                line: encoding.__block_info.line,
                start_offset: encoding.__block_info.start_offset,
                end_offset: encoding.__block_info.end_offset,
                position_restriction: encoding.pos_restrict(),
            });
        }
        if let Some(extended_limits) = &self.extended_limits {
            let extended_limits_out = extended_limits.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "EXTENDED_LIMITS",
                item_text: extended_limits_out,
                is_block: false,
                incfile: &extended_limits.__block_info.incfile,
                uid: extended_limits.__block_info.uid,
                line: extended_limits.__block_info.line,
                start_offset: extended_limits.__block_info.start_offset,
                end_offset: extended_limits.__block_info.end_offset,
                position_restriction: extended_limits.pos_restrict(),
            });
        }
        if let Some(format) = &self.format {
            let format_out = format.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FORMAT",
                item_text: format_out,
                is_block: false,
                incfile: &format.__block_info.incfile,
                uid: format.__block_info.uid,
                line: format.__block_info.line,
                start_offset: format.__block_info.start_offset,
                end_offset: format.__block_info.end_offset,
                position_restriction: format.pos_restrict(),
            });
        }
        if let Some(function_list) = &self.function_list {
            let function_list_out = function_list.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FUNCTION_LIST",
                item_text: function_list_out,
                is_block: true,
                incfile: &function_list.__block_info.incfile,
                uid: function_list.__block_info.uid,
                line: function_list.__block_info.line,
                start_offset: function_list.__block_info.start_offset,
                end_offset: function_list.__block_info.end_offset,
                position_restriction: function_list.pos_restrict(),
            });
        }
        if let Some(guard_rails) = &self.guard_rails {
            let guard_rails_out = guard_rails.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "GUARD_RAILS",
                item_text: guard_rails_out,
                is_block: false,
                incfile: &guard_rails.__block_info.incfile,
                uid: guard_rails.__block_info.uid,
                line: guard_rails.__block_info.line,
                start_offset: guard_rails.__block_info.start_offset,
                end_offset: guard_rails.__block_info.end_offset,
                position_restriction: guard_rails.pos_restrict(),
            });
        }
        for if_data in &self.if_data {
            let if_data_out = if_data.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "IF_DATA",
                item_text: if_data_out,
                is_block: true,
                incfile: &if_data.__block_info.incfile,
                uid: if_data.__block_info.uid,
                line: if_data.__block_info.line,
                start_offset: if_data.__block_info.start_offset,
                end_offset: if_data.__block_info.end_offset,
                position_restriction: if_data.pos_restrict(),
            });
        }
        if let Some(map_list) = &self.map_list {
            let map_list_out = map_list.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MAP_LIST",
                item_text: map_list_out,
                is_block: true,
                incfile: &map_list.__block_info.incfile,
                uid: map_list.__block_info.uid,
                line: map_list.__block_info.line,
                start_offset: map_list.__block_info.start_offset,
                end_offset: map_list.__block_info.end_offset,
                position_restriction: map_list.pos_restrict(),
            });
        }
        if let Some(matrix_dim) = &self.matrix_dim {
            let matrix_dim_out = matrix_dim.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MATRIX_DIM",
                item_text: matrix_dim_out,
                is_block: false,
                incfile: &matrix_dim.__block_info.incfile,
                uid: matrix_dim.__block_info.uid,
                line: matrix_dim.__block_info.line,
                start_offset: matrix_dim.__block_info.start_offset,
                end_offset: matrix_dim.__block_info.end_offset,
                position_restriction: matrix_dim.pos_restrict(),
            });
        }
        if let Some(max_refresh) = &self.max_refresh {
            let max_refresh_out = max_refresh.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MAX_REFRESH",
                item_text: max_refresh_out,
                is_block: false,
                incfile: &max_refresh.__block_info.incfile,
                uid: max_refresh.__block_info.uid,
                line: max_refresh.__block_info.line,
                start_offset: max_refresh.__block_info.start_offset,
                end_offset: max_refresh.__block_info.end_offset,
                position_restriction: max_refresh.pos_restrict(),
            });
        }
        if let Some(model_link) = &self.model_link {
            let model_link_out = model_link.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MODEL_LINK",
                item_text: model_link_out,
                is_block: false,
                incfile: &model_link.__block_info.incfile,
                uid: model_link.__block_info.uid,
                line: model_link.__block_info.line,
                start_offset: model_link.__block_info.start_offset,
                end_offset: model_link.__block_info.end_offset,
                position_restriction: model_link.pos_restrict(),
            });
        }
        if let Some(number) = &self.number {
            let number_out = number.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "NUMBER",
                item_text: number_out,
                is_block: false,
                incfile: &number.__block_info.incfile,
                uid: number.__block_info.uid,
                line: number.__block_info.line,
                start_offset: number.__block_info.start_offset,
                end_offset: number.__block_info.end_offset,
                position_restriction: number.pos_restrict(),
            });
        }
        if let Some(phys_unit) = &self.phys_unit {
            let phys_unit_out = phys_unit.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "PHYS_UNIT",
                item_text: phys_unit_out,
                is_block: false,
                incfile: &phys_unit.__block_info.incfile,
                uid: phys_unit.__block_info.uid,
                line: phys_unit.__block_info.line,
                start_offset: phys_unit.__block_info.start_offset,
                end_offset: phys_unit.__block_info.end_offset,
                position_restriction: phys_unit.pos_restrict(),
            });
        }
        if let Some(read_only) = &self.read_only {
            let read_only_out = read_only.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "READ_ONLY",
                item_text: read_only_out,
                is_block: false,
                incfile: &read_only.__block_info.incfile,
                uid: read_only.__block_info.uid,
                line: read_only.__block_info.line,
                start_offset: read_only.__block_info.start_offset,
                end_offset: read_only.__block_info.end_offset,
                position_restriction: read_only.pos_restrict(),
            });
        }
        if let Some(ref_memory_segment) = &self.ref_memory_segment {
            let ref_memory_segment_out = ref_memory_segment.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "REF_MEMORY_SEGMENT",
                item_text: ref_memory_segment_out,
                is_block: false,
                incfile: &ref_memory_segment.__block_info.incfile,
                uid: ref_memory_segment.__block_info.uid,
                line: ref_memory_segment.__block_info.line,
                start_offset: ref_memory_segment.__block_info.start_offset,
                end_offset: ref_memory_segment.__block_info.end_offset,
                position_restriction: ref_memory_segment.pos_restrict(),
            });
        }
        if let Some(step_size) = &self.step_size {
            let step_size_out = step_size.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "STEP_SIZE",
                item_text: step_size_out,
                is_block: false,
                incfile: &step_size.__block_info.incfile,
                uid: step_size.__block_info.uid,
                line: step_size.__block_info.line,
                start_offset: step_size.__block_info.start_offset,
                end_offset: step_size.__block_info.end_offset,
                position_restriction: step_size.pos_restrict(),
            });
        }
        if let Some(symbol_link) = &self.symbol_link {
            let symbol_link_out = symbol_link.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SYMBOL_LINK",
                item_text: symbol_link_out,
                is_block: false,
                incfile: &symbol_link.__block_info.incfile,
                uid: symbol_link.__block_info.uid,
                line: symbol_link.__block_info.line,
                start_offset: symbol_link.__block_info.start_offset,
                end_offset: symbol_link.__block_info.end_offset,
                position_restriction: symbol_link.pos_restrict(),
            });
        }
        if let Some(virtual_characteristic) = &self.virtual_characteristic {
            let virtual_characteristic_out = virtual_characteristic.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "VIRTUAL_CHARACTERISTIC",
                item_text: virtual_characteristic_out,
                is_block: true,
                incfile: &virtual_characteristic.__block_info.incfile,
                uid: virtual_characteristic.__block_info.uid,
                line: virtual_characteristic.__block_info.line,
                start_offset: virtual_characteristic.__block_info.start_offset,
                end_offset: virtual_characteristic.__block_info.end_offset,
                position_restriction: virtual_characteristic.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Specifies the type of an adjustable object
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CharacteristicType {
    Ascii,
    Curve,
    Map,
    Cuboid,
    Cube4,
    Cube5,
    ValBlk,
    Value,
}

impl ParseableA2lObject for CharacteristicType {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "ASCII" => Ok(Self::Ascii),
            "CURVE" => Ok(Self::Curve),
            "MAP" => Ok(Self::Map),
            "CUBOID" => Ok(Self::Cuboid),
            "CUBE_4" => {
                parser.check_enumitem_version_lower(context, "CUBE_4", A2lVersion::V1_6_0)?;
                Ok(Self::Cube4)
            }
            "CUBE_5" => {
                parser.check_enumitem_version_lower(context, "CUBE_5", A2lVersion::V1_6_0)?;
                Ok(Self::Cube5)
            }
            "VAL_BLK" => Ok(Self::ValBlk),
            "VALUE" => Ok(Self::Value),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for CharacteristicType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::Ascii => "ASCII",
            Self::Curve => "CURVE",
            Self::Map => "MAP",
            Self::Cuboid => "CUBOID",
            Self::Cube4 => "CUBE_4",
            Self::Cube5 => "CUBE_5",
            Self::ValBlk => "VAL_BLK",
            Self::Value => "VALUE",
        };
        f.write_str(tag)
    }
}

/// Specifies the coefficients for the formula f(x) = (axx + bx + c) / (dxx + ex + f)
#[derive(Clone)]
pub struct Coeffs {
    pub a: f64,
    pub b: f64,
    pub c: f64,
    pub d: f64,
    pub e: f64,
    pub f: f64,
    pub(crate) __block_info: BlockInfo<(u32, u32, u32, u32, u32, u32)>,
}

impl std::fmt::Debug for Coeffs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Coeffs")
            .field("a", &self.a)
            .field("b", &self.b)
            .field("c", &self.c)
            .field("d", &self.d)
            .field("e", &self.e)
            .field("f", &self.f)
            .finish()
    }
}

impl Coeffs {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64) -> Self {
        Self {
            a,
            b,
            c,
            d,
            e,
            f,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, 0u32, 0u32, 0u32, 0u32, 0u32),
            },
        }
    }
}

impl PartialEq for Coeffs {
    fn eq(&self, other: &Self) -> bool {
        (self.a == other.a)
            && (self.b == other.b)
            && (self.c == other.c)
            && (self.d == other.d)
            && (self.e == other.e)
            && (self.f == other.f)
    }
}

impl A2lObject<(u32, u32, u32, u32, u32, u32)> for Coeffs {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, u32, u32, u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, u32, u32, u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Coeffs {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__a_location, a) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__b_location, b) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__c_location, c) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__d_location, d) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__e_location, e) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__f_location, f) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __a_location,
                    __b_location,
                    __c_location,
                    __d_location,
                    __e_location,
                    __f_location,
                ),
            },
            a,
            b,
            c,
            d,
            e,
            f,
        })
    }
}

impl Coeffs {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_float(self.a, self.__block_info.item_location.0);
        writer.add_float(self.b, self.__block_info.item_location.1);
        writer.add_float(self.c, self.__block_info.item_location.2);
        writer.add_float(self.d, self.__block_info.item_location.3);
        writer.add_float(self.e, self.__block_info.item_location.4);
        writer.add_float(self.f, self.__block_info.item_location.5);
        writer.finish()
    }
}

/// Specifies the coefficients for the linear formula f(x) = ax + b
#[derive(Clone)]
pub struct CoeffsLinear {
    pub a: f64,
    pub b: f64,
    pub(crate) __block_info: BlockInfo<(u32, u32)>,
}

impl std::fmt::Debug for CoeffsLinear {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CoeffsLinear")
            .field("a", &self.a)
            .field("b", &self.b)
            .finish()
    }
}

impl CoeffsLinear {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(a: f64, b: f64) -> Self {
        Self {
            a,
            b,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, 0u32),
            },
        }
    }
}

impl PartialEq for CoeffsLinear {
    fn eq(&self, other: &Self) -> bool {
        (self.a == other.a) && (self.b == other.b)
    }
}

impl A2lObject<(u32, u32)> for CoeffsLinear {
    fn get_layout(&self) -> &BlockInfo<(u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for CoeffsLinear {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__a_location, a) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__b_location, b) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__a_location, __b_location),
            },
            a,
            b,
        })
    }
}

impl CoeffsLinear {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_float(self.a, self.__block_info.item_location.0);
        writer.add_float(self.b, self.__block_info.item_location.1);
        writer.finish()
    }
}

///Auto generated for repeating sequence combination in block `VAR_FORBIDDEN_COMB`
#[derive(Clone)]
pub struct CombinationStruct {
    pub criterion_name: String,
    pub criterion_value: String,
    pub(crate) __block_info: BlockInfo<(u32, u32)>,
}

impl std::fmt::Debug for CombinationStruct {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CombinationStruct")
            .field("criterion_name", &self.criterion_name)
            .field("criterion_value", &self.criterion_value)
            .finish()
    }
}

impl CombinationStruct {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(criterion_name: String, criterion_value: String) -> Self {
        Self {
            criterion_name,
            criterion_value,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (1u32, 0u32),
            },
        }
    }
}

impl PartialEq for CombinationStruct {
    fn eq(&self, other: &Self) -> bool {
        (self.criterion_name == other.criterion_name)
            && (self.criterion_value == other.criterion_value)
    }
}

impl A2lObject<(u32, u32)> for CombinationStruct {
    fn get_layout(&self) -> &BlockInfo<(u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for CombinationStruct {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__criterion_name_location, criterion_name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__criterion_value_location, criterion_value) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__criterion_name_location, __criterion_value_location),
            },
            criterion_name,
            criterion_value,
        })
    }
}

impl CombinationStruct {
    pub(crate) fn stringify(&self, writer: &mut writer::Writer) {
        writer.add_str(&self.criterion_name, self.__block_info.item_location.0);
        writer.add_str(&self.criterion_value, self.__block_info.item_location.1);
    }
}

/// references a valid MEASUREMENT
#[derive(Clone)]
pub struct ComparisonQuantity {
    pub name: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for ComparisonQuantity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ComparisonQuantity")
            .field("name", &self.name)
            .finish()
    }
}

impl ComparisonQuantity {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String) -> Self {
        Self {
            name,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for ComparisonQuantity {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name
    }
}

impl A2lObject<(u32, ())> for ComparisonQuantity {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for ComparisonQuantity {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for ComparisonQuantity {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __dummy),
            },
            name,
        })
    }
}

impl ComparisonQuantity {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Specification of a conversion method from internal values to physical values
#[derive(Clone)]
pub struct CompuMethod {
    pub name: String,
    pub long_identifier: String,
    pub conversion_type: ConversionType,
    pub format: String,
    pub unit: String,
    pub coeffs: Option<Coeffs>,
    pub coeffs_linear: Option<CoeffsLinear>,
    pub compu_tab_ref: Option<CompuTabRef>,
    pub formula: Option<Formula>,
    pub ref_unit: Option<RefUnit>,
    pub status_string_ref: Option<StatusStringRef>,
    pub(crate) __block_info: BlockInfo<(u32, u32, u32, u32, u32)>,
}

impl std::fmt::Debug for CompuMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CompuMethod")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("conversion_type", &self.conversion_type)
            .field("format", &self.format)
            .field("unit", &self.unit)
            .field("coeffs", &self.coeffs)
            .field("coeffs_linear", &self.coeffs_linear)
            .field("compu_tab_ref", &self.compu_tab_ref)
            .field("formula", &self.formula)
            .field("ref_unit", &self.ref_unit)
            .field("status_string_ref", &self.status_string_ref)
            .finish()
    }
}

impl CompuMethod {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        name: String,
        long_identifier: String,
        conversion_type: ConversionType,
        format: String,
        unit: String,
    ) -> Self {
        Self {
            name,
            long_identifier,
            conversion_type,
            format,
            unit,
            coeffs: None,
            coeffs_linear: None,
            compu_tab_ref: None,
            formula: None,
            ref_unit: None,
            status_string_ref: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32, 1u32, 0u32, 0u32),
            },
        }
    }
}

impl PartialEq for CompuMethod {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.conversion_type == other.conversion_type)
            && (self.format == other.format)
            && (self.unit == other.unit)
            && (self.coeffs == other.coeffs)
            && (self.coeffs_linear == other.coeffs_linear)
            && (self.compu_tab_ref == other.compu_tab_ref)
            && (self.formula == other.formula)
            && (self.ref_unit == other.ref_unit)
            && (self.status_string_ref == other.status_string_ref)
    }
}

impl A2lObject<(u32, u32, u32, u32, u32)> for CompuMethod {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, u32, u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, u32, u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(coeffs) = &mut self.coeffs {
            coeffs.merge_includes();
        }
        if let Some(coeffs_linear) = &mut self.coeffs_linear {
            coeffs_linear.merge_includes();
        }
        if let Some(compu_tab_ref) = &mut self.compu_tab_ref {
            compu_tab_ref.merge_includes();
        }
        if let Some(formula) = &mut self.formula {
            formula.merge_includes();
        }
        if let Some(ref_unit) = &mut self.ref_unit {
            ref_unit.merge_includes();
        }
        if let Some(status_string_ref) = &mut self.status_string_ref {
            status_string_ref.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for CompuMethod {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for CompuMethod {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__conversion_type_location, conversion_type) = (
            parser.get_current_line_offset(),
            ConversionType::parse(parser, context, 0)?,
        );
        let (__format_location, format) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__unit_location, unit) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let mut coeffs: Option<Coeffs> = None;
        let mut coeffs_linear: Option<CoeffsLinear> = None;
        let mut compu_tab_ref: Option<CompuTabRef> = None;
        let mut formula: Option<Formula> = None;
        let mut ref_unit: Option<RefUnit> = None;
        let mut status_string_ref: Option<StatusStringRef> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 6usize] = [
                "COEFFS",
                "COEFFS_LINEAR",
                "COMPU_TAB_REF",
                "FORMULA",
                "REF_UNIT",
                "STATUS_STRING_REF",
            ];
            match tag {
                "COEFFS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Coeffs::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, coeffs.is_some())?;
                    coeffs = Some(newitem);
                }
                "COEFFS_LINEAR" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "COEFFS_LINEAR",
                        A2lVersion::V1_6_0,
                    )?;
                    let newitem = CoeffsLinear::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, coeffs_linear.is_some())?;
                    coeffs_linear = Some(newitem);
                }
                "COMPU_TAB_REF" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = CompuTabRef::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, compu_tab_ref.is_some())?;
                    compu_tab_ref = Some(newitem);
                }
                "FORMULA" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Formula::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, formula.is_some())?;
                    formula = Some(newitem);
                }
                "REF_UNIT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = RefUnit::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, ref_unit.is_some())?;
                    ref_unit = Some(newitem);
                }
                "STATUS_STRING_REF" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "STATUS_STRING_REF",
                        A2lVersion::V1_6_0,
                    )?;
                    let newitem = StatusStringRef::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, status_string_ref.is_some())?;
                    status_string_ref = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __conversion_type_location,
                    __format_location,
                    __unit_location,
                ),
            },
            name,
            long_identifier,
            conversion_type,
            format,
            unit,
            coeffs,
            coeffs_linear,
            compu_tab_ref,
            formula,
            ref_unit,
            status_string_ref,
        })
    }
}

impl CompuMethod {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_str(
            &self.conversion_type.to_string(),
            self.__block_info.item_location.2,
        );
        writer.add_quoted_string(&self.format, self.__block_info.item_location.3);
        writer.add_quoted_string(&self.unit, self.__block_info.item_location.4);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(coeffs) = &self.coeffs {
            let coeffs_out = coeffs.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "COEFFS",
                item_text: coeffs_out,
                is_block: false,
                incfile: &coeffs.__block_info.incfile,
                uid: coeffs.__block_info.uid,
                line: coeffs.__block_info.line,
                start_offset: coeffs.__block_info.start_offset,
                end_offset: coeffs.__block_info.end_offset,
                position_restriction: coeffs.pos_restrict(),
            });
        }
        if let Some(coeffs_linear) = &self.coeffs_linear {
            let coeffs_linear_out = coeffs_linear.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "COEFFS_LINEAR",
                item_text: coeffs_linear_out,
                is_block: false,
                incfile: &coeffs_linear.__block_info.incfile,
                uid: coeffs_linear.__block_info.uid,
                line: coeffs_linear.__block_info.line,
                start_offset: coeffs_linear.__block_info.start_offset,
                end_offset: coeffs_linear.__block_info.end_offset,
                position_restriction: coeffs_linear.pos_restrict(),
            });
        }
        if let Some(compu_tab_ref) = &self.compu_tab_ref {
            let compu_tab_ref_out = compu_tab_ref.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "COMPU_TAB_REF",
                item_text: compu_tab_ref_out,
                is_block: false,
                incfile: &compu_tab_ref.__block_info.incfile,
                uid: compu_tab_ref.__block_info.uid,
                line: compu_tab_ref.__block_info.line,
                start_offset: compu_tab_ref.__block_info.start_offset,
                end_offset: compu_tab_ref.__block_info.end_offset,
                position_restriction: compu_tab_ref.pos_restrict(),
            });
        }
        if let Some(formula) = &self.formula {
            let formula_out = formula.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FORMULA",
                item_text: formula_out,
                is_block: true,
                incfile: &formula.__block_info.incfile,
                uid: formula.__block_info.uid,
                line: formula.__block_info.line,
                start_offset: formula.__block_info.start_offset,
                end_offset: formula.__block_info.end_offset,
                position_restriction: formula.pos_restrict(),
            });
        }
        if let Some(ref_unit) = &self.ref_unit {
            let ref_unit_out = ref_unit.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "REF_UNIT",
                item_text: ref_unit_out,
                is_block: false,
                incfile: &ref_unit.__block_info.incfile,
                uid: ref_unit.__block_info.uid,
                line: ref_unit.__block_info.line,
                start_offset: ref_unit.__block_info.start_offset,
                end_offset: ref_unit.__block_info.end_offset,
                position_restriction: ref_unit.pos_restrict(),
            });
        }
        if let Some(status_string_ref) = &self.status_string_ref {
            let status_string_ref_out = status_string_ref.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "STATUS_STRING_REF",
                item_text: status_string_ref_out,
                is_block: false,
                incfile: &status_string_ref.__block_info.incfile,
                uid: status_string_ref.__block_info.uid,
                line: status_string_ref.__block_info.line,
                start_offset: status_string_ref.__block_info.start_offset,
                end_offset: status_string_ref.__block_info.end_offset,
                position_restriction: status_string_ref.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Conversion table for conversions that cannot be represented as a function
#[derive(Clone)]
pub struct CompuTab {
    pub name: String,
    pub long_identifier: String,
    pub conversion_type: ConversionType,
    pub number_value_pairs: u16,
    pub tab_entry: Vec<TabEntryStruct>,
    pub default_value: Option<DefaultValue>,
    pub default_value_numeric: Option<DefaultValueNumeric>,
    pub(crate) __block_info: BlockInfo<(u32, u32, u32, (u32, bool), Vec<u32>)>,
}

impl std::fmt::Debug for CompuTab {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CompuTab")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("conversion_type", &self.conversion_type)
            .field("number_value_pairs", &self.number_value_pairs)
            .field("tab_entry", &self.tab_entry)
            .field("default_value", &self.default_value)
            .field("default_value_numeric", &self.default_value_numeric)
            .finish()
    }
}

impl CompuTab {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        name: String,
        long_identifier: String,
        conversion_type: ConversionType,
        number_value_pairs: u16,
    ) -> Self {
        Self {
            name,
            long_identifier,
            conversion_type,
            number_value_pairs,
            tab_entry: Vec::new(),
            default_value: None,
            default_value_numeric: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32, 1u32, (0u32, false), Vec::<u32>::new()),
            },
        }
    }
}

impl PartialEq for CompuTab {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.conversion_type == other.conversion_type)
            && (self.number_value_pairs == other.number_value_pairs)
            && (self.tab_entry == other.tab_entry)
            && (self.default_value == other.default_value)
            && (self.default_value_numeric == other.default_value_numeric)
    }
}

impl A2lObject<(u32, u32, u32, (u32, bool), Vec<u32>)> for CompuTab {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, u32, (u32, bool), Vec<u32>)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, u32, (u32, bool), Vec<u32>)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(default_value) = &mut self.default_value {
            default_value.merge_includes();
        }
        if let Some(default_value_numeric) = &mut self.default_value_numeric {
            default_value_numeric.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for CompuTab {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for CompuTab {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__conversion_type_location, conversion_type) = (
            parser.get_current_line_offset(),
            ConversionType::parse(parser, context, 0)?,
        );
        let (__number_value_pairs_location, number_value_pairs) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let mut tab_entry = Vec::new();
        let mut __tab_entry_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        TabEntryStruct::parse(parser, context, 0)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    tab_entry.push(value);
                    __tab_entry_location.push(location);
                }
            }
        }
        let mut default_value: Option<DefaultValue> = None;
        let mut default_value_numeric: Option<DefaultValueNumeric> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 2usize] = ["DEFAULT_VALUE", "DEFAULT_VALUE_NUMERIC"];
            match tag {
                "DEFAULT_VALUE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = DefaultValue::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, default_value.is_some())?;
                    default_value = Some(newitem);
                }
                "DEFAULT_VALUE_NUMERIC" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "DEFAULT_VALUE_NUMERIC",
                        A2lVersion::V1_6_0,
                    )?;
                    let newitem = DefaultValueNumeric::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        default_value_numeric.is_some(),
                    )?;
                    default_value_numeric = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __conversion_type_location,
                    __number_value_pairs_location,
                    __tab_entry_location,
                ),
            },
            name,
            long_identifier,
            conversion_type,
            number_value_pairs,
            tab_entry,
            default_value,
            default_value_numeric,
        })
    }
}

impl CompuTab {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_str(
            &self.conversion_type.to_string(),
            self.__block_info.item_location.2,
        );
        writer.add_integer(
            self.number_value_pairs,
            self.__block_info.item_location.3 .1,
            self.__block_info.item_location.3 .0,
        );
        for seqitem0 in &self.tab_entry {
            seqitem0.stringify(&mut writer);
        }
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(default_value) = &self.default_value {
            let default_value_out = default_value.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DEFAULT_VALUE",
                item_text: default_value_out,
                is_block: false,
                incfile: &default_value.__block_info.incfile,
                uid: default_value.__block_info.uid,
                line: default_value.__block_info.line,
                start_offset: default_value.__block_info.start_offset,
                end_offset: default_value.__block_info.end_offset,
                position_restriction: default_value.pos_restrict(),
            });
        }
        if let Some(default_value_numeric) = &self.default_value_numeric {
            let default_value_numeric_out = default_value_numeric.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DEFAULT_VALUE_NUMERIC",
                item_text: default_value_numeric_out,
                is_block: false,
                incfile: &default_value_numeric.__block_info.incfile,
                uid: default_value_numeric.__block_info.uid,
                line: default_value_numeric.__block_info.line,
                start_offset: default_value_numeric.__block_info.start_offset,
                end_offset: default_value_numeric.__block_info.end_offset,
                position_restriction: default_value_numeric.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// reference to a conversion table
#[derive(Clone)]
pub struct CompuTabRef {
    pub conversion_table: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for CompuTabRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CompuTabRef")
            .field("conversion_table", &self.conversion_table)
            .finish()
    }
}

impl CompuTabRef {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(conversion_table: String) -> Self {
        Self {
            conversion_table,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for CompuTabRef {
    fn eq(&self, other: &Self) -> bool {
        self.conversion_table == other.conversion_table
    }
}

impl A2lObject<(u32, ())> for CompuTabRef {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for CompuTabRef {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__conversion_table_location, conversion_table) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__conversion_table_location, __dummy),
            },
            conversion_table,
        })
    }
}

impl CompuTabRef {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.conversion_table, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Conversion table for the assignment of display strings to values. Typically used for enums.
#[derive(Clone)]
pub struct CompuVtab {
    pub name: String,
    pub long_identifier: String,
    pub conversion_type: ConversionType,
    pub number_value_pairs: u16,
    pub value_pairs: Vec<ValuePairsStruct>,
    pub default_value: Option<DefaultValue>,
    pub(crate) __block_info: BlockInfo<(u32, u32, u32, (u32, bool), Vec<u32>)>,
}

impl std::fmt::Debug for CompuVtab {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CompuVtab")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("conversion_type", &self.conversion_type)
            .field("number_value_pairs", &self.number_value_pairs)
            .field("value_pairs", &self.value_pairs)
            .field("default_value", &self.default_value)
            .finish()
    }
}

impl CompuVtab {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        name: String,
        long_identifier: String,
        conversion_type: ConversionType,
        number_value_pairs: u16,
    ) -> Self {
        Self {
            name,
            long_identifier,
            conversion_type,
            number_value_pairs,
            value_pairs: Vec::new(),
            default_value: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32, 1u32, (0u32, false), Vec::<u32>::new()),
            },
        }
    }
}

impl PartialEq for CompuVtab {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.conversion_type == other.conversion_type)
            && (self.number_value_pairs == other.number_value_pairs)
            && (self.value_pairs == other.value_pairs)
            && (self.default_value == other.default_value)
    }
}

impl A2lObject<(u32, u32, u32, (u32, bool), Vec<u32>)> for CompuVtab {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, u32, (u32, bool), Vec<u32>)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, u32, (u32, bool), Vec<u32>)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(default_value) = &mut self.default_value {
            default_value.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for CompuVtab {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for CompuVtab {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__conversion_type_location, conversion_type) = (
            parser.get_current_line_offset(),
            ConversionType::parse(parser, context, 0)?,
        );
        let (__number_value_pairs_location, number_value_pairs) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let mut value_pairs = Vec::new();
        let mut __value_pairs_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        ValuePairsStruct::parse(parser, context, 0)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    value_pairs.push(value);
                    __value_pairs_location.push(location);
                }
            }
        }
        let mut default_value: Option<DefaultValue> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 1usize] = ["DEFAULT_VALUE"];
            match tag {
                "DEFAULT_VALUE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = DefaultValue::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, default_value.is_some())?;
                    default_value = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __conversion_type_location,
                    __number_value_pairs_location,
                    __value_pairs_location,
                ),
            },
            name,
            long_identifier,
            conversion_type,
            number_value_pairs,
            value_pairs,
            default_value,
        })
    }
}

impl CompuVtab {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_str(
            &self.conversion_type.to_string(),
            self.__block_info.item_location.2,
        );
        writer.add_integer(
            self.number_value_pairs,
            self.__block_info.item_location.3 .1,
            self.__block_info.item_location.3 .0,
        );
        for seqitem0 in &self.value_pairs {
            seqitem0.stringify(&mut writer);
        }
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(default_value) = &self.default_value {
            let default_value_out = default_value.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DEFAULT_VALUE",
                item_text: default_value_out,
                is_block: false,
                incfile: &default_value.__block_info.incfile,
                uid: default_value.__block_info.uid,
                line: default_value.__block_info.line,
                start_offset: default_value.__block_info.start_offset,
                end_offset: default_value.__block_info.end_offset,
                position_restriction: default_value.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Conversion table for the assignment of display strings to a value range
#[derive(Clone)]
pub struct CompuVtabRange {
    pub name: String,
    pub long_identifier: String,
    pub number_value_triples: u16,
    pub value_triples: Vec<ValueTriplesStruct>,
    pub default_value: Option<DefaultValue>,
    pub(crate) __block_info: BlockInfo<(u32, u32, (u32, bool), Vec<u32>)>,
}

impl std::fmt::Debug for CompuVtabRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CompuVtabRange")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("number_value_triples", &self.number_value_triples)
            .field("value_triples", &self.value_triples)
            .field("default_value", &self.default_value)
            .finish()
    }
}

impl CompuVtabRange {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String, long_identifier: String, number_value_triples: u16) -> Self {
        Self {
            name,
            long_identifier,
            number_value_triples,
            value_triples: Vec::new(),
            default_value: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32, (1u32, false), Vec::<u32>::new()),
            },
        }
    }
}

impl PartialEq for CompuVtabRange {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.number_value_triples == other.number_value_triples)
            && (self.value_triples == other.value_triples)
            && (self.default_value == other.default_value)
    }
}

impl A2lObject<(u32, u32, (u32, bool), Vec<u32>)> for CompuVtabRange {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, (u32, bool), Vec<u32>)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, (u32, bool), Vec<u32>)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(default_value) = &mut self.default_value {
            default_value.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for CompuVtabRange {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for CompuVtabRange {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__number_value_triples_location, number_value_triples) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let mut value_triples = Vec::new();
        let mut __value_triples_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        ValueTriplesStruct::parse(parser, context, 0)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    value_triples.push(value);
                    __value_triples_location.push(location);
                }
            }
        }
        let mut default_value: Option<DefaultValue> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 1usize] = ["DEFAULT_VALUE"];
            match tag {
                "DEFAULT_VALUE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = DefaultValue::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, default_value.is_some())?;
                    default_value = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __number_value_triples_location,
                    __value_triples_location,
                ),
            },
            name,
            long_identifier,
            number_value_triples,
            value_triples,
            default_value,
        })
    }
}

impl CompuVtabRange {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_integer(
            self.number_value_triples,
            self.__block_info.item_location.2 .1,
            self.__block_info.item_location.2 .0,
        );
        for seqitem0 in &self.value_triples {
            seqitem0.stringify(&mut writer);
        }
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(default_value) = &self.default_value {
            let default_value_out = default_value.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DEFAULT_VALUE",
                item_text: default_value_out,
                is_block: false,
                incfile: &default_value.__block_info.incfile,
                uid: default_value.__block_info.uid,
                line: default_value.__block_info.line,
                start_offset: default_value.__block_info.start_offset,
                end_offset: default_value.__block_info.end_offset,
                position_restriction: default_value.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// indicates that an instance of a structure should always be handled completely
#[derive(Clone)]
pub struct ConsistentExchange {
    pub(crate) __block_info: BlockInfo<()>,
}

impl std::fmt::Debug for ConsistentExchange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ConsistentExchange").finish()
    }
}

impl ConsistentExchange {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (),
            },
        }
    }
}

impl PartialEq for ConsistentExchange {
    fn eq(&self, _other: &Self) -> bool {
        true
    }
}

impl A2lObject<()> for ConsistentExchange {
    fn get_layout(&self) -> &BlockInfo<()> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<()> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for ConsistentExchange {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (),
            },
        })
    }
}

impl ConsistentExchange {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let writer = writer::Writer::new(indent);
        writer.finish()
    }
}

/// CONVERSION is used inside OVERWRITE to override the default conversion method
#[derive(Clone)]
pub struct Conversion {
    pub name: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for Conversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Conversion")
            .field("name", &self.name)
            .finish()
    }
}

impl Conversion {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String) -> Self {
        Self {
            name,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for Conversion {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name
    }
}

impl A2lObject<(u32, ())> for Conversion {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for Conversion {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for Conversion {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __dummy),
            },
            name,
        })
    }
}

impl Conversion {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Describes how to convert internal input values to physical values
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConversionType {
    Identical,
    Form,
    Linear,
    RatFunc,
    TabIntp,
    TabNointp,
    TabVerb,
}

impl ParseableA2lObject for ConversionType {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "IDENTICAL" => {
                parser.check_enumitem_version_lower(context, "IDENTICAL", A2lVersion::V1_6_0)?;
                Ok(Self::Identical)
            }
            "FORM" => Ok(Self::Form),
            "LINEAR" => {
                parser.check_enumitem_version_lower(context, "LINEAR", A2lVersion::V1_6_0)?;
                Ok(Self::Linear)
            }
            "RAT_FUNC" => Ok(Self::RatFunc),
            "TAB_INTP" => Ok(Self::TabIntp),
            "TAB_NOINTP" => Ok(Self::TabNointp),
            "TAB_VERB" => Ok(Self::TabVerb),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for ConversionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::Identical => "IDENTICAL",
            Self::Form => "FORM",
            Self::Linear => "LINEAR",
            Self::RatFunc => "RAT_FUNC",
            Self::TabIntp => "TAB_INTP",
            Self::TabNointp => "TAB_NOINTP",
            Self::TabVerb => "TAB_VERB",
        };
        f.write_str(tag)
    }
}

/// Identifies the CPU used in the ECU
#[derive(Clone)]
pub struct CpuType {
    pub cpu: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for CpuType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CpuType").field("cpu", &self.cpu).finish()
    }
}

impl CpuType {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(cpu: String) -> Self {
        Self {
            cpu,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for CpuType {
    fn eq(&self, other: &Self) -> bool {
        self.cpu == other.cpu
    }
}

impl A2lObject<(u32, ())> for CpuType {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for CpuType {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__cpu_location, cpu) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__cpu_location, __dummy),
            },
            cpu,
        })
    }
}

impl CpuType {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.cpu, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Used to specify the adjustable CURVE CHARACTERISTIC that is used to normalize or scale the axis in an `AXIS_DESCR`
#[derive(Clone)]
pub struct CurveAxisRef {
    pub curve_axis: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for CurveAxisRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CurveAxisRef")
            .field("curve_axis", &self.curve_axis)
            .finish()
    }
}

impl CurveAxisRef {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(curve_axis: String) -> Self {
        Self {
            curve_axis,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for CurveAxisRef {
    fn eq(&self, other: &Self) -> bool {
        self.curve_axis == other.curve_axis
    }
}

impl A2lObject<(u32, ())> for CurveAxisRef {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for CurveAxisRef {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__curve_axis_location, curve_axis) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__curve_axis_location, __dummy),
            },
            curve_axis,
        })
    }
}

impl CurveAxisRef {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.curve_axis, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Allows a customer name to be specified
#[derive(Clone)]
pub struct Customer {
    pub customer: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for Customer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Customer")
            .field("customer", &self.customer)
            .finish()
    }
}

impl Customer {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(customer: String) -> Self {
        Self {
            customer,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for Customer {
    fn eq(&self, other: &Self) -> bool {
        self.customer == other.customer
    }
}

impl A2lObject<(u32, ())> for Customer {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Customer {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__customer_location, customer) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__customer_location, __dummy),
            },
            customer,
        })
    }
}

impl Customer {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.customer, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// specify a customer number or identifier as a string
#[derive(Clone)]
pub struct CustomerNo {
    pub number: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for CustomerNo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CustomerNo")
            .field("number", &self.number)
            .finish()
    }
}

impl CustomerNo {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(number: String) -> Self {
        Self {
            number,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for CustomerNo {
    fn eq(&self, other: &Self) -> bool {
        self.number == other.number
    }
}

impl A2lObject<(u32, ())> for CustomerNo {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for CustomerNo {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__number_location, number) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__number_location, __dummy),
            },
            number,
        })
    }
}

impl CustomerNo {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.number, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Data size in bits
#[derive(Clone)]
pub struct DataSize {
    pub size: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for DataSize {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("DataSize")
            .field("size", &self.size)
            .finish()
    }
}

impl DataSize {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(size: u16) -> Self {
        Self {
            size,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for DataSize {
    fn eq(&self, other: &Self) -> bool {
        self.size == other.size
    }
}

impl A2lObject<((u32, bool), ())> for DataSize {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for DataSize {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__size_location, size) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__size_location, __dummy),
            },
            size,
        })
    }
}

impl DataSize {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.size,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// Description of the basic data types in the ECU program.
///
/// Specification: predefined data types
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DataType {
    Ubyte,
    Sbyte,
    Uword,
    Sword,
    Ulong,
    Slong,
    AUint64,
    AInt64,
    Float16Ieee,
    Float32Ieee,
    Float64Ieee,
}

impl ParseableA2lObject for DataType {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "UBYTE" => Ok(Self::Ubyte),
            "SBYTE" => Ok(Self::Sbyte),
            "UWORD" => Ok(Self::Uword),
            "SWORD" => Ok(Self::Sword),
            "ULONG" => Ok(Self::Ulong),
            "SLONG" => Ok(Self::Slong),
            "A_UINT64" => {
                parser.check_enumitem_version_lower(context, "A_UINT64", A2lVersion::V1_6_0)?;
                Ok(Self::AUint64)
            }
            "A_INT64" => {
                parser.check_enumitem_version_lower(context, "A_INT64", A2lVersion::V1_6_0)?;
                Ok(Self::AInt64)
            }
            "FLOAT16_IEEE" => {
                parser.check_enumitem_version_lower(context, "FLOAT16_IEEE", A2lVersion::V1_7_1)?;
                Ok(Self::Float16Ieee)
            }
            "FLOAT32_IEEE" => Ok(Self::Float32Ieee),
            "FLOAT64_IEEE" => Ok(Self::Float64Ieee),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for DataType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::Ubyte => "UBYTE",
            Self::Sbyte => "SBYTE",
            Self::Uword => "UWORD",
            Self::Sword => "SWORD",
            Self::Ulong => "ULONG",
            Self::Slong => "SLONG",
            Self::AUint64 => "A_UINT64",
            Self::AInt64 => "A_INT64",
            Self::Float16Ieee => "FLOAT16_IEEE",
            Self::Float32Ieee => "FLOAT32_IEEE",
            Self::Float64Ieee => "FLOAT64_IEEE",
        };
        f.write_str(tag)
    }
}

/// Description of the word lengths in the ECU program.
///
/// Specification: predefined data types (datasize)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DataTypeSize {
    Byte,
    Word,
    Long,
}

impl ParseableA2lObject for DataTypeSize {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "BYTE" => Ok(Self::Byte),
            "WORD" => Ok(Self::Word),
            "LONG" => Ok(Self::Long),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for DataTypeSize {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::Byte => "BYTE",
            Self::Word => "WORD",
            Self::Long => "LONG",
        };
        f.write_str(tag)
    }
}

/// Defines which adjustable objects are used by a FUNCTION
#[derive(Clone)]
pub struct DefCharacteristic {
    pub identifier_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for DefCharacteristic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("DefCharacteristic")
            .field("identifier_list", &self.identifier_list)
            .finish()
    }
}

impl DefCharacteristic {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            identifier_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for DefCharacteristic {
    fn eq(&self, other: &Self) -> bool {
        self.identifier_list == other.identifier_list
    }
}

impl A2lObject<(Vec<u32>, ())> for DefCharacteristic {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for DefCharacteristic {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut identifier_list = Vec::new();
        let mut __identifier_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    identifier_list.push(value);
                    __identifier_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__identifier_list_location, __dummy),
            },
            identifier_list,
        })
    }
}

impl DefCharacteristic {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.identifier_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// Sets the default text value of `COMPU_TAB`, `COMPU_VTAB` or `COMPU_VTAB_RANGE`
#[derive(Clone)]
pub struct DefaultValue {
    pub display_string: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for DefaultValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("DefaultValue")
            .field("display_string", &self.display_string)
            .finish()
    }
}

impl DefaultValue {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(display_string: String) -> Self {
        Self {
            display_string,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for DefaultValue {
    fn eq(&self, other: &Self) -> bool {
        self.display_string == other.display_string
    }
}

impl A2lObject<(u32, ())> for DefaultValue {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for DefaultValue {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__display_string_location, display_string) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__display_string_location, __dummy),
            },
            display_string,
        })
    }
}

impl DefaultValue {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.display_string, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Sets the default numerical value of `COMPU_TAB`, `COMPU_VTAB` or `COMPU_VTAB_RANGE`
#[derive(Clone)]
pub struct DefaultValueNumeric {
    pub display_value: f64,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for DefaultValueNumeric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("DefaultValueNumeric")
            .field("display_value", &self.display_value)
            .finish()
    }
}

impl DefaultValueNumeric {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(display_value: f64) -> Self {
        Self {
            display_value,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for DefaultValueNumeric {
    fn eq(&self, other: &Self) -> bool {
        self.display_value == other.display_value
    }
}

impl A2lObject<(u32, ())> for DefaultValueNumeric {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for DefaultValueNumeric {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__display_value_location, display_value) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__display_value_location, __dummy),
            },
            display_value,
        })
    }
}

impl DefaultValueNumeric {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_float(self.display_value, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Specify characteristics that depend on a formula
#[derive(Clone)]
pub struct DependentCharacteristic {
    pub formula: String,
    pub characteristic_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(u32, Vec<u32>)>,
}

impl std::fmt::Debug for DependentCharacteristic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("DependentCharacteristic")
            .field("formula", &self.formula)
            .field("characteristic_list", &self.characteristic_list)
            .finish()
    }
}

impl DependentCharacteristic {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(formula: String) -> Self {
        Self {
            formula,
            characteristic_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (1u32, Vec::<u32>::new()),
            },
        }
    }
}

impl PartialEq for DependentCharacteristic {
    fn eq(&self, other: &Self) -> bool {
        (self.formula == other.formula) && (self.characteristic_list == other.characteristic_list)
    }
}

impl A2lObject<(u32, Vec<u32>)> for DependentCharacteristic {
    fn get_layout(&self) -> &BlockInfo<(u32, Vec<u32>)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, Vec<u32>)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for DependentCharacteristic {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__formula_location, formula) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let mut characteristic_list = Vec::new();
        let mut __characteristic_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    characteristic_list.push(value);
                    __characteristic_list_location.push(location);
                }
            }
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__formula_location, __characteristic_list_location),
            },
            formula,
            characteristic_list,
        })
    }
}

impl DependentCharacteristic {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.formula, self.__block_info.item_location.0);
        for (seqidx0, seqitem0) in self.characteristic_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.1.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// Specifies how the axis points of a characteristic are deposited in memory
#[derive(Clone)]
pub struct Deposit {
    pub mode: DepositMode,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for Deposit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Deposit").field("mode", &self.mode).finish()
    }
}

impl Deposit {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(mode: DepositMode) -> Self {
        Self {
            mode,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for Deposit {
    fn eq(&self, other: &Self) -> bool {
        self.mode == other.mode
    }
}

impl A2lObject<(u32, ())> for Deposit {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Deposit {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__mode_location, mode) = (
            parser.get_current_line_offset(),
            DepositMode::parse(parser, context, 0)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__mode_location, __dummy),
            },
            mode,
        })
    }
}

impl Deposit {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.mode.to_string(), self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Deposit of the axis points of a characteristic curve or map
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DepositMode {
    Absolute,
    Difference,
}

impl ParseableA2lObject for DepositMode {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "ABSOLUTE" => Ok(Self::Absolute),
            "DIFFERENCE" => Ok(Self::Difference),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for DepositMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::Absolute => "ABSOLUTE",
            Self::Difference => "DIFFERENCE",
        };
        f.write_str(tag)
    }
}

/// Indicates that a measurement or calibration object has discrete values which should not be interpolated
#[derive(Clone)]
pub struct Discrete {
    pub(crate) __block_info: BlockInfo<()>,
}

impl std::fmt::Debug for Discrete {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Discrete").finish()
    }
}

impl Discrete {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (),
            },
        }
    }
}

impl PartialEq for Discrete {
    fn eq(&self, _other: &Self) -> bool {
        true
    }
}

impl A2lObject<()> for Discrete {
    fn get_layout(&self) -> &BlockInfo<()> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<()> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Discrete {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (),
            },
        })
    }
}

impl Discrete {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let writer = writer::Writer::new(indent);
        writer.finish()
    }
}

/// Gives the display name of a CHARACTERISTIC or MEASUREMENT value
#[derive(Clone)]
pub struct DisplayIdentifier {
    pub display_name: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for DisplayIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("DisplayIdentifier")
            .field("display_name", &self.display_name)
            .finish()
    }
}

impl DisplayIdentifier {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(display_name: String) -> Self {
        Self {
            display_name,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for DisplayIdentifier {
    fn eq(&self, other: &Self) -> bool {
        self.display_name == other.display_name
    }
}

impl A2lObject<(u32, ())> for DisplayIdentifier {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for DisplayIdentifier {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__display_name_location, display_name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__display_name_location, __dummy),
            },
            display_name,
        })
    }
}

impl DisplayIdentifier {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.display_name, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Description of the distance operand in the deposit structure to compute the axis points for fixed characteristic curves and fixed characteristic maps
#[derive(Clone)]
pub struct DistOpDim {
    pub position: u16,
    pub datatype: DataType,
    pub(crate) __block_info: BlockInfo<((u32, bool), u32)>,
}

impl std::fmt::Debug for DistOpDim {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("DistOpDim")
            .field("position", &self.position)
            .field("datatype", &self.datatype)
            .finish()
    }
}

impl DistOpDim {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(position: u16, datatype: DataType) -> Self {
        Self {
            position,
            datatype,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), 0u32),
            },
        }
    }
}

impl PartialEq for DistOpDim {
    fn eq(&self, other: &Self) -> bool {
        (self.position == other.position) && (self.datatype == other.datatype)
    }
}

impl A2lObject<((u32, bool), u32)> for DistOpDim {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for DistOpDim {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__position_location, position) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__datatype_location, datatype) = (
            parser.get_current_line_offset(),
            DataType::parse(parser, context, 0)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__position_location, __datatype_location),
            },
            position,
            datatype,
        })
    }
}

impl DistOpDim {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.position,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_str(
            &self.datatype.to_string(),
            self.__block_info.item_location.1,
        );
        writer.finish()
    }
}

/// String for identification of the control unit.
#[derive(Clone)]
pub struct Ecu {
    pub control_unit: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for Ecu {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Ecu")
            .field("control_unit", &self.control_unit)
            .finish()
    }
}

impl Ecu {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(control_unit: String) -> Self {
        Self {
            control_unit,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for Ecu {
    fn eq(&self, other: &Self) -> bool {
        self.control_unit == other.control_unit
    }
}

impl A2lObject<(u32, ())> for Ecu {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Ecu {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__control_unit_location, control_unit) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__control_unit_location, __dummy),
            },
            control_unit,
        })
    }
}

impl Ecu {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.control_unit, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Provides the address of a MEASUREMENT
#[derive(Clone)]
pub struct EcuAddress {
    pub address: u32,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for EcuAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("EcuAddress")
            .field("address", &self.address)
            .finish()
    }
}

impl EcuAddress {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(address: u32) -> Self {
        Self {
            address,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for EcuAddress {
    fn eq(&self, other: &Self) -> bool {
        self.address == other.address
    }
}

impl A2lObject<((u32, bool), ())> for EcuAddress {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for EcuAddress {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__address_location, address) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__address_location, __dummy),
            },
            address,
        })
    }
}

impl EcuAddress {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.address,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// Used to specify additional address information
#[derive(Clone)]
pub struct EcuAddressExtension {
    pub extension: i16,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for EcuAddressExtension {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("EcuAddressExtension")
            .field("extension", &self.extension)
            .finish()
    }
}

impl EcuAddressExtension {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(extension: i16) -> Self {
        Self {
            extension,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for EcuAddressExtension {
    fn eq(&self, other: &Self) -> bool {
        self.extension == other.extension
    }
}

impl A2lObject<((u32, bool), ())> for EcuAddressExtension {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for EcuAddressExtension {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__extension_location, extension) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<i16>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__extension_location, __dummy),
            },
            extension,
        })
    }
}

impl EcuAddressExtension {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.extension,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// Provide an address offset in order to handle near pointers or variant coding
#[derive(Clone)]
pub struct EcuCalibrationOffset {
    pub offset: i32,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for EcuCalibrationOffset {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("EcuCalibrationOffset")
            .field("offset", &self.offset)
            .finish()
    }
}

impl EcuCalibrationOffset {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(offset: i32) -> Self {
        Self {
            offset,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for EcuCalibrationOffset {
    fn eq(&self, other: &Self) -> bool {
        self.offset == other.offset
    }
}

impl A2lObject<((u32, bool), ())> for EcuCalibrationOffset {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for EcuCalibrationOffset {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__offset_location, offset) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<i32>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__offset_location, __dummy),
            },
            offset,
        })
    }
}

impl EcuCalibrationOffset {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.offset,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// a CHARACTERISTIC of type ASCII can be configured to use a multi-byte encoding instead
#[derive(Clone)]
pub struct Encoding {
    pub encoding: CharacterEncoding,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for Encoding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Encoding")
            .field("encoding", &self.encoding)
            .finish()
    }
}

impl Encoding {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(encoding: CharacterEncoding) -> Self {
        Self {
            encoding,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for Encoding {
    fn eq(&self, other: &Self) -> bool {
        self.encoding == other.encoding
    }
}

impl A2lObject<(u32, ())> for Encoding {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Encoding {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__encoding_location, encoding) = (
            parser.get_current_line_offset(),
            CharacterEncoding::parse(parser, context, 0)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__encoding_location, __dummy),
            },
            encoding,
        })
    }
}

impl Encoding {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(
            &self.encoding.to_string(),
            self.__block_info.item_location.0,
        );
        writer.finish()
    }
}

/// EPROM identifier
#[derive(Clone)]
pub struct Epk {
    pub identifier: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for Epk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Epk")
            .field("identifier", &self.identifier)
            .finish()
    }
}

impl Epk {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(identifier: String) -> Self {
        Self {
            identifier,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for Epk {
    fn eq(&self, other: &Self) -> bool {
        self.identifier == other.identifier
    }
}

impl A2lObject<(u32, ())> for Epk {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Epk {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__identifier_location, identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__identifier_location, __dummy),
            },
            identifier,
        })
    }
}

impl Epk {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.identifier, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Used to mask bits of a MEASUREMENT which indicate that the value is in error
#[derive(Clone)]
pub struct ErrorMask {
    pub mask: u64,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for ErrorMask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ErrorMask")
            .field("mask", &self.mask)
            .finish()
    }
}

impl ErrorMask {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(mask: u64) -> Self {
        Self {
            mask,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for ErrorMask {
    fn eq(&self, other: &Self) -> bool {
        self.mask == other.mask
    }
}

impl A2lObject<((u32, bool), ())> for ErrorMask {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for ErrorMask {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__mask_location, mask) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u64>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__mask_location, __dummy),
            },
            mask,
        })
    }
}

impl ErrorMask {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.mask,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// used to specify an extended range of values
#[derive(Clone)]
pub struct ExtendedLimits {
    pub lower_limit: f64,
    pub upper_limit: f64,
    pub(crate) __block_info: BlockInfo<(u32, u32)>,
}

impl std::fmt::Debug for ExtendedLimits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ExtendedLimits")
            .field("lower_limit", &self.lower_limit)
            .field("upper_limit", &self.upper_limit)
            .finish()
    }
}

impl ExtendedLimits {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(lower_limit: f64, upper_limit: f64) -> Self {
        Self {
            lower_limit,
            upper_limit,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, 0u32),
            },
        }
    }
}

impl PartialEq for ExtendedLimits {
    fn eq(&self, other: &Self) -> bool {
        (self.lower_limit == other.lower_limit) && (self.upper_limit == other.upper_limit)
    }
}

impl A2lObject<(u32, u32)> for ExtendedLimits {
    fn get_layout(&self) -> &BlockInfo<(u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for ExtendedLimits {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__lower_limit_location, lower_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__upper_limit_location, upper_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__lower_limit_location, __upper_limit_location),
            },
            lower_limit,
            upper_limit,
        })
    }
}

impl ExtendedLimits {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_float(self.lower_limit, self.__block_info.item_location.0);
        writer.add_float(self.upper_limit, self.__block_info.item_location.1);
        writer.finish()
    }
}

/// Parameters for the calculation of fixed axis points: `X_i` = Offset + (i - 1)*2^shift
#[derive(Clone)]
pub struct FixAxisPar {
    pub offset: i16,
    pub shift: i16,
    pub number_apo: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), (u32, bool), (u32, bool))>,
}

impl std::fmt::Debug for FixAxisPar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FixAxisPar")
            .field("offset", &self.offset)
            .field("shift", &self.shift)
            .field("number_apo", &self.number_apo)
            .finish()
    }
}

impl FixAxisPar {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(offset: i16, shift: i16, number_apo: u16) -> Self {
        Self {
            offset,
            shift,
            number_apo,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), (0u32, false), (0u32, false)),
            },
        }
    }
}

impl PartialEq for FixAxisPar {
    fn eq(&self, other: &Self) -> bool {
        (self.offset == other.offset)
            && (self.shift == other.shift)
            && (self.number_apo == other.number_apo)
    }
}

impl A2lObject<((u32, bool), (u32, bool), (u32, bool))> for FixAxisPar {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), (u32, bool), (u32, bool))> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), (u32, bool), (u32, bool))> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for FixAxisPar {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__offset_location, offset) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<i16>(context)?;
            ((line, is_hex), value)
        };
        let (__shift_location, shift) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<i16>(context)?;
            ((line, is_hex), value)
        };
        let (__number_apo_location, number_apo) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__offset_location, __shift_location, __number_apo_location),
            },
            offset,
            shift,
            number_apo,
        })
    }
}

impl FixAxisPar {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.offset,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_integer(
            self.shift,
            self.__block_info.item_location.1 .1,
            self.__block_info.item_location.1 .0,
        );
        writer.add_integer(
            self.number_apo,
            self.__block_info.item_location.2 .1,
            self.__block_info.item_location.2 .0,
        );
        writer.finish()
    }
}

/// Parameters for the calculation of fixed axis points: `X_i` = Offset + (i - 1)*distance
#[derive(Clone)]
pub struct FixAxisParDist {
    pub offset: i16,
    pub distance: i16,
    pub number_apo: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), (u32, bool), (u32, bool))>,
}

impl std::fmt::Debug for FixAxisParDist {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FixAxisParDist")
            .field("offset", &self.offset)
            .field("distance", &self.distance)
            .field("number_apo", &self.number_apo)
            .finish()
    }
}

impl FixAxisParDist {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(offset: i16, distance: i16, number_apo: u16) -> Self {
        Self {
            offset,
            distance,
            number_apo,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), (0u32, false), (0u32, false)),
            },
        }
    }
}

impl PartialEq for FixAxisParDist {
    fn eq(&self, other: &Self) -> bool {
        (self.offset == other.offset)
            && (self.distance == other.distance)
            && (self.number_apo == other.number_apo)
    }
}

impl A2lObject<((u32, bool), (u32, bool), (u32, bool))> for FixAxisParDist {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), (u32, bool), (u32, bool))> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), (u32, bool), (u32, bool))> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for FixAxisParDist {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__offset_location, offset) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<i16>(context)?;
            ((line, is_hex), value)
        };
        let (__distance_location, distance) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<i16>(context)?;
            ((line, is_hex), value)
        };
        let (__number_apo_location, number_apo) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __offset_location,
                    __distance_location,
                    __number_apo_location,
                ),
            },
            offset,
            distance,
            number_apo,
        })
    }
}

impl FixAxisParDist {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.offset,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_integer(
            self.distance,
            self.__block_info.item_location.1 .1,
            self.__block_info.item_location.1 .0,
        );
        writer.add_integer(
            self.number_apo,
            self.__block_info.item_location.2 .1,
            self.__block_info.item_location.2 .0,
        );
        writer.finish()
    }
}

/// A list of fixed axis point, as implemented on the ECU
#[derive(Clone)]
pub struct FixAxisParList {
    pub axis_pts_value_list: Vec<f64>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for FixAxisParList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FixAxisParList")
            .field("axis_pts_value_list", &self.axis_pts_value_list)
            .finish()
    }
}

impl FixAxisParList {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            axis_pts_value_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for FixAxisParList {
    fn eq(&self, other: &Self) -> bool {
        self.axis_pts_value_list == other.axis_pts_value_list
    }
}

impl A2lObject<(Vec<u32>, ())> for FixAxisParList {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for FixAxisParList {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut axis_pts_value_list = Vec::new();
        let mut __axis_pts_value_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_double(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    axis_pts_value_list.push(value);
                    __axis_pts_value_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__axis_pts_value_list_location, __dummy),
            },
            axis_pts_value_list,
        })
    }
}

impl FixAxisParList {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.axis_pts_value_list.iter().enumerate() {
            writer.add_float(
                *seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// Specifies the number of axis points available to CURVE, MAP, CUBOID, `CUBE_4` or `CUBE_5`
#[derive(Clone)]
pub struct FixNoAxisPtsDim {
    pub number_of_axis_points: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for FixNoAxisPtsDim {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FixNoAxisPtsDim")
            .field("number_of_axis_points", &self.number_of_axis_points)
            .finish()
    }
}

impl FixNoAxisPtsDim {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(number_of_axis_points: u16) -> Self {
        Self {
            number_of_axis_points,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for FixNoAxisPtsDim {
    fn eq(&self, other: &Self) -> bool {
        self.number_of_axis_points == other.number_of_axis_points
    }
}

impl A2lObject<((u32, bool), ())> for FixNoAxisPtsDim {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for FixNoAxisPtsDim {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__number_of_axis_points_location, number_of_axis_points) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__number_of_axis_points_location, __dummy),
            },
            number_of_axis_points,
        })
    }
}

impl FixNoAxisPtsDim {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.number_of_axis_points,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// Description of the table values (function values) of an adjustable object
#[derive(Clone)]
pub struct FncValues {
    pub position: u16,
    pub datatype: DataType,
    pub index_mode: IndexMode,
    pub address_type: AddrType,
    pub(crate) __block_info: BlockInfo<((u32, bool), u32, u32, u32)>,
}

impl std::fmt::Debug for FncValues {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FncValues")
            .field("position", &self.position)
            .field("datatype", &self.datatype)
            .field("index_mode", &self.index_mode)
            .field("address_type", &self.address_type)
            .finish()
    }
}

impl FncValues {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        position: u16,
        datatype: DataType,
        index_mode: IndexMode,
        address_type: AddrType,
    ) -> Self {
        Self {
            position,
            datatype,
            index_mode,
            address_type,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), 0u32, 0u32, 0u32),
            },
        }
    }
}

impl PartialEq for FncValues {
    fn eq(&self, other: &Self) -> bool {
        (self.position == other.position)
            && (self.datatype == other.datatype)
            && (self.index_mode == other.index_mode)
            && (self.address_type == other.address_type)
    }
}

impl A2lObject<((u32, bool), u32, u32, u32)> for FncValues {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), u32, u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), u32, u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for FncValues {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__position_location, position) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__datatype_location, datatype) = (
            parser.get_current_line_offset(),
            DataType::parse(parser, context, 0)?,
        );
        let (__index_mode_location, index_mode) = (
            parser.get_current_line_offset(),
            IndexMode::parse(parser, context, 0)?,
        );
        let (__address_type_location, address_type) = (
            parser.get_current_line_offset(),
            AddrType::parse(parser, context, 0)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __position_location,
                    __datatype_location,
                    __index_mode_location,
                    __address_type_location,
                ),
            },
            position,
            datatype,
            index_mode,
            address_type,
        })
    }
}

impl FncValues {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.position,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_str(
            &self.datatype.to_string(),
            self.__block_info.item_location.1,
        );
        writer.add_str(
            &self.index_mode.to_string(),
            self.__block_info.item_location.2,
        );
        writer.add_str(
            &self.address_type.to_string(),
            self.__block_info.item_location.3,
        );
        writer.finish()
    }
}

/// Allows a display format string to be specified for a MEASUREMENT, CHARACTERISTIC or `AXIS_PTS` object
#[derive(Clone)]
pub struct Format {
    pub format_string: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for Format {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Format")
            .field("format_string", &self.format_string)
            .finish()
    }
}

impl Format {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(format_string: String) -> Self {
        Self {
            format_string,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for Format {
    fn eq(&self, other: &Self) -> bool {
        self.format_string == other.format_string
    }
}

impl A2lObject<(u32, ())> for Format {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Format {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__format_string_location, format_string) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__format_string_location, __dummy),
            },
            format_string,
        })
    }
}

impl Format {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.format_string, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Allows any kind of formula to be specified
#[derive(Clone)]
pub struct Formula {
    pub fx: String,
    pub formula_inv: Option<FormulaInv>,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for Formula {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Formula")
            .field("fx", &self.fx)
            .field("formula_inv", &self.formula_inv)
            .finish()
    }
}

impl Formula {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(fx: String) -> Self {
        Self {
            fx,
            formula_inv: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (1u32, ()),
            },
        }
    }
}

impl PartialEq for Formula {
    fn eq(&self, other: &Self) -> bool {
        (self.fx == other.fx) && (self.formula_inv == other.formula_inv)
    }
}

impl A2lObject<(u32, ())> for Formula {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(formula_inv) = &mut self.formula_inv {
            formula_inv.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Formula {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__fx_location, fx) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let mut formula_inv: Option<FormulaInv> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 1usize] = ["FORMULA_INV"];
            match tag {
                "FORMULA_INV" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = FormulaInv::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, formula_inv.is_some())?;
                    formula_inv = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__fx_location, __dummy),
            },
            fx,
            formula_inv,
        })
    }
}

impl Formula {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.fx, self.__block_info.item_location.0);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(formula_inv) = &self.formula_inv {
            let formula_inv_out = formula_inv.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FORMULA_INV",
                item_text: formula_inv_out,
                is_block: false,
                incfile: &formula_inv.__block_info.incfile,
                uid: formula_inv.__block_info.uid,
                line: formula_inv.__block_info.line,
                start_offset: formula_inv.__block_info.start_offset,
                end_offset: formula_inv.__block_info.end_offset,
                position_restriction: formula_inv.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Allows an inverse formula to be specified
#[derive(Clone)]
pub struct FormulaInv {
    pub gx: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for FormulaInv {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FormulaInv").field("gx", &self.gx).finish()
    }
}

impl FormulaInv {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(gx: String) -> Self {
        Self {
            gx,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for FormulaInv {
    fn eq(&self, other: &Self) -> bool {
        self.gx == other.gx
    }
}

impl A2lObject<(u32, ())> for FormulaInv {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for FormulaInv {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__gx_location, gx) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__gx_location, __dummy),
            },
            gx,
        })
    }
}

impl FormulaInv {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.gx, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Defines a function frame to structure large amounts of measurement objects
#[derive(Clone)]
pub struct Frame {
    pub name: String,
    pub long_identifier: String,
    pub scaling_unit: u16,
    pub rate: u32,
    pub frame_measurement: Option<FrameMeasurement>,
    pub if_data: Vec<IfData>,
    pub(crate) __block_info: BlockInfo<(u32, u32, (u32, bool), (u32, bool))>,
}

impl std::fmt::Debug for Frame {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Frame")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("scaling_unit", &self.scaling_unit)
            .field("rate", &self.rate)
            .field("frame_measurement", &self.frame_measurement)
            .field("if_data", &self.if_data)
            .finish()
    }
}

impl Frame {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String, long_identifier: String, scaling_unit: u16, rate: u32) -> Self {
        Self {
            name,
            long_identifier,
            scaling_unit,
            rate,
            frame_measurement: None,
            if_data: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32, (1u32, false), (0u32, false)),
            },
        }
    }
}

impl PartialEq for Frame {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.scaling_unit == other.scaling_unit)
            && (self.rate == other.rate)
            && (self.frame_measurement == other.frame_measurement)
            && (self.if_data == other.if_data)
    }
}

impl A2lObject<(u32, u32, (u32, bool), (u32, bool))> for Frame {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, (u32, bool), (u32, bool))> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, (u32, bool), (u32, bool))> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(frame_measurement) = &mut self.frame_measurement {
            frame_measurement.merge_includes();
        }
        for if_data in &mut self.if_data {
            if_data.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for Frame {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for Frame {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__scaling_unit_location, scaling_unit) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__rate_location, rate) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let mut frame_measurement: Option<FrameMeasurement> = None;
        let mut if_data: Vec<IfData> = Vec::new();
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 2usize] = ["FRAME_MEASUREMENT", "IF_DATA"];
            match tag {
                "FRAME_MEASUREMENT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = FrameMeasurement::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, frame_measurement.is_some())?;
                    frame_measurement = Some(newitem);
                }
                "IF_DATA" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = IfData::parse(parser, &newcontext, line_offset)?;
                    if_data.push(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __scaling_unit_location,
                    __rate_location,
                ),
            },
            name,
            long_identifier,
            scaling_unit,
            rate,
            frame_measurement,
            if_data,
        })
    }
}

impl Frame {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_integer(
            self.scaling_unit,
            self.__block_info.item_location.2 .1,
            self.__block_info.item_location.2 .0,
        );
        writer.add_integer(
            self.rate,
            self.__block_info.item_location.3 .1,
            self.__block_info.item_location.3 .0,
        );
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(frame_measurement) = &self.frame_measurement {
            let frame_measurement_out = frame_measurement.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FRAME_MEASUREMENT",
                item_text: frame_measurement_out,
                is_block: false,
                incfile: &frame_measurement.__block_info.incfile,
                uid: frame_measurement.__block_info.uid,
                line: frame_measurement.__block_info.line,
                start_offset: frame_measurement.__block_info.start_offset,
                end_offset: frame_measurement.__block_info.end_offset,
                position_restriction: frame_measurement.pos_restrict(),
            });
        }
        for if_data in &self.if_data {
            let if_data_out = if_data.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "IF_DATA",
                item_text: if_data_out,
                is_block: true,
                incfile: &if_data.__block_info.incfile,
                uid: if_data.__block_info.uid,
                line: if_data.__block_info.line,
                start_offset: if_data.__block_info.start_offset,
                end_offset: if_data.__block_info.end_offset,
                position_restriction: if_data.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Contains a list of identifiers of measurement objects
#[derive(Clone)]
pub struct FrameMeasurement {
    pub identifier_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for FrameMeasurement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FrameMeasurement")
            .field("identifier_list", &self.identifier_list)
            .finish()
    }
}

impl FrameMeasurement {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            identifier_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for FrameMeasurement {
    fn eq(&self, other: &Self) -> bool {
        self.identifier_list == other.identifier_list
    }
}

impl A2lObject<(Vec<u32>, ())> for FrameMeasurement {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for FrameMeasurement {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut identifier_list = Vec::new();
        let mut __identifier_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    identifier_list.push(value);
                    __identifier_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__identifier_list_location, __dummy),
            },
            identifier_list,
        })
    }
}

impl FrameMeasurement {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.identifier_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// Describes the input, local, and output variables of a function on the ECU
#[derive(Clone)]
pub struct Function {
    pub name: String,
    pub long_identifier: String,
    pub annotation: Vec<Annotation>,
    pub ar_component: Option<ArComponent>,
    pub def_characteristic: Option<DefCharacteristic>,
    pub function_version: Option<FunctionVersion>,
    pub if_data: Vec<IfData>,
    pub in_measurement: Option<InMeasurement>,
    pub loc_measurement: Option<LocMeasurement>,
    pub out_measurement: Option<OutMeasurement>,
    pub ref_characteristic: Option<RefCharacteristic>,
    pub sub_function: Option<SubFunction>,
    pub(crate) __block_info: BlockInfo<(u32, u32)>,
}

impl std::fmt::Debug for Function {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Function")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("annotation", &self.annotation)
            .field("ar_component", &self.ar_component)
            .field("def_characteristic", &self.def_characteristic)
            .field("function_version", &self.function_version)
            .field("if_data", &self.if_data)
            .field("in_measurement", &self.in_measurement)
            .field("loc_measurement", &self.loc_measurement)
            .field("out_measurement", &self.out_measurement)
            .field("ref_characteristic", &self.ref_characteristic)
            .field("sub_function", &self.sub_function)
            .finish()
    }
}

impl Function {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String, long_identifier: String) -> Self {
        Self {
            name,
            long_identifier,
            annotation: Vec::new(),
            ar_component: None,
            def_characteristic: None,
            function_version: None,
            if_data: Vec::new(),
            in_measurement: None,
            loc_measurement: None,
            out_measurement: None,
            ref_characteristic: None,
            sub_function: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32),
            },
        }
    }
}

impl PartialEq for Function {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.annotation == other.annotation)
            && (self.ar_component == other.ar_component)
            && (self.def_characteristic == other.def_characteristic)
            && (self.function_version == other.function_version)
            && (self.if_data == other.if_data)
            && (self.in_measurement == other.in_measurement)
            && (self.loc_measurement == other.loc_measurement)
            && (self.out_measurement == other.out_measurement)
            && (self.ref_characteristic == other.ref_characteristic)
            && (self.sub_function == other.sub_function)
    }
}

impl A2lObject<(u32, u32)> for Function {
    fn get_layout(&self) -> &BlockInfo<(u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        for annotation in &mut self.annotation {
            annotation.merge_includes();
        }
        if let Some(ar_component) = &mut self.ar_component {
            ar_component.merge_includes();
        }
        if let Some(def_characteristic) = &mut self.def_characteristic {
            def_characteristic.merge_includes();
        }
        if let Some(function_version) = &mut self.function_version {
            function_version.merge_includes();
        }
        for if_data in &mut self.if_data {
            if_data.merge_includes();
        }
        if let Some(in_measurement) = &mut self.in_measurement {
            in_measurement.merge_includes();
        }
        if let Some(loc_measurement) = &mut self.loc_measurement {
            loc_measurement.merge_includes();
        }
        if let Some(out_measurement) = &mut self.out_measurement {
            out_measurement.merge_includes();
        }
        if let Some(ref_characteristic) = &mut self.ref_characteristic {
            ref_characteristic.merge_includes();
        }
        if let Some(sub_function) = &mut self.sub_function {
            sub_function.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for Function {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for Function {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let mut annotation: Vec<Annotation> = Vec::new();
        let mut ar_component: Option<ArComponent> = None;
        let mut def_characteristic: Option<DefCharacteristic> = None;
        let mut function_version: Option<FunctionVersion> = None;
        let mut if_data: Vec<IfData> = Vec::new();
        let mut in_measurement: Option<InMeasurement> = None;
        let mut loc_measurement: Option<LocMeasurement> = None;
        let mut out_measurement: Option<OutMeasurement> = None;
        let mut ref_characteristic: Option<RefCharacteristic> = None;
        let mut sub_function: Option<SubFunction> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 10usize] = [
                "ANNOTATION",
                "AR_COMPONENT",
                "DEF_CHARACTERISTIC",
                "FUNCTION_VERSION",
                "IF_DATA",
                "IN_MEASUREMENT",
                "LOC_MEASUREMENT",
                "OUT_MEASUREMENT",
                "REF_CHARACTERISTIC",
                "SUB_FUNCTION",
            ];
            match tag {
                "ANNOTATION" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Annotation::parse(parser, &newcontext, line_offset)?;
                    annotation.push(newitem);
                }
                "AR_COMPONENT" => {
                    parser.require_block(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "AR_COMPONENT",
                        A2lVersion::V1_7_0,
                    )?;
                    let newitem = ArComponent::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, ar_component.is_some())?;
                    ar_component = Some(newitem);
                }
                "DEF_CHARACTERISTIC" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = DefCharacteristic::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, def_characteristic.is_some())?;
                    def_characteristic = Some(newitem);
                }
                "FUNCTION_VERSION" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = FunctionVersion::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, function_version.is_some())?;
                    function_version = Some(newitem);
                }
                "IF_DATA" => {
                    parser.require_block(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "IF_DATA", A2lVersion::V1_6_0)?;
                    let newitem = IfData::parse(parser, &newcontext, line_offset)?;
                    if_data.push(newitem);
                }
                "IN_MEASUREMENT" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = InMeasurement::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, in_measurement.is_some())?;
                    in_measurement = Some(newitem);
                }
                "LOC_MEASUREMENT" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = LocMeasurement::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, loc_measurement.is_some())?;
                    loc_measurement = Some(newitem);
                }
                "OUT_MEASUREMENT" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = OutMeasurement::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, out_measurement.is_some())?;
                    out_measurement = Some(newitem);
                }
                "REF_CHARACTERISTIC" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = RefCharacteristic::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, ref_characteristic.is_some())?;
                    ref_characteristic = Some(newitem);
                }
                "SUB_FUNCTION" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = SubFunction::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, sub_function.is_some())?;
                    sub_function = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __long_identifier_location),
            },
            name,
            long_identifier,
            annotation,
            ar_component,
            def_characteristic,
            function_version,
            if_data,
            in_measurement,
            loc_measurement,
            out_measurement,
            ref_characteristic,
            sub_function,
        })
    }
}

impl Function {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        for annotation in &self.annotation {
            let annotation_out = annotation.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ANNOTATION",
                item_text: annotation_out,
                is_block: true,
                incfile: &annotation.__block_info.incfile,
                uid: annotation.__block_info.uid,
                line: annotation.__block_info.line,
                start_offset: annotation.__block_info.start_offset,
                end_offset: annotation.__block_info.end_offset,
                position_restriction: annotation.pos_restrict(),
            });
        }
        if let Some(ar_component) = &self.ar_component {
            let ar_component_out = ar_component.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AR_COMPONENT",
                item_text: ar_component_out,
                is_block: true,
                incfile: &ar_component.__block_info.incfile,
                uid: ar_component.__block_info.uid,
                line: ar_component.__block_info.line,
                start_offset: ar_component.__block_info.start_offset,
                end_offset: ar_component.__block_info.end_offset,
                position_restriction: ar_component.pos_restrict(),
            });
        }
        if let Some(def_characteristic) = &self.def_characteristic {
            let def_characteristic_out = def_characteristic.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DEF_CHARACTERISTIC",
                item_text: def_characteristic_out,
                is_block: true,
                incfile: &def_characteristic.__block_info.incfile,
                uid: def_characteristic.__block_info.uid,
                line: def_characteristic.__block_info.line,
                start_offset: def_characteristic.__block_info.start_offset,
                end_offset: def_characteristic.__block_info.end_offset,
                position_restriction: def_characteristic.pos_restrict(),
            });
        }
        if let Some(function_version) = &self.function_version {
            let function_version_out = function_version.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FUNCTION_VERSION",
                item_text: function_version_out,
                is_block: false,
                incfile: &function_version.__block_info.incfile,
                uid: function_version.__block_info.uid,
                line: function_version.__block_info.line,
                start_offset: function_version.__block_info.start_offset,
                end_offset: function_version.__block_info.end_offset,
                position_restriction: function_version.pos_restrict(),
            });
        }
        for if_data in &self.if_data {
            let if_data_out = if_data.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "IF_DATA",
                item_text: if_data_out,
                is_block: true,
                incfile: &if_data.__block_info.incfile,
                uid: if_data.__block_info.uid,
                line: if_data.__block_info.line,
                start_offset: if_data.__block_info.start_offset,
                end_offset: if_data.__block_info.end_offset,
                position_restriction: if_data.pos_restrict(),
            });
        }
        if let Some(in_measurement) = &self.in_measurement {
            let in_measurement_out = in_measurement.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "IN_MEASUREMENT",
                item_text: in_measurement_out,
                is_block: true,
                incfile: &in_measurement.__block_info.incfile,
                uid: in_measurement.__block_info.uid,
                line: in_measurement.__block_info.line,
                start_offset: in_measurement.__block_info.start_offset,
                end_offset: in_measurement.__block_info.end_offset,
                position_restriction: in_measurement.pos_restrict(),
            });
        }
        if let Some(loc_measurement) = &self.loc_measurement {
            let loc_measurement_out = loc_measurement.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "LOC_MEASUREMENT",
                item_text: loc_measurement_out,
                is_block: true,
                incfile: &loc_measurement.__block_info.incfile,
                uid: loc_measurement.__block_info.uid,
                line: loc_measurement.__block_info.line,
                start_offset: loc_measurement.__block_info.start_offset,
                end_offset: loc_measurement.__block_info.end_offset,
                position_restriction: loc_measurement.pos_restrict(),
            });
        }
        if let Some(out_measurement) = &self.out_measurement {
            let out_measurement_out = out_measurement.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "OUT_MEASUREMENT",
                item_text: out_measurement_out,
                is_block: true,
                incfile: &out_measurement.__block_info.incfile,
                uid: out_measurement.__block_info.uid,
                line: out_measurement.__block_info.line,
                start_offset: out_measurement.__block_info.start_offset,
                end_offset: out_measurement.__block_info.end_offset,
                position_restriction: out_measurement.pos_restrict(),
            });
        }
        if let Some(ref_characteristic) = &self.ref_characteristic {
            let ref_characteristic_out = ref_characteristic.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "REF_CHARACTERISTIC",
                item_text: ref_characteristic_out,
                is_block: true,
                incfile: &ref_characteristic.__block_info.incfile,
                uid: ref_characteristic.__block_info.uid,
                line: ref_characteristic.__block_info.line,
                start_offset: ref_characteristic.__block_info.start_offset,
                end_offset: ref_characteristic.__block_info.end_offset,
                position_restriction: ref_characteristic.pos_restrict(),
            });
        }
        if let Some(sub_function) = &self.sub_function {
            let sub_function_out = sub_function.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SUB_FUNCTION",
                item_text: sub_function_out,
                is_block: true,
                incfile: &sub_function.__block_info.incfile,
                uid: sub_function.__block_info.uid,
                line: sub_function.__block_info.line,
                start_offset: sub_function.__block_info.start_offset,
                end_offset: sub_function.__block_info.end_offset,
                position_restriction: sub_function.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// a list of FUNCTION objects
#[derive(Clone)]
pub struct FunctionList {
    pub name_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for FunctionList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FunctionList")
            .field("name_list", &self.name_list)
            .finish()
    }
}

impl FunctionList {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            name_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for FunctionList {
    fn eq(&self, other: &Self) -> bool {
        self.name_list == other.name_list
    }
}

impl A2lObject<(Vec<u32>, ())> for FunctionList {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for FunctionList {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut name_list = Vec::new();
        let mut __name_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    name_list.push(value);
                    __name_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_list_location, __dummy),
            },
            name_list,
        })
    }
}

impl FunctionList {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.name_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// A string containing the version of a FUNCTION
#[derive(Clone)]
pub struct FunctionVersion {
    pub version_identifier: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for FunctionVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FunctionVersion")
            .field("version_identifier", &self.version_identifier)
            .finish()
    }
}

impl FunctionVersion {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(version_identifier: String) -> Self {
        Self {
            version_identifier,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for FunctionVersion {
    fn eq(&self, other: &Self) -> bool {
        self.version_identifier == other.version_identifier
    }
}

impl A2lObject<(u32, ())> for FunctionVersion {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for FunctionVersion {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__version_identifier_location, version_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__version_identifier_location, __dummy),
            },
            version_identifier,
        })
    }
}

impl FunctionVersion {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.version_identifier, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Defines a group of releated CHARACTERISTIC and MEASUREMENT objects
#[derive(Clone)]
pub struct Group {
    pub name: String,
    pub long_identifier: String,
    pub annotation: Vec<Annotation>,
    pub function_list: Option<FunctionList>,
    pub if_data: Vec<IfData>,
    pub ref_characteristic: Option<RefCharacteristic>,
    pub ref_measurement: Option<RefMeasurement>,
    pub root: Option<Root>,
    pub sub_group: Option<SubGroup>,
    pub(crate) __block_info: BlockInfo<(u32, u32)>,
}

impl std::fmt::Debug for Group {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Group")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("annotation", &self.annotation)
            .field("function_list", &self.function_list)
            .field("if_data", &self.if_data)
            .field("ref_characteristic", &self.ref_characteristic)
            .field("ref_measurement", &self.ref_measurement)
            .field("root", &self.root)
            .field("sub_group", &self.sub_group)
            .finish()
    }
}

impl Group {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String, long_identifier: String) -> Self {
        Self {
            name,
            long_identifier,
            annotation: Vec::new(),
            function_list: None,
            if_data: Vec::new(),
            ref_characteristic: None,
            ref_measurement: None,
            root: None,
            sub_group: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32),
            },
        }
    }
}

impl PartialEq for Group {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.annotation == other.annotation)
            && (self.function_list == other.function_list)
            && (self.if_data == other.if_data)
            && (self.ref_characteristic == other.ref_characteristic)
            && (self.ref_measurement == other.ref_measurement)
            && (self.root == other.root)
            && (self.sub_group == other.sub_group)
    }
}

impl A2lObject<(u32, u32)> for Group {
    fn get_layout(&self) -> &BlockInfo<(u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        for annotation in &mut self.annotation {
            annotation.merge_includes();
        }
        if let Some(function_list) = &mut self.function_list {
            function_list.merge_includes();
        }
        for if_data in &mut self.if_data {
            if_data.merge_includes();
        }
        if let Some(ref_characteristic) = &mut self.ref_characteristic {
            ref_characteristic.merge_includes();
        }
        if let Some(ref_measurement) = &mut self.ref_measurement {
            ref_measurement.merge_includes();
        }
        if let Some(root) = &mut self.root {
            root.merge_includes();
        }
        if let Some(sub_group) = &mut self.sub_group {
            sub_group.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for Group {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for Group {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let mut annotation: Vec<Annotation> = Vec::new();
        let mut function_list: Option<FunctionList> = None;
        let mut if_data: Vec<IfData> = Vec::new();
        let mut ref_characteristic: Option<RefCharacteristic> = None;
        let mut ref_measurement: Option<RefMeasurement> = None;
        let mut root: Option<Root> = None;
        let mut sub_group: Option<SubGroup> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 7usize] = [
                "ANNOTATION",
                "FUNCTION_LIST",
                "IF_DATA",
                "REF_CHARACTERISTIC",
                "REF_MEASUREMENT",
                "ROOT",
                "SUB_GROUP",
            ];
            match tag {
                "ANNOTATION" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Annotation::parse(parser, &newcontext, line_offset)?;
                    annotation.push(newitem);
                }
                "FUNCTION_LIST" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = FunctionList::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, function_list.is_some())?;
                    function_list = Some(newitem);
                }
                "IF_DATA" => {
                    parser.require_block(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "IF_DATA", A2lVersion::V1_6_0)?;
                    let newitem = IfData::parse(parser, &newcontext, line_offset)?;
                    if_data.push(newitem);
                }
                "REF_CHARACTERISTIC" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = RefCharacteristic::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, ref_characteristic.is_some())?;
                    ref_characteristic = Some(newitem);
                }
                "REF_MEASUREMENT" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = RefMeasurement::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, ref_measurement.is_some())?;
                    ref_measurement = Some(newitem);
                }
                "ROOT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Root::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, root.is_some())?;
                    root = Some(newitem);
                }
                "SUB_GROUP" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = SubGroup::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, sub_group.is_some())?;
                    sub_group = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __long_identifier_location),
            },
            name,
            long_identifier,
            annotation,
            function_list,
            if_data,
            ref_characteristic,
            ref_measurement,
            root,
            sub_group,
        })
    }
}

impl Group {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        for annotation in &self.annotation {
            let annotation_out = annotation.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ANNOTATION",
                item_text: annotation_out,
                is_block: true,
                incfile: &annotation.__block_info.incfile,
                uid: annotation.__block_info.uid,
                line: annotation.__block_info.line,
                start_offset: annotation.__block_info.start_offset,
                end_offset: annotation.__block_info.end_offset,
                position_restriction: annotation.pos_restrict(),
            });
        }
        if let Some(function_list) = &self.function_list {
            let function_list_out = function_list.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FUNCTION_LIST",
                item_text: function_list_out,
                is_block: true,
                incfile: &function_list.__block_info.incfile,
                uid: function_list.__block_info.uid,
                line: function_list.__block_info.line,
                start_offset: function_list.__block_info.start_offset,
                end_offset: function_list.__block_info.end_offset,
                position_restriction: function_list.pos_restrict(),
            });
        }
        for if_data in &self.if_data {
            let if_data_out = if_data.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "IF_DATA",
                item_text: if_data_out,
                is_block: true,
                incfile: &if_data.__block_info.incfile,
                uid: if_data.__block_info.uid,
                line: if_data.__block_info.line,
                start_offset: if_data.__block_info.start_offset,
                end_offset: if_data.__block_info.end_offset,
                position_restriction: if_data.pos_restrict(),
            });
        }
        if let Some(ref_characteristic) = &self.ref_characteristic {
            let ref_characteristic_out = ref_characteristic.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "REF_CHARACTERISTIC",
                item_text: ref_characteristic_out,
                is_block: true,
                incfile: &ref_characteristic.__block_info.incfile,
                uid: ref_characteristic.__block_info.uid,
                line: ref_characteristic.__block_info.line,
                start_offset: ref_characteristic.__block_info.start_offset,
                end_offset: ref_characteristic.__block_info.end_offset,
                position_restriction: ref_characteristic.pos_restrict(),
            });
        }
        if let Some(ref_measurement) = &self.ref_measurement {
            let ref_measurement_out = ref_measurement.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "REF_MEASUREMENT",
                item_text: ref_measurement_out,
                is_block: true,
                incfile: &ref_measurement.__block_info.incfile,
                uid: ref_measurement.__block_info.uid,
                line: ref_measurement.__block_info.line,
                start_offset: ref_measurement.__block_info.start_offset,
                end_offset: ref_measurement.__block_info.end_offset,
                position_restriction: ref_measurement.pos_restrict(),
            });
        }
        if let Some(root) = &self.root {
            let root_out = root.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ROOT",
                item_text: root_out,
                is_block: false,
                incfile: &root.__block_info.incfile,
                uid: root.__block_info.uid,
                line: root.__block_info.line,
                start_offset: root.__block_info.start_offset,
                end_offset: root.__block_info.end_offset,
                position_restriction: root.pos_restrict(),
            });
        }
        if let Some(sub_group) = &self.sub_group {
            let sub_group_out = sub_group.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SUB_GROUP",
                item_text: sub_group_out,
                is_block: true,
                incfile: &sub_group.__block_info.incfile,
                uid: sub_group.__block_info.uid,
                line: sub_group.__block_info.line,
                start_offset: sub_group.__block_info.start_offset,
                end_offset: sub_group.__block_info.end_offset,
                position_restriction: sub_group.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Used to indicate that an adjustable CURVE, MAP or `AXIS_PTS` uses guard rails
#[derive(Clone)]
pub struct GuardRails {
    pub(crate) __block_info: BlockInfo<()>,
}

impl std::fmt::Debug for GuardRails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("GuardRails").finish()
    }
}

impl GuardRails {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (),
            },
        }
    }
}

impl PartialEq for GuardRails {
    fn eq(&self, _other: &Self) -> bool {
        true
    }
}

impl A2lObject<()> for GuardRails {
    fn get_layout(&self) -> &BlockInfo<()> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<()> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for GuardRails {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (),
            },
        })
    }
}

impl GuardRails {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let writer = writer::Writer::new(indent);
        writer.finish()
    }
}

/// The header of a project
#[derive(Clone)]
pub struct Header {
    pub comment: String,
    pub project_no: Option<ProjectNo>,
    pub version: Option<Version>,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for Header {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Header")
            .field("comment", &self.comment)
            .field("project_no", &self.project_no)
            .field("version", &self.version)
            .finish()
    }
}

impl Header {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(comment: String) -> Self {
        Self {
            comment,
            project_no: None,
            version: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (1u32, ()),
            },
        }
    }
}

impl PartialEq for Header {
    fn eq(&self, other: &Self) -> bool {
        (self.comment == other.comment)
            && (self.project_no == other.project_no)
            && (self.version == other.version)
    }
}

impl A2lObject<(u32, ())> for Header {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(project_no) = &mut self.project_no {
            project_no.merge_includes();
        }
        if let Some(version) = &mut self.version {
            version.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Header {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__comment_location, comment) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let mut project_no: Option<ProjectNo> = None;
        let mut version: Option<Version> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 2usize] = ["PROJECT_NO", "VERSION"];
            match tag {
                "PROJECT_NO" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ProjectNo::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, project_no.is_some())?;
                    project_no = Some(newitem);
                }
                "VERSION" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Version::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, version.is_some())?;
                    version = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__comment_location, __dummy),
            },
            comment,
            project_no,
            version,
        })
    }
}

impl Header {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.comment, self.__block_info.item_location.0);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(project_no) = &self.project_no {
            let project_no_out = project_no.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "PROJECT_NO",
                item_text: project_no_out,
                is_block: false,
                incfile: &project_no.__block_info.incfile,
                uid: project_no.__block_info.uid,
                line: project_no.__block_info.line,
                start_offset: project_no.__block_info.start_offset,
                end_offset: project_no.__block_info.end_offset,
                position_restriction: project_no.pos_restrict(),
            });
        }
        if let Some(version) = &self.version {
            let version_out = version.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "VERSION",
                item_text: version_out,
                is_block: false,
                incfile: &version.__block_info.incfile,
                uid: version.__block_info.uid,
                line: version.__block_info.line,
                start_offset: version.__block_info.start_offset,
                end_offset: version.__block_info.end_offset,
                position_restriction: version.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// used to describe that an \'identifier\' is deposited in a specific position in the adjustable object
#[derive(Clone)]
pub struct Identification {
    pub position: u16,
    pub datatype: DataType,
    pub(crate) __block_info: BlockInfo<((u32, bool), u32)>,
}

impl std::fmt::Debug for Identification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Identification")
            .field("position", &self.position)
            .field("datatype", &self.datatype)
            .finish()
    }
}

impl Identification {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(position: u16, datatype: DataType) -> Self {
        Self {
            position,
            datatype,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), 0u32),
            },
        }
    }
}

impl PartialEq for Identification {
    fn eq(&self, other: &Self) -> bool {
        (self.position == other.position) && (self.datatype == other.datatype)
    }
}

impl A2lObject<((u32, bool), u32)> for Identification {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Identification {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__position_location, position) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__datatype_location, datatype) = (
            parser.get_current_line_offset(),
            DataType::parse(parser, context, 0)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__position_location, __datatype_location),
            },
            position,
            datatype,
        })
    }
}

impl Identification {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.position,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_str(
            &self.datatype.to_string(),
            self.__block_info.item_location.1,
        );
        writer.finish()
    }
}

/// Interface specific data
/// A list of measurement objects that are used as the inputs of a function
#[derive(Clone)]
pub struct InMeasurement {
    pub identifier_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for InMeasurement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("InMeasurement")
            .field("identifier_list", &self.identifier_list)
            .finish()
    }
}

impl InMeasurement {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            identifier_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for InMeasurement {
    fn eq(&self, other: &Self) -> bool {
        self.identifier_list == other.identifier_list
    }
}

impl A2lObject<(Vec<u32>, ())> for InMeasurement {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for InMeasurement {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut identifier_list = Vec::new();
        let mut __identifier_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    identifier_list.push(value);
                    __identifier_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__identifier_list_location, __dummy),
            },
            identifier_list,
        })
    }
}

impl InMeasurement {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.identifier_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// Describes how the 2-dimensional table values are mapped onto the 1-dimensional address space
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum IndexMode {
    AlternateCurves,
    AlternateWithX,
    AlternateWithY,
    ColumnDir,
    RowDir,
}

impl ParseableA2lObject for IndexMode {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "ALTERNATE_CURVES" => Ok(Self::AlternateCurves),
            "ALTERNATE_WITH_X" => Ok(Self::AlternateWithX),
            "ALTERNATE_WITH_Y" => Ok(Self::AlternateWithY),
            "COLUMN_DIR" => Ok(Self::ColumnDir),
            "ROW_DIR" => Ok(Self::RowDir),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for IndexMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::AlternateCurves => "ALTERNATE_CURVES",
            Self::AlternateWithX => "ALTERNATE_WITH_X",
            Self::AlternateWithY => "ALTERNATE_WITH_Y",
            Self::ColumnDir => "COLUMN_DIR",
            Self::RowDir => "ROW_DIR",
        };
        f.write_str(tag)
    }
}

/// Description of the axis point sequence in the memory.
///
/// Specification: predefined data types
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum IndexOrder {
    IndexIncr,
    IndexDecr,
}

impl ParseableA2lObject for IndexOrder {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "INDEX_INCR" => Ok(Self::IndexIncr),
            "INDEX_DECR" => Ok(Self::IndexDecr),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for IndexOrder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::IndexIncr => "INDEX_INCR",
            Self::IndexDecr => "INDEX_DECR",
        };
        f.write_str(tag)
    }
}

///`INPUT_QUANTITY` is used inside OVERWRITE to override the `input_quantity` of an INSTANCE
#[derive(Clone)]
pub struct InputQuantity {
    pub name: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for InputQuantity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("InputQuantity")
            .field("name", &self.name)
            .finish()
    }
}

impl InputQuantity {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String) -> Self {
        Self {
            name,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for InputQuantity {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name
    }
}

impl A2lObject<(u32, ())> for InputQuantity {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for InputQuantity {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for InputQuantity {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __dummy),
            },
            name,
        })
    }
}

impl InputQuantity {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Creates an instance of a type defined using `TYPEDEF_STRUCTURE`, `TYPEDEF_MEASUREMENT` or `TYPEDEF_CHARACTERISTIC`
#[derive(Clone)]
pub struct Instance {
    pub name: String,
    pub long_identifier: String,
    pub type_ref: String,
    pub start_address: u32,
    pub address_type: Option<AddressType>,
    pub annotation: Vec<Annotation>,
    pub calibration_access: Option<CalibrationAccess>,
    pub display_identifier: Option<DisplayIdentifier>,
    pub ecu_address_extension: Option<EcuAddressExtension>,
    pub if_data: Vec<IfData>,
    pub layout: Option<Layout>,
    pub matrix_dim: Option<MatrixDim>,
    pub max_refresh: Option<MaxRefresh>,
    pub model_link: Option<ModelLink>,
    pub overwrite: Vec<Overwrite>,
    pub read_only: Option<ReadOnly>,
    pub symbol_link: Option<SymbolLink>,
    pub(crate) __block_info: BlockInfo<(u32, u32, u32, (u32, bool))>,
}

impl std::fmt::Debug for Instance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Instance")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("type_ref", &self.type_ref)
            .field("start_address", &self.start_address)
            .field("address_type", &self.address_type)
            .field("annotation", &self.annotation)
            .field("calibration_access", &self.calibration_access)
            .field("display_identifier", &self.display_identifier)
            .field("ecu_address_extension", &self.ecu_address_extension)
            .field("if_data", &self.if_data)
            .field("layout", &self.layout)
            .field("matrix_dim", &self.matrix_dim)
            .field("max_refresh", &self.max_refresh)
            .field("model_link", &self.model_link)
            .field("overwrite", &self.overwrite)
            .field("read_only", &self.read_only)
            .field("symbol_link", &self.symbol_link)
            .finish()
    }
}

impl Instance {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        name: String,
        long_identifier: String,
        type_ref: String,
        start_address: u32,
    ) -> Self {
        Self {
            name,
            long_identifier,
            type_ref,
            start_address,
            address_type: None,
            annotation: Vec::new(),
            calibration_access: None,
            display_identifier: None,
            ecu_address_extension: None,
            if_data: Vec::new(),
            layout: None,
            matrix_dim: None,
            max_refresh: None,
            model_link: None,
            overwrite: Vec::new(),
            read_only: None,
            symbol_link: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32, 1u32, (0u32, false)),
            },
        }
    }
}

impl PartialEq for Instance {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.type_ref == other.type_ref)
            && (self.start_address == other.start_address)
            && (self.address_type == other.address_type)
            && (self.annotation == other.annotation)
            && (self.calibration_access == other.calibration_access)
            && (self.display_identifier == other.display_identifier)
            && (self.ecu_address_extension == other.ecu_address_extension)
            && (self.if_data == other.if_data)
            && (self.layout == other.layout)
            && (self.matrix_dim == other.matrix_dim)
            && (self.max_refresh == other.max_refresh)
            && (self.model_link == other.model_link)
            && (self.overwrite == other.overwrite)
            && (self.read_only == other.read_only)
            && (self.symbol_link == other.symbol_link)
    }
}

impl A2lObject<(u32, u32, u32, (u32, bool))> for Instance {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, u32, (u32, bool))> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, u32, (u32, bool))> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(address_type) = &mut self.address_type {
            address_type.merge_includes();
        }
        for annotation in &mut self.annotation {
            annotation.merge_includes();
        }
        if let Some(calibration_access) = &mut self.calibration_access {
            calibration_access.merge_includes();
        }
        if let Some(display_identifier) = &mut self.display_identifier {
            display_identifier.merge_includes();
        }
        if let Some(ecu_address_extension) = &mut self.ecu_address_extension {
            ecu_address_extension.merge_includes();
        }
        for if_data in &mut self.if_data {
            if_data.merge_includes();
        }
        if let Some(layout) = &mut self.layout {
            layout.merge_includes();
        }
        if let Some(matrix_dim) = &mut self.matrix_dim {
            matrix_dim.merge_includes();
        }
        if let Some(max_refresh) = &mut self.max_refresh {
            max_refresh.merge_includes();
        }
        if let Some(model_link) = &mut self.model_link {
            model_link.merge_includes();
        }
        for overwrite in &mut self.overwrite {
            overwrite.merge_includes();
        }
        if let Some(read_only) = &mut self.read_only {
            read_only.merge_includes();
        }
        if let Some(symbol_link) = &mut self.symbol_link {
            symbol_link.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for Instance {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for Instance {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__type_ref_location, type_ref) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__start_address_location, start_address) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let mut address_type: Option<AddressType> = None;
        let mut annotation: Vec<Annotation> = Vec::new();
        let mut calibration_access: Option<CalibrationAccess> = None;
        let mut display_identifier: Option<DisplayIdentifier> = None;
        let mut ecu_address_extension: Option<EcuAddressExtension> = None;
        let mut if_data: Vec<IfData> = Vec::new();
        let mut layout: Option<Layout> = None;
        let mut matrix_dim: Option<MatrixDim> = None;
        let mut max_refresh: Option<MaxRefresh> = None;
        let mut model_link: Option<ModelLink> = None;
        let mut overwrite: Vec<Overwrite> = Vec::new();
        let mut read_only: Option<ReadOnly> = None;
        let mut symbol_link: Option<SymbolLink> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 13usize] = [
                "ADDRESS_TYPE",
                "ANNOTATION",
                "CALIBRATION_ACCESS",
                "DISPLAY_IDENTIFIER",
                "ECU_ADDRESS_EXTENSION",
                "IF_DATA",
                "LAYOUT",
                "MATRIX_DIM",
                "MAX_REFRESH",
                "MODEL_LINK",
                "OVERWRITE",
                "READ_ONLY",
                "SYMBOL_LINK",
            ];
            match tag {
                "ADDRESS_TYPE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "ADDRESS_TYPE",
                        A2lVersion::V1_7_1,
                    )?;
                    let newitem = AddressType::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, address_type.is_some())?;
                    address_type = Some(newitem);
                }
                "ANNOTATION" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Annotation::parse(parser, &newcontext, line_offset)?;
                    annotation.push(newitem);
                }
                "CALIBRATION_ACCESS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = CalibrationAccess::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, calibration_access.is_some())?;
                    calibration_access = Some(newitem);
                }
                "DISPLAY_IDENTIFIER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = DisplayIdentifier::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, display_identifier.is_some())?;
                    display_identifier = Some(newitem);
                }
                "ECU_ADDRESS_EXTENSION" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = EcuAddressExtension::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        ecu_address_extension.is_some(),
                    )?;
                    ecu_address_extension = Some(newitem);
                }
                "IF_DATA" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = IfData::parse(parser, &newcontext, line_offset)?;
                    if_data.push(newitem);
                }
                "LAYOUT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Layout::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, layout.is_some())?;
                    layout = Some(newitem);
                }
                "MATRIX_DIM" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = MatrixDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, matrix_dim.is_some())?;
                    matrix_dim = Some(newitem);
                }
                "MAX_REFRESH" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = MaxRefresh::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, max_refresh.is_some())?;
                    max_refresh = Some(newitem);
                }
                "MODEL_LINK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ModelLink::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, model_link.is_some())?;
                    model_link = Some(newitem);
                }
                "OVERWRITE" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Overwrite::parse(parser, &newcontext, line_offset)?;
                    overwrite.push(newitem);
                }
                "READ_ONLY" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ReadOnly::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, read_only.is_some())?;
                    read_only = Some(newitem);
                }
                "SYMBOL_LINK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = SymbolLink::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, symbol_link.is_some())?;
                    symbol_link = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __type_ref_location,
                    __start_address_location,
                ),
            },
            name,
            long_identifier,
            type_ref,
            start_address,
            address_type,
            annotation,
            calibration_access,
            display_identifier,
            ecu_address_extension,
            if_data,
            layout,
            matrix_dim,
            max_refresh,
            model_link,
            overwrite,
            read_only,
            symbol_link,
        })
    }
}

impl Instance {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_str(&self.type_ref, self.__block_info.item_location.2);
        writer.add_integer(
            self.start_address,
            self.__block_info.item_location.3 .1,
            self.__block_info.item_location.3 .0,
        );
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(address_type) = &self.address_type {
            let address_type_out = address_type.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ADDRESS_TYPE",
                item_text: address_type_out,
                is_block: false,
                incfile: &address_type.__block_info.incfile,
                uid: address_type.__block_info.uid,
                line: address_type.__block_info.line,
                start_offset: address_type.__block_info.start_offset,
                end_offset: address_type.__block_info.end_offset,
                position_restriction: address_type.pos_restrict(),
            });
        }
        for annotation in &self.annotation {
            let annotation_out = annotation.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ANNOTATION",
                item_text: annotation_out,
                is_block: true,
                incfile: &annotation.__block_info.incfile,
                uid: annotation.__block_info.uid,
                line: annotation.__block_info.line,
                start_offset: annotation.__block_info.start_offset,
                end_offset: annotation.__block_info.end_offset,
                position_restriction: annotation.pos_restrict(),
            });
        }
        if let Some(calibration_access) = &self.calibration_access {
            let calibration_access_out = calibration_access.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "CALIBRATION_ACCESS",
                item_text: calibration_access_out,
                is_block: false,
                incfile: &calibration_access.__block_info.incfile,
                uid: calibration_access.__block_info.uid,
                line: calibration_access.__block_info.line,
                start_offset: calibration_access.__block_info.start_offset,
                end_offset: calibration_access.__block_info.end_offset,
                position_restriction: calibration_access.pos_restrict(),
            });
        }
        if let Some(display_identifier) = &self.display_identifier {
            let display_identifier_out = display_identifier.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DISPLAY_IDENTIFIER",
                item_text: display_identifier_out,
                is_block: false,
                incfile: &display_identifier.__block_info.incfile,
                uid: display_identifier.__block_info.uid,
                line: display_identifier.__block_info.line,
                start_offset: display_identifier.__block_info.start_offset,
                end_offset: display_identifier.__block_info.end_offset,
                position_restriction: display_identifier.pos_restrict(),
            });
        }
        if let Some(ecu_address_extension) = &self.ecu_address_extension {
            let ecu_address_extension_out = ecu_address_extension.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ECU_ADDRESS_EXTENSION",
                item_text: ecu_address_extension_out,
                is_block: false,
                incfile: &ecu_address_extension.__block_info.incfile,
                uid: ecu_address_extension.__block_info.uid,
                line: ecu_address_extension.__block_info.line,
                start_offset: ecu_address_extension.__block_info.start_offset,
                end_offset: ecu_address_extension.__block_info.end_offset,
                position_restriction: ecu_address_extension.pos_restrict(),
            });
        }
        for if_data in &self.if_data {
            let if_data_out = if_data.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "IF_DATA",
                item_text: if_data_out,
                is_block: true,
                incfile: &if_data.__block_info.incfile,
                uid: if_data.__block_info.uid,
                line: if_data.__block_info.line,
                start_offset: if_data.__block_info.start_offset,
                end_offset: if_data.__block_info.end_offset,
                position_restriction: if_data.pos_restrict(),
            });
        }
        if let Some(layout) = &self.layout {
            let layout_out = layout.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "LAYOUT",
                item_text: layout_out,
                is_block: false,
                incfile: &layout.__block_info.incfile,
                uid: layout.__block_info.uid,
                line: layout.__block_info.line,
                start_offset: layout.__block_info.start_offset,
                end_offset: layout.__block_info.end_offset,
                position_restriction: layout.pos_restrict(),
            });
        }
        if let Some(matrix_dim) = &self.matrix_dim {
            let matrix_dim_out = matrix_dim.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MATRIX_DIM",
                item_text: matrix_dim_out,
                is_block: false,
                incfile: &matrix_dim.__block_info.incfile,
                uid: matrix_dim.__block_info.uid,
                line: matrix_dim.__block_info.line,
                start_offset: matrix_dim.__block_info.start_offset,
                end_offset: matrix_dim.__block_info.end_offset,
                position_restriction: matrix_dim.pos_restrict(),
            });
        }
        if let Some(max_refresh) = &self.max_refresh {
            let max_refresh_out = max_refresh.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MAX_REFRESH",
                item_text: max_refresh_out,
                is_block: false,
                incfile: &max_refresh.__block_info.incfile,
                uid: max_refresh.__block_info.uid,
                line: max_refresh.__block_info.line,
                start_offset: max_refresh.__block_info.start_offset,
                end_offset: max_refresh.__block_info.end_offset,
                position_restriction: max_refresh.pos_restrict(),
            });
        }
        if let Some(model_link) = &self.model_link {
            let model_link_out = model_link.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MODEL_LINK",
                item_text: model_link_out,
                is_block: false,
                incfile: &model_link.__block_info.incfile,
                uid: model_link.__block_info.uid,
                line: model_link.__block_info.line,
                start_offset: model_link.__block_info.start_offset,
                end_offset: model_link.__block_info.end_offset,
                position_restriction: model_link.pos_restrict(),
            });
        }
        for overwrite in &self.overwrite {
            let overwrite_out = overwrite.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "OVERWRITE",
                item_text: overwrite_out,
                is_block: true,
                incfile: &overwrite.__block_info.incfile,
                uid: overwrite.__block_info.uid,
                line: overwrite.__block_info.line,
                start_offset: overwrite.__block_info.start_offset,
                end_offset: overwrite.__block_info.end_offset,
                position_restriction: overwrite.pos_restrict(),
            });
        }
        if let Some(read_only) = &self.read_only {
            let read_only_out = read_only.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "READ_ONLY",
                item_text: read_only_out,
                is_block: false,
                incfile: &read_only.__block_info.incfile,
                uid: read_only.__block_info.uid,
                line: read_only.__block_info.line,
                start_offset: read_only.__block_info.start_offset,
                end_offset: read_only.__block_info.end_offset,
                position_restriction: read_only.pos_restrict(),
            });
        }
        if let Some(symbol_link) = &self.symbol_link {
            let symbol_link_out = symbol_link.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SYMBOL_LINK",
                item_text: symbol_link_out,
                is_block: false,
                incfile: &symbol_link.__block_info.incfile,
                uid: symbol_link.__block_info.uid,
                line: symbol_link.__block_info.line,
                start_offset: symbol_link.__block_info.start_offset,
                end_offset: symbol_link.__block_info.end_offset,
                position_restriction: symbol_link.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// describes the layout of a multi-dimensional measurement array
#[derive(Clone)]
pub struct Layout {
    pub index_mode: IndexMode,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for Layout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Layout")
            .field("index_mode", &self.index_mode)
            .finish()
    }
}

impl Layout {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(index_mode: IndexMode) -> Self {
        Self {
            index_mode,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for Layout {
    fn eq(&self, other: &Self) -> bool {
        self.index_mode == other.index_mode
    }
}

impl A2lObject<(u32, ())> for Layout {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Layout {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__index_mode_location, index_mode) = (
            parser.get_current_line_offset(),
            IndexMode::parse(parser, context, 0)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__index_mode_location, __dummy),
            },
            index_mode,
        })
    }
}

impl Layout {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(
            &self.index_mode.to_string(),
            self.__block_info.item_location.0,
        );
        writer.finish()
    }
}

/// Used within `BIT_OPERATION` to left-shift the bits of a value
#[derive(Clone)]
pub struct LeftShift {
    pub bitcount: u32,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for LeftShift {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("LeftShift")
            .field("bitcount", &self.bitcount)
            .finish()
    }
}

impl LeftShift {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(bitcount: u32) -> Self {
        Self {
            bitcount,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for LeftShift {
    fn eq(&self, other: &Self) -> bool {
        self.bitcount == other.bitcount
    }
}

impl A2lObject<((u32, bool), ())> for LeftShift {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for LeftShift {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__bitcount_location, bitcount) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__bitcount_location, __dummy),
            },
            bitcount,
        })
    }
}

impl LeftShift {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.bitcount,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// LIMITS is used inside OVERWRITE to override the limits of an INSTANCE
#[derive(Clone)]
pub struct Limits {
    pub lower_limit: f64,
    pub upper_limit: f64,
    pub(crate) __block_info: BlockInfo<(u32, u32)>,
}

impl std::fmt::Debug for Limits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Limits")
            .field("lower_limit", &self.lower_limit)
            .field("upper_limit", &self.upper_limit)
            .finish()
    }
}

impl Limits {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(lower_limit: f64, upper_limit: f64) -> Self {
        Self {
            lower_limit,
            upper_limit,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, 0u32),
            },
        }
    }
}

impl PartialEq for Limits {
    fn eq(&self, other: &Self) -> bool {
        (self.lower_limit == other.lower_limit) && (self.upper_limit == other.upper_limit)
    }
}

impl A2lObject<(u32, u32)> for Limits {
    fn get_layout(&self) -> &BlockInfo<(u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Limits {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__lower_limit_location, lower_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__upper_limit_location, upper_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__lower_limit_location, __upper_limit_location),
            },
            lower_limit,
            upper_limit,
        })
    }
}

impl Limits {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_float(self.lower_limit, self.__block_info.item_location.0);
        writer.add_float(self.upper_limit, self.__block_info.item_location.1);
        writer.finish()
    }
}

/// A list of measurement objects that are local variables of a function
#[derive(Clone)]
pub struct LocMeasurement {
    pub identifier_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for LocMeasurement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("LocMeasurement")
            .field("identifier_list", &self.identifier_list)
            .finish()
    }
}

impl LocMeasurement {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            identifier_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for LocMeasurement {
    fn eq(&self, other: &Self) -> bool {
        self.identifier_list == other.identifier_list
    }
}

impl A2lObject<(Vec<u32>, ())> for LocMeasurement {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for LocMeasurement {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut identifier_list = Vec::new();
        let mut __identifier_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    identifier_list.push(value);
                    __identifier_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__identifier_list_location, __dummy),
            },
            identifier_list,
        })
    }
}

impl LocMeasurement {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.identifier_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// used to specify the list of MAPs which comprise a CUBOID
#[derive(Clone)]
pub struct MapList {
    pub name_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for MapList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("MapList")
            .field("name_list", &self.name_list)
            .finish()
    }
}

impl MapList {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            name_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for MapList {
    fn eq(&self, other: &Self) -> bool {
        self.name_list == other.name_list
    }
}

impl A2lObject<(Vec<u32>, ())> for MapList {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for MapList {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut name_list = Vec::new();
        let mut __name_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    name_list.push(value);
                    __name_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_list_location, __dummy),
            },
            name_list,
        })
    }
}

impl MapList {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.name_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// describes the dimensions of a multidimensional array of values
#[derive(Clone)]
pub struct MatrixDim {
    pub dim_list: Vec<u16>,
    pub(crate) __block_info: BlockInfo<(Vec<(u32, bool)>, ())>,
}

impl std::fmt::Debug for MatrixDim {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("MatrixDim")
            .field("dim_list", &self.dim_list)
            .finish()
    }
}

impl MatrixDim {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            dim_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (Vec::<(u32, bool)>::new(), ()),
            },
        }
    }
}

impl PartialEq for MatrixDim {
    fn eq(&self, other: &Self) -> bool {
        self.dim_list == other.dim_list
    }
}

impl A2lObject<(Vec<(u32, bool)>, ())> for MatrixDim {
    fn get_layout(&self) -> &BlockInfo<(Vec<(u32, bool)>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<(u32, bool)>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for MatrixDim {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut dim_list = Vec::new();
        let mut __dim_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok({
                        let line = parser.get_current_line_offset();
                        let (value, is_hex) = parser.get_integer::<u16>(context)?;
                        ((line, is_hex), value)
                    })
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    dim_list.push(value);
                    __dim_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__dim_list_location, __dummy),
            },
            dim_list,
        })
    }
}

impl MatrixDim {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.dim_list.iter().enumerate() {
            writer.add_integer(
                *seqitem0,
                self.__block_info
                    .item_location
                    .0
                    .get(seqidx0)
                    .unwrap_or(&(0, false))
                    .1,
                self.__block_info
                    .item_location
                    .0
                    .get(seqidx0)
                    .unwrap_or(&(0, false))
                    .0,
            );
        }
        writer.finish()
    }
}

/// specifies a maximum permissible gradient for an adjustable object
#[derive(Clone)]
pub struct MaxGrad {
    pub max_gradient: f64,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for MaxGrad {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("MaxGrad")
            .field("max_gradient", &self.max_gradient)
            .finish()
    }
}

impl MaxGrad {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(max_gradient: f64) -> Self {
        Self {
            max_gradient,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for MaxGrad {
    fn eq(&self, other: &Self) -> bool {
        self.max_gradient == other.max_gradient
    }
}

impl A2lObject<(u32, ())> for MaxGrad {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for MaxGrad {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__max_gradient_location, max_gradient) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__max_gradient_location, __dummy),
            },
            max_gradient,
        })
    }
}

impl MaxGrad {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_float(self.max_gradient, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// specifies the maximum refresh rate in the control unit
#[derive(Clone)]
pub struct MaxRefresh {
    pub scaling_unit: u16,
    pub rate: u32,
    pub(crate) __block_info: BlockInfo<((u32, bool), (u32, bool))>,
}

impl std::fmt::Debug for MaxRefresh {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("MaxRefresh")
            .field("scaling_unit", &self.scaling_unit)
            .field("rate", &self.rate)
            .finish()
    }
}

impl MaxRefresh {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(scaling_unit: u16, rate: u32) -> Self {
        Self {
            scaling_unit,
            rate,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), (0u32, false)),
            },
        }
    }
}

impl PartialEq for MaxRefresh {
    fn eq(&self, other: &Self) -> bool {
        (self.scaling_unit == other.scaling_unit) && (self.rate == other.rate)
    }
}

impl A2lObject<((u32, bool), (u32, bool))> for MaxRefresh {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), (u32, bool))> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), (u32, bool))> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for MaxRefresh {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__scaling_unit_location, scaling_unit) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__rate_location, rate) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__scaling_unit_location, __rate_location),
            },
            scaling_unit,
            rate,
        })
    }
}

impl MaxRefresh {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.scaling_unit,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_integer(
            self.rate,
            self.__block_info.item_location.1 .1,
            self.__block_info.item_location.1 .0,
        );
        writer.finish()
    }
}

/// describes the parameters for a measurement object
#[derive(Clone)]
pub struct Measurement {
    pub name: String,
    pub long_identifier: String,
    pub datatype: DataType,
    pub conversion: String,
    pub resolution: u16,
    pub accuracy: f64,
    pub lower_limit: f64,
    pub upper_limit: f64,
    pub address_type: Option<AddressType>,
    pub annotation: Vec<Annotation>,
    pub array_size: Option<ArraySize>,
    pub bit_mask: Option<BitMask>,
    pub bit_operation: Option<BitOperation>,
    pub byte_order: Option<ByteOrder>,
    pub discrete: Option<Discrete>,
    pub display_identifier: Option<DisplayIdentifier>,
    pub ecu_address: Option<EcuAddress>,
    pub ecu_address_extension: Option<EcuAddressExtension>,
    pub error_mask: Option<ErrorMask>,
    pub format: Option<Format>,
    pub function_list: Option<FunctionList>,
    pub if_data: Vec<IfData>,
    pub layout: Option<Layout>,
    pub matrix_dim: Option<MatrixDim>,
    pub max_refresh: Option<MaxRefresh>,
    pub model_link: Option<ModelLink>,
    pub phys_unit: Option<PhysUnit>,
    pub read_write: Option<ReadWrite>,
    pub ref_memory_segment: Option<RefMemorySegment>,
    pub symbol_link: Option<SymbolLink>,
    pub var_virtual: Option<Virtual>,
    pub(crate) __block_info: BlockInfo<(u32, u32, u32, u32, (u32, bool), u32, u32, u32)>,
}

impl std::fmt::Debug for Measurement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Measurement")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("datatype", &self.datatype)
            .field("conversion", &self.conversion)
            .field("resolution", &self.resolution)
            .field("accuracy", &self.accuracy)
            .field("lower_limit", &self.lower_limit)
            .field("upper_limit", &self.upper_limit)
            .field("address_type", &self.address_type)
            .field("annotation", &self.annotation)
            .field("array_size", &self.array_size)
            .field("bit_mask", &self.bit_mask)
            .field("bit_operation", &self.bit_operation)
            .field("byte_order", &self.byte_order)
            .field("discrete", &self.discrete)
            .field("display_identifier", &self.display_identifier)
            .field("ecu_address", &self.ecu_address)
            .field("ecu_address_extension", &self.ecu_address_extension)
            .field("error_mask", &self.error_mask)
            .field("format", &self.format)
            .field("function_list", &self.function_list)
            .field("if_data", &self.if_data)
            .field("layout", &self.layout)
            .field("matrix_dim", &self.matrix_dim)
            .field("max_refresh", &self.max_refresh)
            .field("model_link", &self.model_link)
            .field("phys_unit", &self.phys_unit)
            .field("read_write", &self.read_write)
            .field("ref_memory_segment", &self.ref_memory_segment)
            .field("symbol_link", &self.symbol_link)
            .field("var_virtual", &self.var_virtual)
            .finish()
    }
}

impl Measurement {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        name: String,
        long_identifier: String,
        datatype: DataType,
        conversion: String,
        resolution: u16,
        accuracy: f64,
        lower_limit: f64,
        upper_limit: f64,
    ) -> Self {
        Self {
            name,
            long_identifier,
            datatype,
            conversion,
            resolution,
            accuracy,
            lower_limit,
            upper_limit,
            address_type: None,
            annotation: Vec::new(),
            array_size: None,
            bit_mask: None,
            bit_operation: None,
            byte_order: None,
            discrete: None,
            display_identifier: None,
            ecu_address: None,
            ecu_address_extension: None,
            error_mask: None,
            format: None,
            function_list: None,
            if_data: Vec::new(),
            layout: None,
            matrix_dim: None,
            max_refresh: None,
            model_link: None,
            phys_unit: None,
            read_write: None,
            ref_memory_segment: None,
            symbol_link: None,
            var_virtual: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32, 1u32, 0u32, (0u32, false), 0u32, 0u32, 0u32),
            },
        }
    }
}

impl PartialEq for Measurement {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.datatype == other.datatype)
            && (self.conversion == other.conversion)
            && (self.resolution == other.resolution)
            && (self.accuracy == other.accuracy)
            && (self.lower_limit == other.lower_limit)
            && (self.upper_limit == other.upper_limit)
            && (self.address_type == other.address_type)
            && (self.annotation == other.annotation)
            && (self.array_size == other.array_size)
            && (self.bit_mask == other.bit_mask)
            && (self.bit_operation == other.bit_operation)
            && (self.byte_order == other.byte_order)
            && (self.discrete == other.discrete)
            && (self.display_identifier == other.display_identifier)
            && (self.ecu_address == other.ecu_address)
            && (self.ecu_address_extension == other.ecu_address_extension)
            && (self.error_mask == other.error_mask)
            && (self.format == other.format)
            && (self.function_list == other.function_list)
            && (self.if_data == other.if_data)
            && (self.layout == other.layout)
            && (self.matrix_dim == other.matrix_dim)
            && (self.max_refresh == other.max_refresh)
            && (self.model_link == other.model_link)
            && (self.phys_unit == other.phys_unit)
            && (self.read_write == other.read_write)
            && (self.ref_memory_segment == other.ref_memory_segment)
            && (self.symbol_link == other.symbol_link)
            && (self.var_virtual == other.var_virtual)
    }
}

impl A2lObject<(u32, u32, u32, u32, (u32, bool), u32, u32, u32)> for Measurement {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, u32, u32, (u32, bool), u32, u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(
        &mut self,
    ) -> &mut BlockInfo<(u32, u32, u32, u32, (u32, bool), u32, u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(address_type) = &mut self.address_type {
            address_type.merge_includes();
        }
        for annotation in &mut self.annotation {
            annotation.merge_includes();
        }
        if let Some(array_size) = &mut self.array_size {
            array_size.merge_includes();
        }
        if let Some(bit_mask) = &mut self.bit_mask {
            bit_mask.merge_includes();
        }
        if let Some(bit_operation) = &mut self.bit_operation {
            bit_operation.merge_includes();
        }
        if let Some(byte_order) = &mut self.byte_order {
            byte_order.merge_includes();
        }
        if let Some(discrete) = &mut self.discrete {
            discrete.merge_includes();
        }
        if let Some(display_identifier) = &mut self.display_identifier {
            display_identifier.merge_includes();
        }
        if let Some(ecu_address) = &mut self.ecu_address {
            ecu_address.merge_includes();
        }
        if let Some(ecu_address_extension) = &mut self.ecu_address_extension {
            ecu_address_extension.merge_includes();
        }
        if let Some(error_mask) = &mut self.error_mask {
            error_mask.merge_includes();
        }
        if let Some(format) = &mut self.format {
            format.merge_includes();
        }
        if let Some(function_list) = &mut self.function_list {
            function_list.merge_includes();
        }
        for if_data in &mut self.if_data {
            if_data.merge_includes();
        }
        if let Some(layout) = &mut self.layout {
            layout.merge_includes();
        }
        if let Some(matrix_dim) = &mut self.matrix_dim {
            matrix_dim.merge_includes();
        }
        if let Some(max_refresh) = &mut self.max_refresh {
            max_refresh.merge_includes();
        }
        if let Some(model_link) = &mut self.model_link {
            model_link.merge_includes();
        }
        if let Some(phys_unit) = &mut self.phys_unit {
            phys_unit.merge_includes();
        }
        if let Some(read_write) = &mut self.read_write {
            read_write.merge_includes();
        }
        if let Some(ref_memory_segment) = &mut self.ref_memory_segment {
            ref_memory_segment.merge_includes();
        }
        if let Some(symbol_link) = &mut self.symbol_link {
            symbol_link.merge_includes();
        }
        if let Some(var_virtual) = &mut self.var_virtual {
            var_virtual.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for Measurement {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for Measurement {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__datatype_location, datatype) = (
            parser.get_current_line_offset(),
            DataType::parse(parser, context, 0)?,
        );
        let (__conversion_location, conversion) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__resolution_location, resolution) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__accuracy_location, accuracy) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__lower_limit_location, lower_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__upper_limit_location, upper_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let mut address_type: Option<AddressType> = None;
        let mut annotation: Vec<Annotation> = Vec::new();
        let mut array_size: Option<ArraySize> = None;
        let mut bit_mask: Option<BitMask> = None;
        let mut bit_operation: Option<BitOperation> = None;
        let mut byte_order: Option<ByteOrder> = None;
        let mut discrete: Option<Discrete> = None;
        let mut display_identifier: Option<DisplayIdentifier> = None;
        let mut ecu_address: Option<EcuAddress> = None;
        let mut ecu_address_extension: Option<EcuAddressExtension> = None;
        let mut error_mask: Option<ErrorMask> = None;
        let mut format: Option<Format> = None;
        let mut function_list: Option<FunctionList> = None;
        let mut if_data: Vec<IfData> = Vec::new();
        let mut layout: Option<Layout> = None;
        let mut matrix_dim: Option<MatrixDim> = None;
        let mut max_refresh: Option<MaxRefresh> = None;
        let mut model_link: Option<ModelLink> = None;
        let mut phys_unit: Option<PhysUnit> = None;
        let mut read_write: Option<ReadWrite> = None;
        let mut ref_memory_segment: Option<RefMemorySegment> = None;
        let mut symbol_link: Option<SymbolLink> = None;
        let mut var_virtual: Option<Virtual> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 23usize] = [
                "ADDRESS_TYPE",
                "ANNOTATION",
                "ARRAY_SIZE",
                "BIT_MASK",
                "BIT_OPERATION",
                "BYTE_ORDER",
                "DISCRETE",
                "DISPLAY_IDENTIFIER",
                "ECU_ADDRESS",
                "ECU_ADDRESS_EXTENSION",
                "ERROR_MASK",
                "FORMAT",
                "FUNCTION_LIST",
                "IF_DATA",
                "LAYOUT",
                "MATRIX_DIM",
                "MAX_REFRESH",
                "MODEL_LINK",
                "PHYS_UNIT",
                "READ_WRITE",
                "REF_MEMORY_SEGMENT",
                "SYMBOL_LINK",
                "VIRTUAL",
            ];
            match tag {
                "ADDRESS_TYPE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "ADDRESS_TYPE",
                        A2lVersion::V1_7_0,
                    )?;
                    let newitem = AddressType::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, address_type.is_some())?;
                    address_type = Some(newitem);
                }
                "ANNOTATION" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Annotation::parse(parser, &newcontext, line_offset)?;
                    annotation.push(newitem);
                }
                "ARRAY_SIZE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_upper(context, "ARRAY_SIZE", A2lVersion::V1_5_1);
                    let newitem = ArraySize::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, array_size.is_some())?;
                    array_size = Some(newitem);
                }
                "BIT_MASK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = BitMask::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, bit_mask.is_some())?;
                    bit_mask = Some(newitem);
                }
                "BIT_OPERATION" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = BitOperation::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, bit_operation.is_some())?;
                    bit_operation = Some(newitem);
                }
                "BYTE_ORDER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ByteOrder::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, byte_order.is_some())?;
                    byte_order = Some(newitem);
                }
                "DISCRETE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "DISCRETE", A2lVersion::V1_6_0)?;
                    let newitem = Discrete::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, discrete.is_some())?;
                    discrete = Some(newitem);
                }
                "DISPLAY_IDENTIFIER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = DisplayIdentifier::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, display_identifier.is_some())?;
                    display_identifier = Some(newitem);
                }
                "ECU_ADDRESS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = EcuAddress::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, ecu_address.is_some())?;
                    ecu_address = Some(newitem);
                }
                "ECU_ADDRESS_EXTENSION" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = EcuAddressExtension::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        ecu_address_extension.is_some(),
                    )?;
                    ecu_address_extension = Some(newitem);
                }
                "ERROR_MASK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ErrorMask::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, error_mask.is_some())?;
                    error_mask = Some(newitem);
                }
                "FORMAT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Format::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, format.is_some())?;
                    format = Some(newitem);
                }
                "FUNCTION_LIST" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = FunctionList::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, function_list.is_some())?;
                    function_list = Some(newitem);
                }
                "IF_DATA" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = IfData::parse(parser, &newcontext, line_offset)?;
                    if_data.push(newitem);
                }
                "LAYOUT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "LAYOUT", A2lVersion::V1_6_0)?;
                    let newitem = Layout::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, layout.is_some())?;
                    layout = Some(newitem);
                }
                "MATRIX_DIM" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = MatrixDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, matrix_dim.is_some())?;
                    matrix_dim = Some(newitem);
                }
                "MAX_REFRESH" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = MaxRefresh::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, max_refresh.is_some())?;
                    max_refresh = Some(newitem);
                }
                "MODEL_LINK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "MODEL_LINK", A2lVersion::V1_7_0)?;
                    let newitem = ModelLink::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, model_link.is_some())?;
                    model_link = Some(newitem);
                }
                "PHYS_UNIT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "PHYS_UNIT", A2lVersion::V1_6_0)?;
                    let newitem = PhysUnit::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, phys_unit.is_some())?;
                    phys_unit = Some(newitem);
                }
                "READ_WRITE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ReadWrite::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, read_write.is_some())?;
                    read_write = Some(newitem);
                }
                "REF_MEMORY_SEGMENT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = RefMemorySegment::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, ref_memory_segment.is_some())?;
                    ref_memory_segment = Some(newitem);
                }
                "SYMBOL_LINK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "SYMBOL_LINK", A2lVersion::V1_6_0)?;
                    let newitem = SymbolLink::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, symbol_link.is_some())?;
                    symbol_link = Some(newitem);
                }
                "VIRTUAL" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Virtual::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, var_virtual.is_some())?;
                    var_virtual = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __datatype_location,
                    __conversion_location,
                    __resolution_location,
                    __accuracy_location,
                    __lower_limit_location,
                    __upper_limit_location,
                ),
            },
            name,
            long_identifier,
            datatype,
            conversion,
            resolution,
            accuracy,
            lower_limit,
            upper_limit,
            address_type,
            annotation,
            array_size,
            bit_mask,
            bit_operation,
            byte_order,
            discrete,
            display_identifier,
            ecu_address,
            ecu_address_extension,
            error_mask,
            format,
            function_list,
            if_data,
            layout,
            matrix_dim,
            max_refresh,
            model_link,
            phys_unit,
            read_write,
            ref_memory_segment,
            symbol_link,
            var_virtual,
        })
    }
}

impl Measurement {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_str(
            &self.datatype.to_string(),
            self.__block_info.item_location.2,
        );
        writer.add_str(&self.conversion, self.__block_info.item_location.3);
        writer.add_integer(
            self.resolution,
            self.__block_info.item_location.4 .1,
            self.__block_info.item_location.4 .0,
        );
        writer.add_float(self.accuracy, self.__block_info.item_location.5);
        writer.add_float(self.lower_limit, self.__block_info.item_location.6);
        writer.add_float(self.upper_limit, self.__block_info.item_location.7);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(address_type) = &self.address_type {
            let address_type_out = address_type.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ADDRESS_TYPE",
                item_text: address_type_out,
                is_block: false,
                incfile: &address_type.__block_info.incfile,
                uid: address_type.__block_info.uid,
                line: address_type.__block_info.line,
                start_offset: address_type.__block_info.start_offset,
                end_offset: address_type.__block_info.end_offset,
                position_restriction: address_type.pos_restrict(),
            });
        }
        for annotation in &self.annotation {
            let annotation_out = annotation.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ANNOTATION",
                item_text: annotation_out,
                is_block: true,
                incfile: &annotation.__block_info.incfile,
                uid: annotation.__block_info.uid,
                line: annotation.__block_info.line,
                start_offset: annotation.__block_info.start_offset,
                end_offset: annotation.__block_info.end_offset,
                position_restriction: annotation.pos_restrict(),
            });
        }
        if let Some(array_size) = &self.array_size {
            let array_size_out = array_size.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ARRAY_SIZE",
                item_text: array_size_out,
                is_block: false,
                incfile: &array_size.__block_info.incfile,
                uid: array_size.__block_info.uid,
                line: array_size.__block_info.line,
                start_offset: array_size.__block_info.start_offset,
                end_offset: array_size.__block_info.end_offset,
                position_restriction: array_size.pos_restrict(),
            });
        }
        if let Some(bit_mask) = &self.bit_mask {
            let bit_mask_out = bit_mask.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "BIT_MASK",
                item_text: bit_mask_out,
                is_block: false,
                incfile: &bit_mask.__block_info.incfile,
                uid: bit_mask.__block_info.uid,
                line: bit_mask.__block_info.line,
                start_offset: bit_mask.__block_info.start_offset,
                end_offset: bit_mask.__block_info.end_offset,
                position_restriction: bit_mask.pos_restrict(),
            });
        }
        if let Some(bit_operation) = &self.bit_operation {
            let bit_operation_out = bit_operation.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "BIT_OPERATION",
                item_text: bit_operation_out,
                is_block: true,
                incfile: &bit_operation.__block_info.incfile,
                uid: bit_operation.__block_info.uid,
                line: bit_operation.__block_info.line,
                start_offset: bit_operation.__block_info.start_offset,
                end_offset: bit_operation.__block_info.end_offset,
                position_restriction: bit_operation.pos_restrict(),
            });
        }
        if let Some(byte_order) = &self.byte_order {
            let byte_order_out = byte_order.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "BYTE_ORDER",
                item_text: byte_order_out,
                is_block: false,
                incfile: &byte_order.__block_info.incfile,
                uid: byte_order.__block_info.uid,
                line: byte_order.__block_info.line,
                start_offset: byte_order.__block_info.start_offset,
                end_offset: byte_order.__block_info.end_offset,
                position_restriction: byte_order.pos_restrict(),
            });
        }
        if let Some(discrete) = &self.discrete {
            let discrete_out = discrete.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DISCRETE",
                item_text: discrete_out,
                is_block: false,
                incfile: &discrete.__block_info.incfile,
                uid: discrete.__block_info.uid,
                line: discrete.__block_info.line,
                start_offset: discrete.__block_info.start_offset,
                end_offset: discrete.__block_info.end_offset,
                position_restriction: discrete.pos_restrict(),
            });
        }
        if let Some(display_identifier) = &self.display_identifier {
            let display_identifier_out = display_identifier.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DISPLAY_IDENTIFIER",
                item_text: display_identifier_out,
                is_block: false,
                incfile: &display_identifier.__block_info.incfile,
                uid: display_identifier.__block_info.uid,
                line: display_identifier.__block_info.line,
                start_offset: display_identifier.__block_info.start_offset,
                end_offset: display_identifier.__block_info.end_offset,
                position_restriction: display_identifier.pos_restrict(),
            });
        }
        if let Some(ecu_address) = &self.ecu_address {
            let ecu_address_out = ecu_address.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ECU_ADDRESS",
                item_text: ecu_address_out,
                is_block: false,
                incfile: &ecu_address.__block_info.incfile,
                uid: ecu_address.__block_info.uid,
                line: ecu_address.__block_info.line,
                start_offset: ecu_address.__block_info.start_offset,
                end_offset: ecu_address.__block_info.end_offset,
                position_restriction: ecu_address.pos_restrict(),
            });
        }
        if let Some(ecu_address_extension) = &self.ecu_address_extension {
            let ecu_address_extension_out = ecu_address_extension.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ECU_ADDRESS_EXTENSION",
                item_text: ecu_address_extension_out,
                is_block: false,
                incfile: &ecu_address_extension.__block_info.incfile,
                uid: ecu_address_extension.__block_info.uid,
                line: ecu_address_extension.__block_info.line,
                start_offset: ecu_address_extension.__block_info.start_offset,
                end_offset: ecu_address_extension.__block_info.end_offset,
                position_restriction: ecu_address_extension.pos_restrict(),
            });
        }
        if let Some(error_mask) = &self.error_mask {
            let error_mask_out = error_mask.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ERROR_MASK",
                item_text: error_mask_out,
                is_block: false,
                incfile: &error_mask.__block_info.incfile,
                uid: error_mask.__block_info.uid,
                line: error_mask.__block_info.line,
                start_offset: error_mask.__block_info.start_offset,
                end_offset: error_mask.__block_info.end_offset,
                position_restriction: error_mask.pos_restrict(),
            });
        }
        if let Some(format) = &self.format {
            let format_out = format.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FORMAT",
                item_text: format_out,
                is_block: false,
                incfile: &format.__block_info.incfile,
                uid: format.__block_info.uid,
                line: format.__block_info.line,
                start_offset: format.__block_info.start_offset,
                end_offset: format.__block_info.end_offset,
                position_restriction: format.pos_restrict(),
            });
        }
        if let Some(function_list) = &self.function_list {
            let function_list_out = function_list.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FUNCTION_LIST",
                item_text: function_list_out,
                is_block: true,
                incfile: &function_list.__block_info.incfile,
                uid: function_list.__block_info.uid,
                line: function_list.__block_info.line,
                start_offset: function_list.__block_info.start_offset,
                end_offset: function_list.__block_info.end_offset,
                position_restriction: function_list.pos_restrict(),
            });
        }
        for if_data in &self.if_data {
            let if_data_out = if_data.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "IF_DATA",
                item_text: if_data_out,
                is_block: true,
                incfile: &if_data.__block_info.incfile,
                uid: if_data.__block_info.uid,
                line: if_data.__block_info.line,
                start_offset: if_data.__block_info.start_offset,
                end_offset: if_data.__block_info.end_offset,
                position_restriction: if_data.pos_restrict(),
            });
        }
        if let Some(layout) = &self.layout {
            let layout_out = layout.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "LAYOUT",
                item_text: layout_out,
                is_block: false,
                incfile: &layout.__block_info.incfile,
                uid: layout.__block_info.uid,
                line: layout.__block_info.line,
                start_offset: layout.__block_info.start_offset,
                end_offset: layout.__block_info.end_offset,
                position_restriction: layout.pos_restrict(),
            });
        }
        if let Some(matrix_dim) = &self.matrix_dim {
            let matrix_dim_out = matrix_dim.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MATRIX_DIM",
                item_text: matrix_dim_out,
                is_block: false,
                incfile: &matrix_dim.__block_info.incfile,
                uid: matrix_dim.__block_info.uid,
                line: matrix_dim.__block_info.line,
                start_offset: matrix_dim.__block_info.start_offset,
                end_offset: matrix_dim.__block_info.end_offset,
                position_restriction: matrix_dim.pos_restrict(),
            });
        }
        if let Some(max_refresh) = &self.max_refresh {
            let max_refresh_out = max_refresh.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MAX_REFRESH",
                item_text: max_refresh_out,
                is_block: false,
                incfile: &max_refresh.__block_info.incfile,
                uid: max_refresh.__block_info.uid,
                line: max_refresh.__block_info.line,
                start_offset: max_refresh.__block_info.start_offset,
                end_offset: max_refresh.__block_info.end_offset,
                position_restriction: max_refresh.pos_restrict(),
            });
        }
        if let Some(model_link) = &self.model_link {
            let model_link_out = model_link.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MODEL_LINK",
                item_text: model_link_out,
                is_block: false,
                incfile: &model_link.__block_info.incfile,
                uid: model_link.__block_info.uid,
                line: model_link.__block_info.line,
                start_offset: model_link.__block_info.start_offset,
                end_offset: model_link.__block_info.end_offset,
                position_restriction: model_link.pos_restrict(),
            });
        }
        if let Some(phys_unit) = &self.phys_unit {
            let phys_unit_out = phys_unit.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "PHYS_UNIT",
                item_text: phys_unit_out,
                is_block: false,
                incfile: &phys_unit.__block_info.incfile,
                uid: phys_unit.__block_info.uid,
                line: phys_unit.__block_info.line,
                start_offset: phys_unit.__block_info.start_offset,
                end_offset: phys_unit.__block_info.end_offset,
                position_restriction: phys_unit.pos_restrict(),
            });
        }
        if let Some(read_write) = &self.read_write {
            let read_write_out = read_write.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "READ_WRITE",
                item_text: read_write_out,
                is_block: false,
                incfile: &read_write.__block_info.incfile,
                uid: read_write.__block_info.uid,
                line: read_write.__block_info.line,
                start_offset: read_write.__block_info.start_offset,
                end_offset: read_write.__block_info.end_offset,
                position_restriction: read_write.pos_restrict(),
            });
        }
        if let Some(ref_memory_segment) = &self.ref_memory_segment {
            let ref_memory_segment_out = ref_memory_segment.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "REF_MEMORY_SEGMENT",
                item_text: ref_memory_segment_out,
                is_block: false,
                incfile: &ref_memory_segment.__block_info.incfile,
                uid: ref_memory_segment.__block_info.uid,
                line: ref_memory_segment.__block_info.line,
                start_offset: ref_memory_segment.__block_info.start_offset,
                end_offset: ref_memory_segment.__block_info.end_offset,
                position_restriction: ref_memory_segment.pos_restrict(),
            });
        }
        if let Some(symbol_link) = &self.symbol_link {
            let symbol_link_out = symbol_link.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SYMBOL_LINK",
                item_text: symbol_link_out,
                is_block: false,
                incfile: &symbol_link.__block_info.incfile,
                uid: symbol_link.__block_info.uid,
                line: symbol_link.__block_info.line,
                start_offset: symbol_link.__block_info.start_offset,
                end_offset: symbol_link.__block_info.end_offset,
                position_restriction: symbol_link.pos_restrict(),
            });
        }
        if let Some(var_virtual) = &self.var_virtual {
            let var_virtual_out = var_virtual.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "VIRTUAL",
                item_text: var_virtual_out,
                is_block: true,
                incfile: &var_virtual.__block_info.incfile,
                uid: var_virtual.__block_info.uid,
                line: var_virtual.__block_info.line,
                start_offset: var_virtual.__block_info.start_offset,
                end_offset: var_virtual.__block_info.end_offset,
                position_restriction: var_virtual.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// specifies if a given memory region is internal or external
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MemoryAttribute {
    Intern,
    Extern,
}

impl ParseableA2lObject for MemoryAttribute {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "INTERN" => Ok(Self::Intern),
            "EXTERN" => Ok(Self::Extern),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for MemoryAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::Intern => "INTERN",
            Self::Extern => "EXTERN",
        };
        f.write_str(tag)
    }
}

/// describes the layout of the ECU memory
#[derive(Clone)]
pub struct MemoryLayout {
    pub prog_type: ProgType,
    pub address: u32,
    pub size: u32,
    pub offset: [i32; 5usize],
    pub if_data: Vec<IfData>,
    pub(crate) __block_info: BlockInfo<(u32, (u32, bool), (u32, bool), [(u32, bool); 5usize])>,
}

impl std::fmt::Debug for MemoryLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("MemoryLayout")
            .field("prog_type", &self.prog_type)
            .field("address", &self.address)
            .field("size", &self.size)
            .field("offset", &self.offset)
            .field("if_data", &self.if_data)
            .finish()
    }
}

impl MemoryLayout {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(prog_type: ProgType, address: u32, size: u32, offset: [i32; 5usize]) -> Self {
        Self {
            prog_type,
            address,
            size,
            offset,
            if_data: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (
                    1u32,
                    (0u32, false),
                    (0u32, false),
                    [
                        (0u32, false),
                        (0u32, false),
                        (0u32, false),
                        (0u32, false),
                        (0u32, false),
                    ],
                ),
            },
        }
    }
}

impl PartialEq for MemoryLayout {
    fn eq(&self, other: &Self) -> bool {
        (self.prog_type == other.prog_type)
            && (self.address == other.address)
            && (self.size == other.size)
            && (self.offset == other.offset)
            && (self.if_data == other.if_data)
    }
}

impl A2lObject<(u32, (u32, bool), (u32, bool), [(u32, bool); 5usize])> for MemoryLayout {
    fn get_layout(&self) -> &BlockInfo<(u32, (u32, bool), (u32, bool), [(u32, bool); 5usize])> {
        &self.__block_info
    }
    fn get_layout_mut(
        &mut self,
    ) -> &mut BlockInfo<(u32, (u32, bool), (u32, bool), [(u32, bool); 5usize])> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        for if_data in &mut self.if_data {
            if_data.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for MemoryLayout {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__prog_type_location, prog_type) = (
            parser.get_current_line_offset(),
            ProgType::parse(parser, context, 0)?,
        );
        let (__address_location, address) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let (__size_location, size) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let (__offset_location, offset) = {
            let __arrayitem_0 = {
                let line = parser.get_current_line_offset();
                let (value, is_hex) = parser.get_integer::<i32>(context)?;
                ((line, is_hex), value)
            };
            let __arrayitem_1 = {
                let line = parser.get_current_line_offset();
                let (value, is_hex) = parser.get_integer::<i32>(context)?;
                ((line, is_hex), value)
            };
            let __arrayitem_2 = {
                let line = parser.get_current_line_offset();
                let (value, is_hex) = parser.get_integer::<i32>(context)?;
                ((line, is_hex), value)
            };
            let __arrayitem_3 = {
                let line = parser.get_current_line_offset();
                let (value, is_hex) = parser.get_integer::<i32>(context)?;
                ((line, is_hex), value)
            };
            let __arrayitem_4 = {
                let line = parser.get_current_line_offset();
                let (value, is_hex) = parser.get_integer::<i32>(context)?;
                ((line, is_hex), value)
            };
            (
                [
                    __arrayitem_0.0,
                    __arrayitem_1.0,
                    __arrayitem_2.0,
                    __arrayitem_3.0,
                    __arrayitem_4.0,
                ],
                [
                    __arrayitem_0.1,
                    __arrayitem_1.1,
                    __arrayitem_2.1,
                    __arrayitem_3.1,
                    __arrayitem_4.1,
                ],
            )
        };
        let mut if_data: Vec<IfData> = Vec::new();
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 1usize] = ["IF_DATA"];
            match tag {
                "IF_DATA" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = IfData::parse(parser, &newcontext, line_offset)?;
                    if_data.push(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __prog_type_location,
                    __address_location,
                    __size_location,
                    __offset_location,
                ),
            },
            prog_type,
            address,
            size,
            offset,
            if_data,
        })
    }
}

impl MemoryLayout {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(
            &self.prog_type.to_string(),
            self.__block_info.item_location.0,
        );
        writer.add_integer(
            self.address,
            self.__block_info.item_location.1 .1,
            self.__block_info.item_location.1 .0,
        );
        writer.add_integer(
            self.size,
            self.__block_info.item_location.2 .1,
            self.__block_info.item_location.2 .0,
        );
        for idx0 in 0..5usize {
            writer.add_integer(
                self.offset[idx0],
                self.__block_info.item_location.3[idx0].1,
                self.__block_info.item_location.3[idx0].0,
            );
        }
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        for if_data in &self.if_data {
            let if_data_out = if_data.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "IF_DATA",
                item_text: if_data_out,
                is_block: true,
                incfile: &if_data.__block_info.incfile,
                uid: if_data.__block_info.uid,
                line: if_data.__block_info.line,
                start_offset: if_data.__block_info.start_offset,
                end_offset: if_data.__block_info.end_offset,
                position_restriction: if_data.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// describes a memory segment of the ECU program
#[derive(Clone)]
pub struct MemorySegment {
    pub name: String,
    pub long_identifier: String,
    pub prg_type: PrgType,
    pub memory_type: MemoryType,
    pub attribute: MemoryAttribute,
    pub address: u32,
    pub size: u32,
    pub offset: [i32; 5usize],
    pub if_data: Vec<IfData>,
    pub(crate) __block_info: BlockInfo<(
        u32,
        u32,
        u32,
        u32,
        u32,
        (u32, bool),
        (u32, bool),
        [(u32, bool); 5usize],
    )>,
}

impl std::fmt::Debug for MemorySegment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("MemorySegment")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("prg_type", &self.prg_type)
            .field("memory_type", &self.memory_type)
            .field("attribute", &self.attribute)
            .field("address", &self.address)
            .field("size", &self.size)
            .field("offset", &self.offset)
            .field("if_data", &self.if_data)
            .finish()
    }
}

impl MemorySegment {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        name: String,
        long_identifier: String,
        prg_type: PrgType,
        memory_type: MemoryType,
        attribute: MemoryAttribute,
        address: u32,
        size: u32,
        offset: [i32; 5usize],
    ) -> Self {
        Self {
            name,
            long_identifier,
            prg_type,
            memory_type,
            attribute,
            address,
            size,
            offset,
            if_data: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (
                    0u32,
                    0u32,
                    1u32,
                    0u32,
                    0u32,
                    (0u32, false),
                    (0u32, false),
                    [
                        (0u32, false),
                        (0u32, false),
                        (0u32, false),
                        (0u32, false),
                        (0u32, false),
                    ],
                ),
            },
        }
    }
}

impl PartialEq for MemorySegment {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.prg_type == other.prg_type)
            && (self.memory_type == other.memory_type)
            && (self.attribute == other.attribute)
            && (self.address == other.address)
            && (self.size == other.size)
            && (self.offset == other.offset)
            && (self.if_data == other.if_data)
    }
}

impl
    A2lObject<(
        u32,
        u32,
        u32,
        u32,
        u32,
        (u32, bool),
        (u32, bool),
        [(u32, bool); 5usize],
    )> for MemorySegment
{
    fn get_layout(
        &self,
    ) -> &BlockInfo<(
        u32,
        u32,
        u32,
        u32,
        u32,
        (u32, bool),
        (u32, bool),
        [(u32, bool); 5usize],
    )> {
        &self.__block_info
    }
    fn get_layout_mut(
        &mut self,
    ) -> &mut BlockInfo<(
        u32,
        u32,
        u32,
        u32,
        u32,
        (u32, bool),
        (u32, bool),
        [(u32, bool); 5usize],
    )> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        for if_data in &mut self.if_data {
            if_data.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for MemorySegment {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for MemorySegment {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__prg_type_location, prg_type) = (
            parser.get_current_line_offset(),
            PrgType::parse(parser, context, 0)?,
        );
        let (__memory_type_location, memory_type) = (
            parser.get_current_line_offset(),
            MemoryType::parse(parser, context, 0)?,
        );
        let (__attribute_location, attribute) = (
            parser.get_current_line_offset(),
            MemoryAttribute::parse(parser, context, 0)?,
        );
        let (__address_location, address) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let (__size_location, size) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let (__offset_location, offset) = {
            let __arrayitem_0 = {
                let line = parser.get_current_line_offset();
                let (value, is_hex) = parser.get_integer::<i32>(context)?;
                ((line, is_hex), value)
            };
            let __arrayitem_1 = {
                let line = parser.get_current_line_offset();
                let (value, is_hex) = parser.get_integer::<i32>(context)?;
                ((line, is_hex), value)
            };
            let __arrayitem_2 = {
                let line = parser.get_current_line_offset();
                let (value, is_hex) = parser.get_integer::<i32>(context)?;
                ((line, is_hex), value)
            };
            let __arrayitem_3 = {
                let line = parser.get_current_line_offset();
                let (value, is_hex) = parser.get_integer::<i32>(context)?;
                ((line, is_hex), value)
            };
            let __arrayitem_4 = {
                let line = parser.get_current_line_offset();
                let (value, is_hex) = parser.get_integer::<i32>(context)?;
                ((line, is_hex), value)
            };
            (
                [
                    __arrayitem_0.0,
                    __arrayitem_1.0,
                    __arrayitem_2.0,
                    __arrayitem_3.0,
                    __arrayitem_4.0,
                ],
                [
                    __arrayitem_0.1,
                    __arrayitem_1.1,
                    __arrayitem_2.1,
                    __arrayitem_3.1,
                    __arrayitem_4.1,
                ],
            )
        };
        let mut if_data: Vec<IfData> = Vec::new();
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 1usize] = ["IF_DATA"];
            match tag {
                "IF_DATA" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = IfData::parse(parser, &newcontext, line_offset)?;
                    if_data.push(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __prg_type_location,
                    __memory_type_location,
                    __attribute_location,
                    __address_location,
                    __size_location,
                    __offset_location,
                ),
            },
            name,
            long_identifier,
            prg_type,
            memory_type,
            attribute,
            address,
            size,
            offset,
            if_data,
        })
    }
}

impl MemorySegment {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_str(
            &self.prg_type.to_string(),
            self.__block_info.item_location.2,
        );
        writer.add_str(
            &self.memory_type.to_string(),
            self.__block_info.item_location.3,
        );
        writer.add_str(
            &self.attribute.to_string(),
            self.__block_info.item_location.4,
        );
        writer.add_integer(
            self.address,
            self.__block_info.item_location.5 .1,
            self.__block_info.item_location.5 .0,
        );
        writer.add_integer(
            self.size,
            self.__block_info.item_location.6 .1,
            self.__block_info.item_location.6 .0,
        );
        for idx0 in 0..5usize {
            writer.add_integer(
                self.offset[idx0],
                self.__block_info.item_location.7[idx0].1,
                self.__block_info.item_location.7[idx0].0,
            );
        }
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        for if_data in &self.if_data {
            let if_data_out = if_data.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "IF_DATA",
                item_text: if_data_out,
                is_block: true,
                incfile: &if_data.__block_info.incfile,
                uid: if_data.__block_info.uid,
                line: if_data.__block_info.line,
                start_offset: if_data.__block_info.start_offset,
                end_offset: if_data.__block_info.end_offset,
                position_restriction: if_data.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// describes the type of memory used
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MemoryType {
    Eeprom,
    Eprom,
    Flash,
    Ram,
    Rom,
    Register,
    NotInEcu,
}

impl ParseableA2lObject for MemoryType {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "EEPROM" => Ok(Self::Eeprom),
            "EPROM" => Ok(Self::Eprom),
            "FLASH" => Ok(Self::Flash),
            "RAM" => Ok(Self::Ram),
            "ROM" => Ok(Self::Rom),
            "REGISTER" => Ok(Self::Register),
            "NOT_IN_ECU" => {
                parser.check_enumitem_version_lower(context, "NOT_IN_ECU", A2lVersion::V1_7_0)?;
                Ok(Self::NotInEcu)
            }
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for MemoryType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::Eeprom => "EEPROM",
            Self::Eprom => "EPROM",
            Self::Flash => "FLASH",
            Self::Ram => "RAM",
            Self::Rom => "ROM",
            Self::Register => "REGISTER",
            Self::NotInEcu => "NOT_IN_ECU",
        };
        f.write_str(tag)
    }
}

/// defines default values for the  entire module
#[derive(Clone)]
pub struct ModCommon {
    pub comment: String,
    pub alignment_byte: Option<AlignmentByte>,
    pub alignment_float16_ieee: Option<AlignmentFloat16Ieee>,
    pub alignment_float32_ieee: Option<AlignmentFloat32Ieee>,
    pub alignment_float64_ieee: Option<AlignmentFloat64Ieee>,
    pub alignment_int64: Option<AlignmentInt64>,
    pub alignment_long: Option<AlignmentLong>,
    pub alignment_word: Option<AlignmentWord>,
    pub byte_order: Option<ByteOrder>,
    pub data_size: Option<DataSize>,
    pub deposit: Option<Deposit>,
    pub s_rec_layout: Option<SRecLayout>,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for ModCommon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ModCommon")
            .field("comment", &self.comment)
            .field("alignment_byte", &self.alignment_byte)
            .field("alignment_float16_ieee", &self.alignment_float16_ieee)
            .field("alignment_float32_ieee", &self.alignment_float32_ieee)
            .field("alignment_float64_ieee", &self.alignment_float64_ieee)
            .field("alignment_int64", &self.alignment_int64)
            .field("alignment_long", &self.alignment_long)
            .field("alignment_word", &self.alignment_word)
            .field("byte_order", &self.byte_order)
            .field("data_size", &self.data_size)
            .field("deposit", &self.deposit)
            .field("s_rec_layout", &self.s_rec_layout)
            .finish()
    }
}

impl ModCommon {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(comment: String) -> Self {
        Self {
            comment,
            alignment_byte: None,
            alignment_float16_ieee: None,
            alignment_float32_ieee: None,
            alignment_float64_ieee: None,
            alignment_int64: None,
            alignment_long: None,
            alignment_word: None,
            byte_order: None,
            data_size: None,
            deposit: None,
            s_rec_layout: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (1u32, ()),
            },
        }
    }
}

impl PartialEq for ModCommon {
    fn eq(&self, other: &Self) -> bool {
        (self.comment == other.comment)
            && (self.alignment_byte == other.alignment_byte)
            && (self.alignment_float16_ieee == other.alignment_float16_ieee)
            && (self.alignment_float32_ieee == other.alignment_float32_ieee)
            && (self.alignment_float64_ieee == other.alignment_float64_ieee)
            && (self.alignment_int64 == other.alignment_int64)
            && (self.alignment_long == other.alignment_long)
            && (self.alignment_word == other.alignment_word)
            && (self.byte_order == other.byte_order)
            && (self.data_size == other.data_size)
            && (self.deposit == other.deposit)
            && (self.s_rec_layout == other.s_rec_layout)
    }
}

impl A2lObject<(u32, ())> for ModCommon {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(alignment_byte) = &mut self.alignment_byte {
            alignment_byte.merge_includes();
        }
        if let Some(alignment_float16_ieee) = &mut self.alignment_float16_ieee {
            alignment_float16_ieee.merge_includes();
        }
        if let Some(alignment_float32_ieee) = &mut self.alignment_float32_ieee {
            alignment_float32_ieee.merge_includes();
        }
        if let Some(alignment_float64_ieee) = &mut self.alignment_float64_ieee {
            alignment_float64_ieee.merge_includes();
        }
        if let Some(alignment_int64) = &mut self.alignment_int64 {
            alignment_int64.merge_includes();
        }
        if let Some(alignment_long) = &mut self.alignment_long {
            alignment_long.merge_includes();
        }
        if let Some(alignment_word) = &mut self.alignment_word {
            alignment_word.merge_includes();
        }
        if let Some(byte_order) = &mut self.byte_order {
            byte_order.merge_includes();
        }
        if let Some(data_size) = &mut self.data_size {
            data_size.merge_includes();
        }
        if let Some(deposit) = &mut self.deposit {
            deposit.merge_includes();
        }
        if let Some(s_rec_layout) = &mut self.s_rec_layout {
            s_rec_layout.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for ModCommon {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__comment_location, comment) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let mut alignment_byte: Option<AlignmentByte> = None;
        let mut alignment_float16_ieee: Option<AlignmentFloat16Ieee> = None;
        let mut alignment_float32_ieee: Option<AlignmentFloat32Ieee> = None;
        let mut alignment_float64_ieee: Option<AlignmentFloat64Ieee> = None;
        let mut alignment_int64: Option<AlignmentInt64> = None;
        let mut alignment_long: Option<AlignmentLong> = None;
        let mut alignment_word: Option<AlignmentWord> = None;
        let mut byte_order: Option<ByteOrder> = None;
        let mut data_size: Option<DataSize> = None;
        let mut deposit: Option<Deposit> = None;
        let mut s_rec_layout: Option<SRecLayout> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 11usize] = [
                "ALIGNMENT_BYTE",
                "ALIGNMENT_FLOAT16_IEEE",
                "ALIGNMENT_FLOAT32_IEEE",
                "ALIGNMENT_FLOAT64_IEEE",
                "ALIGNMENT_INT64",
                "ALIGNMENT_LONG",
                "ALIGNMENT_WORD",
                "BYTE_ORDER",
                "DATA_SIZE",
                "DEPOSIT",
                "S_REC_LAYOUT",
            ];
            match tag {
                "ALIGNMENT_BYTE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AlignmentByte::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, alignment_byte.is_some())?;
                    alignment_byte = Some(newitem);
                }
                "ALIGNMENT_FLOAT16_IEEE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "ALIGNMENT_FLOAT16_IEEE",
                        A2lVersion::V1_7_1,
                    )?;
                    let newitem = AlignmentFloat16Ieee::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        alignment_float16_ieee.is_some(),
                    )?;
                    alignment_float16_ieee = Some(newitem);
                }
                "ALIGNMENT_FLOAT32_IEEE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AlignmentFloat32Ieee::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        alignment_float32_ieee.is_some(),
                    )?;
                    alignment_float32_ieee = Some(newitem);
                }
                "ALIGNMENT_FLOAT64_IEEE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AlignmentFloat64Ieee::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        alignment_float64_ieee.is_some(),
                    )?;
                    alignment_float64_ieee = Some(newitem);
                }
                "ALIGNMENT_INT64" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "ALIGNMENT_INT64",
                        A2lVersion::V1_6_0,
                    )?;
                    let newitem = AlignmentInt64::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, alignment_int64.is_some())?;
                    alignment_int64 = Some(newitem);
                }
                "ALIGNMENT_LONG" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AlignmentLong::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, alignment_long.is_some())?;
                    alignment_long = Some(newitem);
                }
                "ALIGNMENT_WORD" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AlignmentWord::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, alignment_word.is_some())?;
                    alignment_word = Some(newitem);
                }
                "BYTE_ORDER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ByteOrder::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, byte_order.is_some())?;
                    byte_order = Some(newitem);
                }
                "DATA_SIZE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = DataSize::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, data_size.is_some())?;
                    data_size = Some(newitem);
                }
                "DEPOSIT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Deposit::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, deposit.is_some())?;
                    deposit = Some(newitem);
                }
                "S_REC_LAYOUT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_upper(context, "S_REC_LAYOUT", A2lVersion::V1_6_0);
                    let newitem = SRecLayout::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, s_rec_layout.is_some())?;
                    s_rec_layout = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__comment_location, __dummy),
            },
            comment,
            alignment_byte,
            alignment_float16_ieee,
            alignment_float32_ieee,
            alignment_float64_ieee,
            alignment_int64,
            alignment_long,
            alignment_word,
            byte_order,
            data_size,
            deposit,
            s_rec_layout,
        })
    }
}

impl ModCommon {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.comment, self.__block_info.item_location.0);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(alignment_byte) = &self.alignment_byte {
            let alignment_byte_out = alignment_byte.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ALIGNMENT_BYTE",
                item_text: alignment_byte_out,
                is_block: false,
                incfile: &alignment_byte.__block_info.incfile,
                uid: alignment_byte.__block_info.uid,
                line: alignment_byte.__block_info.line,
                start_offset: alignment_byte.__block_info.start_offset,
                end_offset: alignment_byte.__block_info.end_offset,
                position_restriction: alignment_byte.pos_restrict(),
            });
        }
        if let Some(alignment_float16_ieee) = &self.alignment_float16_ieee {
            let alignment_float16_ieee_out = alignment_float16_ieee.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ALIGNMENT_FLOAT16_IEEE",
                item_text: alignment_float16_ieee_out,
                is_block: false,
                incfile: &alignment_float16_ieee.__block_info.incfile,
                uid: alignment_float16_ieee.__block_info.uid,
                line: alignment_float16_ieee.__block_info.line,
                start_offset: alignment_float16_ieee.__block_info.start_offset,
                end_offset: alignment_float16_ieee.__block_info.end_offset,
                position_restriction: alignment_float16_ieee.pos_restrict(),
            });
        }
        if let Some(alignment_float32_ieee) = &self.alignment_float32_ieee {
            let alignment_float32_ieee_out = alignment_float32_ieee.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ALIGNMENT_FLOAT32_IEEE",
                item_text: alignment_float32_ieee_out,
                is_block: false,
                incfile: &alignment_float32_ieee.__block_info.incfile,
                uid: alignment_float32_ieee.__block_info.uid,
                line: alignment_float32_ieee.__block_info.line,
                start_offset: alignment_float32_ieee.__block_info.start_offset,
                end_offset: alignment_float32_ieee.__block_info.end_offset,
                position_restriction: alignment_float32_ieee.pos_restrict(),
            });
        }
        if let Some(alignment_float64_ieee) = &self.alignment_float64_ieee {
            let alignment_float64_ieee_out = alignment_float64_ieee.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ALIGNMENT_FLOAT64_IEEE",
                item_text: alignment_float64_ieee_out,
                is_block: false,
                incfile: &alignment_float64_ieee.__block_info.incfile,
                uid: alignment_float64_ieee.__block_info.uid,
                line: alignment_float64_ieee.__block_info.line,
                start_offset: alignment_float64_ieee.__block_info.start_offset,
                end_offset: alignment_float64_ieee.__block_info.end_offset,
                position_restriction: alignment_float64_ieee.pos_restrict(),
            });
        }
        if let Some(alignment_int64) = &self.alignment_int64 {
            let alignment_int64_out = alignment_int64.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ALIGNMENT_INT64",
                item_text: alignment_int64_out,
                is_block: false,
                incfile: &alignment_int64.__block_info.incfile,
                uid: alignment_int64.__block_info.uid,
                line: alignment_int64.__block_info.line,
                start_offset: alignment_int64.__block_info.start_offset,
                end_offset: alignment_int64.__block_info.end_offset,
                position_restriction: alignment_int64.pos_restrict(),
            });
        }
        if let Some(alignment_long) = &self.alignment_long {
            let alignment_long_out = alignment_long.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ALIGNMENT_LONG",
                item_text: alignment_long_out,
                is_block: false,
                incfile: &alignment_long.__block_info.incfile,
                uid: alignment_long.__block_info.uid,
                line: alignment_long.__block_info.line,
                start_offset: alignment_long.__block_info.start_offset,
                end_offset: alignment_long.__block_info.end_offset,
                position_restriction: alignment_long.pos_restrict(),
            });
        }
        if let Some(alignment_word) = &self.alignment_word {
            let alignment_word_out = alignment_word.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ALIGNMENT_WORD",
                item_text: alignment_word_out,
                is_block: false,
                incfile: &alignment_word.__block_info.incfile,
                uid: alignment_word.__block_info.uid,
                line: alignment_word.__block_info.line,
                start_offset: alignment_word.__block_info.start_offset,
                end_offset: alignment_word.__block_info.end_offset,
                position_restriction: alignment_word.pos_restrict(),
            });
        }
        if let Some(byte_order) = &self.byte_order {
            let byte_order_out = byte_order.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "BYTE_ORDER",
                item_text: byte_order_out,
                is_block: false,
                incfile: &byte_order.__block_info.incfile,
                uid: byte_order.__block_info.uid,
                line: byte_order.__block_info.line,
                start_offset: byte_order.__block_info.start_offset,
                end_offset: byte_order.__block_info.end_offset,
                position_restriction: byte_order.pos_restrict(),
            });
        }
        if let Some(data_size) = &self.data_size {
            let data_size_out = data_size.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DATA_SIZE",
                item_text: data_size_out,
                is_block: false,
                incfile: &data_size.__block_info.incfile,
                uid: data_size.__block_info.uid,
                line: data_size.__block_info.line,
                start_offset: data_size.__block_info.start_offset,
                end_offset: data_size.__block_info.end_offset,
                position_restriction: data_size.pos_restrict(),
            });
        }
        if let Some(deposit) = &self.deposit {
            let deposit_out = deposit.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DEPOSIT",
                item_text: deposit_out,
                is_block: false,
                incfile: &deposit.__block_info.incfile,
                uid: deposit.__block_info.uid,
                line: deposit.__block_info.line,
                start_offset: deposit.__block_info.start_offset,
                end_offset: deposit.__block_info.end_offset,
                position_restriction: deposit.pos_restrict(),
            });
        }
        if let Some(s_rec_layout) = &self.s_rec_layout {
            let s_rec_layout_out = s_rec_layout.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "S_REC_LAYOUT",
                item_text: s_rec_layout_out,
                is_block: false,
                incfile: &s_rec_layout.__block_info.incfile,
                uid: s_rec_layout.__block_info.uid,
                line: s_rec_layout.__block_info.line,
                start_offset: s_rec_layout.__block_info.start_offset,
                end_offset: s_rec_layout.__block_info.end_offset,
                position_restriction: s_rec_layout.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// defines system information and management data for the module
#[derive(Clone)]
pub struct ModPar {
    pub comment: String,
    pub addr_epk: Vec<AddrEpk>,
    pub calibration_method: Vec<CalibrationMethod>,
    pub cpu_type: Option<CpuType>,
    pub customer: Option<Customer>,
    pub customer_no: Option<CustomerNo>,
    pub ecu: Option<Ecu>,
    pub ecu_calibration_offset: Option<EcuCalibrationOffset>,
    pub epk: Option<Epk>,
    pub memory_layout: Vec<MemoryLayout>,
    pub memory_segment: Vec<MemorySegment>,
    pub no_of_interfaces: Option<NoOfInterfaces>,
    pub phone_no: Option<PhoneNo>,
    pub supplier: Option<Supplier>,
    pub system_constant: Vec<SystemConstant>,
    pub user: Option<User>,
    pub version: Option<Version>,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for ModPar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ModPar")
            .field("comment", &self.comment)
            .field("addr_epk", &self.addr_epk)
            .field("calibration_method", &self.calibration_method)
            .field("cpu_type", &self.cpu_type)
            .field("customer", &self.customer)
            .field("customer_no", &self.customer_no)
            .field("ecu", &self.ecu)
            .field("ecu_calibration_offset", &self.ecu_calibration_offset)
            .field("epk", &self.epk)
            .field("memory_layout", &self.memory_layout)
            .field("memory_segment", &self.memory_segment)
            .field("no_of_interfaces", &self.no_of_interfaces)
            .field("phone_no", &self.phone_no)
            .field("supplier", &self.supplier)
            .field("system_constant", &self.system_constant)
            .field("user", &self.user)
            .field("version", &self.version)
            .finish()
    }
}

impl ModPar {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(comment: String) -> Self {
        Self {
            comment,
            addr_epk: Vec::new(),
            calibration_method: Vec::new(),
            cpu_type: None,
            customer: None,
            customer_no: None,
            ecu: None,
            ecu_calibration_offset: None,
            epk: None,
            memory_layout: Vec::new(),
            memory_segment: Vec::new(),
            no_of_interfaces: None,
            phone_no: None,
            supplier: None,
            system_constant: Vec::new(),
            user: None,
            version: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (1u32, ()),
            },
        }
    }
}

impl PartialEq for ModPar {
    fn eq(&self, other: &Self) -> bool {
        (self.comment == other.comment)
            && (self.addr_epk == other.addr_epk)
            && (self.calibration_method == other.calibration_method)
            && (self.cpu_type == other.cpu_type)
            && (self.customer == other.customer)
            && (self.customer_no == other.customer_no)
            && (self.ecu == other.ecu)
            && (self.ecu_calibration_offset == other.ecu_calibration_offset)
            && (self.epk == other.epk)
            && (self.memory_layout == other.memory_layout)
            && (self.memory_segment == other.memory_segment)
            && (self.no_of_interfaces == other.no_of_interfaces)
            && (self.phone_no == other.phone_no)
            && (self.supplier == other.supplier)
            && (self.system_constant == other.system_constant)
            && (self.user == other.user)
            && (self.version == other.version)
    }
}

impl A2lObject<(u32, ())> for ModPar {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        for addr_epk in &mut self.addr_epk {
            addr_epk.merge_includes();
        }
        for calibration_method in &mut self.calibration_method {
            calibration_method.merge_includes();
        }
        if let Some(cpu_type) = &mut self.cpu_type {
            cpu_type.merge_includes();
        }
        if let Some(customer) = &mut self.customer {
            customer.merge_includes();
        }
        if let Some(customer_no) = &mut self.customer_no {
            customer_no.merge_includes();
        }
        if let Some(ecu) = &mut self.ecu {
            ecu.merge_includes();
        }
        if let Some(ecu_calibration_offset) = &mut self.ecu_calibration_offset {
            ecu_calibration_offset.merge_includes();
        }
        if let Some(epk) = &mut self.epk {
            epk.merge_includes();
        }
        for memory_layout in &mut self.memory_layout {
            memory_layout.merge_includes();
        }
        for memory_segment in &mut self.memory_segment {
            memory_segment.merge_includes();
        }
        if let Some(no_of_interfaces) = &mut self.no_of_interfaces {
            no_of_interfaces.merge_includes();
        }
        if let Some(phone_no) = &mut self.phone_no {
            phone_no.merge_includes();
        }
        if let Some(supplier) = &mut self.supplier {
            supplier.merge_includes();
        }
        for system_constant in &mut self.system_constant {
            system_constant.merge_includes();
        }
        if let Some(user) = &mut self.user {
            user.merge_includes();
        }
        if let Some(version) = &mut self.version {
            version.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for ModPar {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__comment_location, comment) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let mut addr_epk: Vec<AddrEpk> = Vec::new();
        let mut calibration_method: Vec<CalibrationMethod> = Vec::new();
        let mut cpu_type: Option<CpuType> = None;
        let mut customer: Option<Customer> = None;
        let mut customer_no: Option<CustomerNo> = None;
        let mut ecu: Option<Ecu> = None;
        let mut ecu_calibration_offset: Option<EcuCalibrationOffset> = None;
        let mut epk: Option<Epk> = None;
        let mut memory_layout: Vec<MemoryLayout> = Vec::new();
        let mut memory_segment: Vec<MemorySegment> = Vec::new();
        let mut no_of_interfaces: Option<NoOfInterfaces> = None;
        let mut phone_no: Option<PhoneNo> = None;
        let mut supplier: Option<Supplier> = None;
        let mut system_constant: Vec<SystemConstant> = Vec::new();
        let mut user: Option<User> = None;
        let mut version: Option<Version> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 16usize] = [
                "ADDR_EPK",
                "CALIBRATION_METHOD",
                "CPU_TYPE",
                "CUSTOMER",
                "CUSTOMER_NO",
                "ECU",
                "ECU_CALIBRATION_OFFSET",
                "EPK",
                "MEMORY_LAYOUT",
                "MEMORY_SEGMENT",
                "NO_OF_INTERFACES",
                "PHONE_NO",
                "SUPPLIER",
                "SYSTEM_CONSTANT",
                "USER",
                "VERSION",
            ];
            match tag {
                "ADDR_EPK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AddrEpk::parse(parser, &newcontext, line_offset)?;
                    addr_epk.push(newitem);
                }
                "CALIBRATION_METHOD" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = CalibrationMethod::parse(parser, &newcontext, line_offset)?;
                    calibration_method.push(newitem);
                }
                "CPU_TYPE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = CpuType::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, cpu_type.is_some())?;
                    cpu_type = Some(newitem);
                }
                "CUSTOMER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Customer::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, customer.is_some())?;
                    customer = Some(newitem);
                }
                "CUSTOMER_NO" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = CustomerNo::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, customer_no.is_some())?;
                    customer_no = Some(newitem);
                }
                "ECU" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Ecu::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, ecu.is_some())?;
                    ecu = Some(newitem);
                }
                "ECU_CALIBRATION_OFFSET" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = EcuCalibrationOffset::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        ecu_calibration_offset.is_some(),
                    )?;
                    ecu_calibration_offset = Some(newitem);
                }
                "EPK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Epk::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, epk.is_some())?;
                    epk = Some(newitem);
                }
                "MEMORY_LAYOUT" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = MemoryLayout::parse(parser, &newcontext, line_offset)?;
                    memory_layout.push(newitem);
                }
                "MEMORY_SEGMENT" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = MemorySegment::parse(parser, &newcontext, line_offset)?;
                    memory_segment.push(newitem);
                }
                "NO_OF_INTERFACES" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = NoOfInterfaces::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, no_of_interfaces.is_some())?;
                    no_of_interfaces = Some(newitem);
                }
                "PHONE_NO" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = PhoneNo::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, phone_no.is_some())?;
                    phone_no = Some(newitem);
                }
                "SUPPLIER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Supplier::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, supplier.is_some())?;
                    supplier = Some(newitem);
                }
                "SYSTEM_CONSTANT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = SystemConstant::parse(parser, &newcontext, line_offset)?;
                    system_constant.push(newitem);
                }
                "USER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = User::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, user.is_some())?;
                    user = Some(newitem);
                }
                "VERSION" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Version::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, version.is_some())?;
                    version = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__comment_location, __dummy),
            },
            comment,
            addr_epk,
            calibration_method,
            cpu_type,
            customer,
            customer_no,
            ecu,
            ecu_calibration_offset,
            epk,
            memory_layout,
            memory_segment,
            no_of_interfaces,
            phone_no,
            supplier,
            system_constant,
            user,
            version,
        })
    }
}

impl ModPar {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.comment, self.__block_info.item_location.0);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        for addr_epk in &self.addr_epk {
            let addr_epk_out = addr_epk.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ADDR_EPK",
                item_text: addr_epk_out,
                is_block: false,
                incfile: &addr_epk.__block_info.incfile,
                uid: addr_epk.__block_info.uid,
                line: addr_epk.__block_info.line,
                start_offset: addr_epk.__block_info.start_offset,
                end_offset: addr_epk.__block_info.end_offset,
                position_restriction: addr_epk.pos_restrict(),
            });
        }
        for calibration_method in &self.calibration_method {
            let calibration_method_out = calibration_method.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "CALIBRATION_METHOD",
                item_text: calibration_method_out,
                is_block: true,
                incfile: &calibration_method.__block_info.incfile,
                uid: calibration_method.__block_info.uid,
                line: calibration_method.__block_info.line,
                start_offset: calibration_method.__block_info.start_offset,
                end_offset: calibration_method.__block_info.end_offset,
                position_restriction: calibration_method.pos_restrict(),
            });
        }
        if let Some(cpu_type) = &self.cpu_type {
            let cpu_type_out = cpu_type.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "CPU_TYPE",
                item_text: cpu_type_out,
                is_block: false,
                incfile: &cpu_type.__block_info.incfile,
                uid: cpu_type.__block_info.uid,
                line: cpu_type.__block_info.line,
                start_offset: cpu_type.__block_info.start_offset,
                end_offset: cpu_type.__block_info.end_offset,
                position_restriction: cpu_type.pos_restrict(),
            });
        }
        if let Some(customer) = &self.customer {
            let customer_out = customer.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "CUSTOMER",
                item_text: customer_out,
                is_block: false,
                incfile: &customer.__block_info.incfile,
                uid: customer.__block_info.uid,
                line: customer.__block_info.line,
                start_offset: customer.__block_info.start_offset,
                end_offset: customer.__block_info.end_offset,
                position_restriction: customer.pos_restrict(),
            });
        }
        if let Some(customer_no) = &self.customer_no {
            let customer_no_out = customer_no.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "CUSTOMER_NO",
                item_text: customer_no_out,
                is_block: false,
                incfile: &customer_no.__block_info.incfile,
                uid: customer_no.__block_info.uid,
                line: customer_no.__block_info.line,
                start_offset: customer_no.__block_info.start_offset,
                end_offset: customer_no.__block_info.end_offset,
                position_restriction: customer_no.pos_restrict(),
            });
        }
        if let Some(ecu) = &self.ecu {
            let ecu_out = ecu.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ECU",
                item_text: ecu_out,
                is_block: false,
                incfile: &ecu.__block_info.incfile,
                uid: ecu.__block_info.uid,
                line: ecu.__block_info.line,
                start_offset: ecu.__block_info.start_offset,
                end_offset: ecu.__block_info.end_offset,
                position_restriction: ecu.pos_restrict(),
            });
        }
        if let Some(ecu_calibration_offset) = &self.ecu_calibration_offset {
            let ecu_calibration_offset_out = ecu_calibration_offset.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ECU_CALIBRATION_OFFSET",
                item_text: ecu_calibration_offset_out,
                is_block: false,
                incfile: &ecu_calibration_offset.__block_info.incfile,
                uid: ecu_calibration_offset.__block_info.uid,
                line: ecu_calibration_offset.__block_info.line,
                start_offset: ecu_calibration_offset.__block_info.start_offset,
                end_offset: ecu_calibration_offset.__block_info.end_offset,
                position_restriction: ecu_calibration_offset.pos_restrict(),
            });
        }
        if let Some(epk) = &self.epk {
            let epk_out = epk.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "EPK",
                item_text: epk_out,
                is_block: false,
                incfile: &epk.__block_info.incfile,
                uid: epk.__block_info.uid,
                line: epk.__block_info.line,
                start_offset: epk.__block_info.start_offset,
                end_offset: epk.__block_info.end_offset,
                position_restriction: epk.pos_restrict(),
            });
        }
        for memory_layout in &self.memory_layout {
            let memory_layout_out = memory_layout.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MEMORY_LAYOUT",
                item_text: memory_layout_out,
                is_block: true,
                incfile: &memory_layout.__block_info.incfile,
                uid: memory_layout.__block_info.uid,
                line: memory_layout.__block_info.line,
                start_offset: memory_layout.__block_info.start_offset,
                end_offset: memory_layout.__block_info.end_offset,
                position_restriction: memory_layout.pos_restrict(),
            });
        }
        for memory_segment in &self.memory_segment {
            let memory_segment_out = memory_segment.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MEMORY_SEGMENT",
                item_text: memory_segment_out,
                is_block: true,
                incfile: &memory_segment.__block_info.incfile,
                uid: memory_segment.__block_info.uid,
                line: memory_segment.__block_info.line,
                start_offset: memory_segment.__block_info.start_offset,
                end_offset: memory_segment.__block_info.end_offset,
                position_restriction: memory_segment.pos_restrict(),
            });
        }
        if let Some(no_of_interfaces) = &self.no_of_interfaces {
            let no_of_interfaces_out = no_of_interfaces.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "NO_OF_INTERFACES",
                item_text: no_of_interfaces_out,
                is_block: false,
                incfile: &no_of_interfaces.__block_info.incfile,
                uid: no_of_interfaces.__block_info.uid,
                line: no_of_interfaces.__block_info.line,
                start_offset: no_of_interfaces.__block_info.start_offset,
                end_offset: no_of_interfaces.__block_info.end_offset,
                position_restriction: no_of_interfaces.pos_restrict(),
            });
        }
        if let Some(phone_no) = &self.phone_no {
            let phone_no_out = phone_no.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "PHONE_NO",
                item_text: phone_no_out,
                is_block: false,
                incfile: &phone_no.__block_info.incfile,
                uid: phone_no.__block_info.uid,
                line: phone_no.__block_info.line,
                start_offset: phone_no.__block_info.start_offset,
                end_offset: phone_no.__block_info.end_offset,
                position_restriction: phone_no.pos_restrict(),
            });
        }
        if let Some(supplier) = &self.supplier {
            let supplier_out = supplier.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SUPPLIER",
                item_text: supplier_out,
                is_block: false,
                incfile: &supplier.__block_info.incfile,
                uid: supplier.__block_info.uid,
                line: supplier.__block_info.line,
                start_offset: supplier.__block_info.start_offset,
                end_offset: supplier.__block_info.end_offset,
                position_restriction: supplier.pos_restrict(),
            });
        }
        for system_constant in &self.system_constant {
            let system_constant_out = system_constant.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SYSTEM_CONSTANT",
                item_text: system_constant_out,
                is_block: false,
                incfile: &system_constant.__block_info.incfile,
                uid: system_constant.__block_info.uid,
                line: system_constant.__block_info.line,
                start_offset: system_constant.__block_info.start_offset,
                end_offset: system_constant.__block_info.end_offset,
                position_restriction: system_constant.pos_restrict(),
            });
        }
        if let Some(user) = &self.user {
            let user_out = user.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "USER",
                item_text: user_out,
                is_block: false,
                incfile: &user.__block_info.incfile,
                uid: user.__block_info.uid,
                line: user.__block_info.line,
                start_offset: user.__block_info.start_offset,
                end_offset: user.__block_info.end_offset,
                position_restriction: user.pos_restrict(),
            });
        }
        if let Some(version) = &self.version {
            let version_out = version.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "VERSION",
                item_text: version_out,
                is_block: false,
                incfile: &version.__block_info.incfile,
                uid: version.__block_info.uid,
                line: version.__block_info.line,
                start_offset: version.__block_info.start_offset,
                end_offset: version.__block_info.end_offset,
                position_restriction: version.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// add a string to a CHARACTERISTIC linking it to a name in the model
#[derive(Clone)]
pub struct ModelLink {
    pub model_link: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for ModelLink {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ModelLink")
            .field("model_link", &self.model_link)
            .finish()
    }
}

impl ModelLink {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(model_link: String) -> Self {
        Self {
            model_link,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for ModelLink {
    fn eq(&self, other: &Self) -> bool {
        self.model_link == other.model_link
    }
}

impl A2lObject<(u32, ())> for ModelLink {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for ModelLink {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__model_link_location, model_link) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__model_link_location, __dummy),
            },
            model_link,
        })
    }
}

impl ModelLink {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.model_link, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// The MODULE keyword describes a complete ECU or device with all adjustable and measurement objects, conversion methods and functions
///
/// At least one module must be defined within the PROJECT
#[derive(Clone)]
pub struct Module {
    pub name: String,
    pub long_identifier: String,
    pub a2ml: Option<A2ml>,
    pub axis_pts: Vec<AxisPts>,
    pub blob: Vec<Blob>,
    pub characteristic: Vec<Characteristic>,
    pub compu_method: Vec<CompuMethod>,
    pub compu_tab: Vec<CompuTab>,
    pub compu_vtab: Vec<CompuVtab>,
    pub compu_vtab_range: Vec<CompuVtabRange>,
    pub frame: Vec<Frame>,
    pub function: Vec<Function>,
    pub group: Vec<Group>,
    pub if_data: Vec<IfData>,
    pub instance: Vec<Instance>,
    pub measurement: Vec<Measurement>,
    pub mod_common: Option<ModCommon>,
    pub mod_par: Option<ModPar>,
    pub record_layout: Vec<RecordLayout>,
    pub transformer: Vec<Transformer>,
    pub typedef_axis: Vec<TypedefAxis>,
    pub typedef_blob: Vec<TypedefBlob>,
    pub typedef_characteristic: Vec<TypedefCharacteristic>,
    pub typedef_measurement: Vec<TypedefMeasurement>,
    pub typedef_structure: Vec<TypedefStructure>,
    pub unit: Vec<Unit>,
    pub user_rights: Vec<UserRights>,
    pub variant_coding: Option<VariantCoding>,
    pub(crate) __block_info: BlockInfo<(u32, u32)>,
}

impl std::fmt::Debug for Module {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Module")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("a2ml", &self.a2ml)
            .field("axis_pts", &self.axis_pts)
            .field("blob", &self.blob)
            .field("characteristic", &self.characteristic)
            .field("compu_method", &self.compu_method)
            .field("compu_tab", &self.compu_tab)
            .field("compu_vtab", &self.compu_vtab)
            .field("compu_vtab_range", &self.compu_vtab_range)
            .field("frame", &self.frame)
            .field("function", &self.function)
            .field("group", &self.group)
            .field("if_data", &self.if_data)
            .field("instance", &self.instance)
            .field("measurement", &self.measurement)
            .field("mod_common", &self.mod_common)
            .field("mod_par", &self.mod_par)
            .field("record_layout", &self.record_layout)
            .field("transformer", &self.transformer)
            .field("typedef_axis", &self.typedef_axis)
            .field("typedef_blob", &self.typedef_blob)
            .field("typedef_characteristic", &self.typedef_characteristic)
            .field("typedef_measurement", &self.typedef_measurement)
            .field("typedef_structure", &self.typedef_structure)
            .field("unit", &self.unit)
            .field("user_rights", &self.user_rights)
            .field("variant_coding", &self.variant_coding)
            .finish()
    }
}

impl Module {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String, long_identifier: String) -> Self {
        Self {
            name,
            long_identifier,
            a2ml: None,
            axis_pts: Vec::new(),
            blob: Vec::new(),
            characteristic: Vec::new(),
            compu_method: Vec::new(),
            compu_tab: Vec::new(),
            compu_vtab: Vec::new(),
            compu_vtab_range: Vec::new(),
            frame: Vec::new(),
            function: Vec::new(),
            group: Vec::new(),
            if_data: Vec::new(),
            instance: Vec::new(),
            measurement: Vec::new(),
            mod_common: None,
            mod_par: None,
            record_layout: Vec::new(),
            transformer: Vec::new(),
            typedef_axis: Vec::new(),
            typedef_blob: Vec::new(),
            typedef_characteristic: Vec::new(),
            typedef_measurement: Vec::new(),
            typedef_structure: Vec::new(),
            unit: Vec::new(),
            user_rights: Vec::new(),
            variant_coding: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32),
            },
        }
    }
}

impl PartialEq for Module {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.a2ml == other.a2ml)
            && (self.axis_pts == other.axis_pts)
            && (self.blob == other.blob)
            && (self.characteristic == other.characteristic)
            && (self.compu_method == other.compu_method)
            && (self.compu_tab == other.compu_tab)
            && (self.compu_vtab == other.compu_vtab)
            && (self.compu_vtab_range == other.compu_vtab_range)
            && (self.frame == other.frame)
            && (self.function == other.function)
            && (self.group == other.group)
            && (self.if_data == other.if_data)
            && (self.instance == other.instance)
            && (self.measurement == other.measurement)
            && (self.mod_common == other.mod_common)
            && (self.mod_par == other.mod_par)
            && (self.record_layout == other.record_layout)
            && (self.transformer == other.transformer)
            && (self.typedef_axis == other.typedef_axis)
            && (self.typedef_blob == other.typedef_blob)
            && (self.typedef_characteristic == other.typedef_characteristic)
            && (self.typedef_measurement == other.typedef_measurement)
            && (self.typedef_structure == other.typedef_structure)
            && (self.unit == other.unit)
            && (self.user_rights == other.user_rights)
            && (self.variant_coding == other.variant_coding)
    }
}

impl A2lObject<(u32, u32)> for Module {
    fn get_layout(&self) -> &BlockInfo<(u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(a2ml) = &mut self.a2ml {
            a2ml.merge_includes();
        }
        for axis_pts in &mut self.axis_pts {
            axis_pts.merge_includes();
        }
        for blob in &mut self.blob {
            blob.merge_includes();
        }
        for characteristic in &mut self.characteristic {
            characteristic.merge_includes();
        }
        for compu_method in &mut self.compu_method {
            compu_method.merge_includes();
        }
        for compu_tab in &mut self.compu_tab {
            compu_tab.merge_includes();
        }
        for compu_vtab in &mut self.compu_vtab {
            compu_vtab.merge_includes();
        }
        for compu_vtab_range in &mut self.compu_vtab_range {
            compu_vtab_range.merge_includes();
        }
        for frame in &mut self.frame {
            frame.merge_includes();
        }
        for function in &mut self.function {
            function.merge_includes();
        }
        for group in &mut self.group {
            group.merge_includes();
        }
        for if_data in &mut self.if_data {
            if_data.merge_includes();
        }
        for instance in &mut self.instance {
            instance.merge_includes();
        }
        for measurement in &mut self.measurement {
            measurement.merge_includes();
        }
        if let Some(mod_common) = &mut self.mod_common {
            mod_common.merge_includes();
        }
        if let Some(mod_par) = &mut self.mod_par {
            mod_par.merge_includes();
        }
        for record_layout in &mut self.record_layout {
            record_layout.merge_includes();
        }
        for transformer in &mut self.transformer {
            transformer.merge_includes();
        }
        for typedef_axis in &mut self.typedef_axis {
            typedef_axis.merge_includes();
        }
        for typedef_blob in &mut self.typedef_blob {
            typedef_blob.merge_includes();
        }
        for typedef_characteristic in &mut self.typedef_characteristic {
            typedef_characteristic.merge_includes();
        }
        for typedef_measurement in &mut self.typedef_measurement {
            typedef_measurement.merge_includes();
        }
        for typedef_structure in &mut self.typedef_structure {
            typedef_structure.merge_includes();
        }
        for unit in &mut self.unit {
            unit.merge_includes();
        }
        for user_rights in &mut self.user_rights {
            user_rights.merge_includes();
        }
        if let Some(variant_coding) = &mut self.variant_coding {
            variant_coding.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for Module {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for Module {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let mut a2ml: Option<A2ml> = None;
        let mut axis_pts: Vec<AxisPts> = Vec::new();
        let mut blob: Vec<Blob> = Vec::new();
        let mut characteristic: Vec<Characteristic> = Vec::new();
        let mut compu_method: Vec<CompuMethod> = Vec::new();
        let mut compu_tab: Vec<CompuTab> = Vec::new();
        let mut compu_vtab: Vec<CompuVtab> = Vec::new();
        let mut compu_vtab_range: Vec<CompuVtabRange> = Vec::new();
        let mut frame: Vec<Frame> = Vec::new();
        let mut function: Vec<Function> = Vec::new();
        let mut group: Vec<Group> = Vec::new();
        let mut if_data: Vec<IfData> = Vec::new();
        let mut instance: Vec<Instance> = Vec::new();
        let mut measurement: Vec<Measurement> = Vec::new();
        let mut mod_common: Option<ModCommon> = None;
        let mut mod_par: Option<ModPar> = None;
        let mut record_layout: Vec<RecordLayout> = Vec::new();
        let mut transformer: Vec<Transformer> = Vec::new();
        let mut typedef_axis: Vec<TypedefAxis> = Vec::new();
        let mut typedef_blob: Vec<TypedefBlob> = Vec::new();
        let mut typedef_characteristic: Vec<TypedefCharacteristic> = Vec::new();
        let mut typedef_measurement: Vec<TypedefMeasurement> = Vec::new();
        let mut typedef_structure: Vec<TypedefStructure> = Vec::new();
        let mut unit: Vec<Unit> = Vec::new();
        let mut user_rights: Vec<UserRights> = Vec::new();
        let mut variant_coding: Option<VariantCoding> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 26usize] = [
                "A2ML",
                "AXIS_PTS",
                "BLOB",
                "CHARACTERISTIC",
                "COMPU_METHOD",
                "COMPU_TAB",
                "COMPU_VTAB",
                "COMPU_VTAB_RANGE",
                "FRAME",
                "FUNCTION",
                "GROUP",
                "IF_DATA",
                "INSTANCE",
                "MEASUREMENT",
                "MOD_COMMON",
                "MOD_PAR",
                "RECORD_LAYOUT",
                "TRANSFORMER",
                "TYPEDEF_AXIS",
                "TYPEDEF_BLOB",
                "TYPEDEF_CHARACTERISTIC",
                "TYPEDEF_MEASUREMENT",
                "TYPEDEF_STRUCTURE",
                "UNIT",
                "USER_RIGHTS",
                "VARIANT_CODING",
            ];
            match tag {
                "A2ML" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = A2ml::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, a2ml.is_some())?;
                    a2ml = Some(newitem);
                }
                "AXIS_PTS" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = AxisPts::parse(parser, &newcontext, line_offset)?;
                    axis_pts.push(newitem);
                }
                "BLOB" => {
                    parser.require_block(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "BLOB", A2lVersion::V1_7_0)?;
                    let newitem = Blob::parse(parser, &newcontext, line_offset)?;
                    blob.push(newitem);
                }
                "CHARACTERISTIC" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Characteristic::parse(parser, &newcontext, line_offset)?;
                    characteristic.push(newitem);
                }
                "COMPU_METHOD" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = CompuMethod::parse(parser, &newcontext, line_offset)?;
                    compu_method.push(newitem);
                }
                "COMPU_TAB" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = CompuTab::parse(parser, &newcontext, line_offset)?;
                    compu_tab.push(newitem);
                }
                "COMPU_VTAB" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = CompuVtab::parse(parser, &newcontext, line_offset)?;
                    compu_vtab.push(newitem);
                }
                "COMPU_VTAB_RANGE" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = CompuVtabRange::parse(parser, &newcontext, line_offset)?;
                    compu_vtab_range.push(newitem);
                }
                "FRAME" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Frame::parse(parser, &newcontext, line_offset)?;
                    frame.push(newitem);
                }
                "FUNCTION" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Function::parse(parser, &newcontext, line_offset)?;
                    function.push(newitem);
                }
                "GROUP" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Group::parse(parser, &newcontext, line_offset)?;
                    group.push(newitem);
                }
                "IF_DATA" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = IfData::parse(parser, &newcontext, line_offset)?;
                    if_data.push(newitem);
                }
                "INSTANCE" => {
                    parser.require_block(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "INSTANCE", A2lVersion::V1_7_0)?;
                    let newitem = Instance::parse(parser, &newcontext, line_offset)?;
                    instance.push(newitem);
                }
                "MEASUREMENT" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Measurement::parse(parser, &newcontext, line_offset)?;
                    measurement.push(newitem);
                }
                "MOD_COMMON" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = ModCommon::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, mod_common.is_some())?;
                    mod_common = Some(newitem);
                }
                "MOD_PAR" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = ModPar::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, mod_par.is_some())?;
                    mod_par = Some(newitem);
                }
                "RECORD_LAYOUT" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = RecordLayout::parse(parser, &newcontext, line_offset)?;
                    record_layout.push(newitem);
                }
                "TRANSFORMER" => {
                    parser.require_block(tag, is_block, context)?;
                    parser.check_block_version_lower(context, "TRANSFORMER", A2lVersion::V1_7_0)?;
                    let newitem = Transformer::parse(parser, &newcontext, line_offset)?;
                    transformer.push(newitem);
                }
                "TYPEDEF_AXIS" => {
                    parser.require_block(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "TYPEDEF_AXIS",
                        A2lVersion::V1_7_0,
                    )?;
                    let newitem = TypedefAxis::parse(parser, &newcontext, line_offset)?;
                    typedef_axis.push(newitem);
                }
                "TYPEDEF_BLOB" => {
                    parser.require_block(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "TYPEDEF_BLOB",
                        A2lVersion::V1_7_0,
                    )?;
                    let newitem = TypedefBlob::parse(parser, &newcontext, line_offset)?;
                    typedef_blob.push(newitem);
                }
                "TYPEDEF_CHARACTERISTIC" => {
                    parser.require_block(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "TYPEDEF_CHARACTERISTIC",
                        A2lVersion::V1_7_0,
                    )?;
                    let newitem = TypedefCharacteristic::parse(parser, &newcontext, line_offset)?;
                    typedef_characteristic.push(newitem);
                }
                "TYPEDEF_MEASUREMENT" => {
                    parser.require_block(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "TYPEDEF_MEASUREMENT",
                        A2lVersion::V1_7_0,
                    )?;
                    let newitem = TypedefMeasurement::parse(parser, &newcontext, line_offset)?;
                    typedef_measurement.push(newitem);
                }
                "TYPEDEF_STRUCTURE" => {
                    parser.require_block(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "TYPEDEF_STRUCTURE",
                        A2lVersion::V1_7_0,
                    )?;
                    let newitem = TypedefStructure::parse(parser, &newcontext, line_offset)?;
                    typedef_structure.push(newitem);
                }
                "UNIT" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Unit::parse(parser, &newcontext, line_offset)?;
                    unit.push(newitem);
                }
                "USER_RIGHTS" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = UserRights::parse(parser, &newcontext, line_offset)?;
                    user_rights.push(newitem);
                }
                "VARIANT_CODING" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = VariantCoding::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, variant_coding.is_some())?;
                    variant_coding = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __long_identifier_location),
            },
            name,
            long_identifier,
            a2ml,
            axis_pts,
            blob,
            characteristic,
            compu_method,
            compu_tab,
            compu_vtab,
            compu_vtab_range,
            frame,
            function,
            group,
            if_data,
            instance,
            measurement,
            mod_common,
            mod_par,
            record_layout,
            transformer,
            typedef_axis,
            typedef_blob,
            typedef_characteristic,
            typedef_measurement,
            typedef_structure,
            unit,
            user_rights,
            variant_coding,
        })
    }
}

impl Module {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(a2ml) = &self.a2ml {
            let a2ml_out = a2ml.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "A2ML",
                item_text: a2ml_out,
                is_block: true,
                incfile: &a2ml.__block_info.incfile,
                uid: a2ml.__block_info.uid,
                line: a2ml.__block_info.line,
                start_offset: a2ml.__block_info.start_offset,
                end_offset: a2ml.__block_info.end_offset,
                position_restriction: a2ml.pos_restrict(),
            });
        }
        for axis_pts in &self.axis_pts {
            let axis_pts_out = axis_pts.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AXIS_PTS",
                item_text: axis_pts_out,
                is_block: true,
                incfile: &axis_pts.__block_info.incfile,
                uid: axis_pts.__block_info.uid,
                line: axis_pts.__block_info.line,
                start_offset: axis_pts.__block_info.start_offset,
                end_offset: axis_pts.__block_info.end_offset,
                position_restriction: axis_pts.pos_restrict(),
            });
        }
        for blob in &self.blob {
            let blob_out = blob.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "BLOB",
                item_text: blob_out,
                is_block: true,
                incfile: &blob.__block_info.incfile,
                uid: blob.__block_info.uid,
                line: blob.__block_info.line,
                start_offset: blob.__block_info.start_offset,
                end_offset: blob.__block_info.end_offset,
                position_restriction: blob.pos_restrict(),
            });
        }
        for characteristic in &self.characteristic {
            let characteristic_out = characteristic.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "CHARACTERISTIC",
                item_text: characteristic_out,
                is_block: true,
                incfile: &characteristic.__block_info.incfile,
                uid: characteristic.__block_info.uid,
                line: characteristic.__block_info.line,
                start_offset: characteristic.__block_info.start_offset,
                end_offset: characteristic.__block_info.end_offset,
                position_restriction: characteristic.pos_restrict(),
            });
        }
        for compu_method in &self.compu_method {
            let compu_method_out = compu_method.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "COMPU_METHOD",
                item_text: compu_method_out,
                is_block: true,
                incfile: &compu_method.__block_info.incfile,
                uid: compu_method.__block_info.uid,
                line: compu_method.__block_info.line,
                start_offset: compu_method.__block_info.start_offset,
                end_offset: compu_method.__block_info.end_offset,
                position_restriction: compu_method.pos_restrict(),
            });
        }
        for compu_tab in &self.compu_tab {
            let compu_tab_out = compu_tab.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "COMPU_TAB",
                item_text: compu_tab_out,
                is_block: true,
                incfile: &compu_tab.__block_info.incfile,
                uid: compu_tab.__block_info.uid,
                line: compu_tab.__block_info.line,
                start_offset: compu_tab.__block_info.start_offset,
                end_offset: compu_tab.__block_info.end_offset,
                position_restriction: compu_tab.pos_restrict(),
            });
        }
        for compu_vtab in &self.compu_vtab {
            let compu_vtab_out = compu_vtab.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "COMPU_VTAB",
                item_text: compu_vtab_out,
                is_block: true,
                incfile: &compu_vtab.__block_info.incfile,
                uid: compu_vtab.__block_info.uid,
                line: compu_vtab.__block_info.line,
                start_offset: compu_vtab.__block_info.start_offset,
                end_offset: compu_vtab.__block_info.end_offset,
                position_restriction: compu_vtab.pos_restrict(),
            });
        }
        for compu_vtab_range in &self.compu_vtab_range {
            let compu_vtab_range_out = compu_vtab_range.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "COMPU_VTAB_RANGE",
                item_text: compu_vtab_range_out,
                is_block: true,
                incfile: &compu_vtab_range.__block_info.incfile,
                uid: compu_vtab_range.__block_info.uid,
                line: compu_vtab_range.__block_info.line,
                start_offset: compu_vtab_range.__block_info.start_offset,
                end_offset: compu_vtab_range.__block_info.end_offset,
                position_restriction: compu_vtab_range.pos_restrict(),
            });
        }
        for frame in &self.frame {
            let frame_out = frame.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FRAME",
                item_text: frame_out,
                is_block: true,
                incfile: &frame.__block_info.incfile,
                uid: frame.__block_info.uid,
                line: frame.__block_info.line,
                start_offset: frame.__block_info.start_offset,
                end_offset: frame.__block_info.end_offset,
                position_restriction: frame.pos_restrict(),
            });
        }
        for function in &self.function {
            let function_out = function.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FUNCTION",
                item_text: function_out,
                is_block: true,
                incfile: &function.__block_info.incfile,
                uid: function.__block_info.uid,
                line: function.__block_info.line,
                start_offset: function.__block_info.start_offset,
                end_offset: function.__block_info.end_offset,
                position_restriction: function.pos_restrict(),
            });
        }
        for group in &self.group {
            let group_out = group.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "GROUP",
                item_text: group_out,
                is_block: true,
                incfile: &group.__block_info.incfile,
                uid: group.__block_info.uid,
                line: group.__block_info.line,
                start_offset: group.__block_info.start_offset,
                end_offset: group.__block_info.end_offset,
                position_restriction: group.pos_restrict(),
            });
        }
        for if_data in &self.if_data {
            let if_data_out = if_data.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "IF_DATA",
                item_text: if_data_out,
                is_block: true,
                incfile: &if_data.__block_info.incfile,
                uid: if_data.__block_info.uid,
                line: if_data.__block_info.line,
                start_offset: if_data.__block_info.start_offset,
                end_offset: if_data.__block_info.end_offset,
                position_restriction: if_data.pos_restrict(),
            });
        }
        for instance in &self.instance {
            let instance_out = instance.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "INSTANCE",
                item_text: instance_out,
                is_block: true,
                incfile: &instance.__block_info.incfile,
                uid: instance.__block_info.uid,
                line: instance.__block_info.line,
                start_offset: instance.__block_info.start_offset,
                end_offset: instance.__block_info.end_offset,
                position_restriction: instance.pos_restrict(),
            });
        }
        for measurement in &self.measurement {
            let measurement_out = measurement.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MEASUREMENT",
                item_text: measurement_out,
                is_block: true,
                incfile: &measurement.__block_info.incfile,
                uid: measurement.__block_info.uid,
                line: measurement.__block_info.line,
                start_offset: measurement.__block_info.start_offset,
                end_offset: measurement.__block_info.end_offset,
                position_restriction: measurement.pos_restrict(),
            });
        }
        if let Some(mod_common) = &self.mod_common {
            let mod_common_out = mod_common.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MOD_COMMON",
                item_text: mod_common_out,
                is_block: true,
                incfile: &mod_common.__block_info.incfile,
                uid: mod_common.__block_info.uid,
                line: mod_common.__block_info.line,
                start_offset: mod_common.__block_info.start_offset,
                end_offset: mod_common.__block_info.end_offset,
                position_restriction: mod_common.pos_restrict(),
            });
        }
        if let Some(mod_par) = &self.mod_par {
            let mod_par_out = mod_par.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MOD_PAR",
                item_text: mod_par_out,
                is_block: true,
                incfile: &mod_par.__block_info.incfile,
                uid: mod_par.__block_info.uid,
                line: mod_par.__block_info.line,
                start_offset: mod_par.__block_info.start_offset,
                end_offset: mod_par.__block_info.end_offset,
                position_restriction: mod_par.pos_restrict(),
            });
        }
        for record_layout in &self.record_layout {
            let record_layout_out = record_layout.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "RECORD_LAYOUT",
                item_text: record_layout_out,
                is_block: true,
                incfile: &record_layout.__block_info.incfile,
                uid: record_layout.__block_info.uid,
                line: record_layout.__block_info.line,
                start_offset: record_layout.__block_info.start_offset,
                end_offset: record_layout.__block_info.end_offset,
                position_restriction: record_layout.pos_restrict(),
            });
        }
        for transformer in &self.transformer {
            let transformer_out = transformer.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "TRANSFORMER",
                item_text: transformer_out,
                is_block: true,
                incfile: &transformer.__block_info.incfile,
                uid: transformer.__block_info.uid,
                line: transformer.__block_info.line,
                start_offset: transformer.__block_info.start_offset,
                end_offset: transformer.__block_info.end_offset,
                position_restriction: transformer.pos_restrict(),
            });
        }
        for typedef_axis in &self.typedef_axis {
            let typedef_axis_out = typedef_axis.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "TYPEDEF_AXIS",
                item_text: typedef_axis_out,
                is_block: true,
                incfile: &typedef_axis.__block_info.incfile,
                uid: typedef_axis.__block_info.uid,
                line: typedef_axis.__block_info.line,
                start_offset: typedef_axis.__block_info.start_offset,
                end_offset: typedef_axis.__block_info.end_offset,
                position_restriction: typedef_axis.pos_restrict(),
            });
        }
        for typedef_blob in &self.typedef_blob {
            let typedef_blob_out = typedef_blob.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "TYPEDEF_BLOB",
                item_text: typedef_blob_out,
                is_block: true,
                incfile: &typedef_blob.__block_info.incfile,
                uid: typedef_blob.__block_info.uid,
                line: typedef_blob.__block_info.line,
                start_offset: typedef_blob.__block_info.start_offset,
                end_offset: typedef_blob.__block_info.end_offset,
                position_restriction: typedef_blob.pos_restrict(),
            });
        }
        for typedef_characteristic in &self.typedef_characteristic {
            let typedef_characteristic_out = typedef_characteristic.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "TYPEDEF_CHARACTERISTIC",
                item_text: typedef_characteristic_out,
                is_block: true,
                incfile: &typedef_characteristic.__block_info.incfile,
                uid: typedef_characteristic.__block_info.uid,
                line: typedef_characteristic.__block_info.line,
                start_offset: typedef_characteristic.__block_info.start_offset,
                end_offset: typedef_characteristic.__block_info.end_offset,
                position_restriction: typedef_characteristic.pos_restrict(),
            });
        }
        for typedef_measurement in &self.typedef_measurement {
            let typedef_measurement_out = typedef_measurement.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "TYPEDEF_MEASUREMENT",
                item_text: typedef_measurement_out,
                is_block: true,
                incfile: &typedef_measurement.__block_info.incfile,
                uid: typedef_measurement.__block_info.uid,
                line: typedef_measurement.__block_info.line,
                start_offset: typedef_measurement.__block_info.start_offset,
                end_offset: typedef_measurement.__block_info.end_offset,
                position_restriction: typedef_measurement.pos_restrict(),
            });
        }
        for typedef_structure in &self.typedef_structure {
            let typedef_structure_out = typedef_structure.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "TYPEDEF_STRUCTURE",
                item_text: typedef_structure_out,
                is_block: true,
                incfile: &typedef_structure.__block_info.incfile,
                uid: typedef_structure.__block_info.uid,
                line: typedef_structure.__block_info.line,
                start_offset: typedef_structure.__block_info.start_offset,
                end_offset: typedef_structure.__block_info.end_offset,
                position_restriction: typedef_structure.pos_restrict(),
            });
        }
        for unit in &self.unit {
            let unit_out = unit.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "UNIT",
                item_text: unit_out,
                is_block: true,
                incfile: &unit.__block_info.incfile,
                uid: unit.__block_info.uid,
                line: unit.__block_info.line,
                start_offset: unit.__block_info.start_offset,
                end_offset: unit.__block_info.end_offset,
                position_restriction: unit.pos_restrict(),
            });
        }
        for user_rights in &self.user_rights {
            let user_rights_out = user_rights.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "USER_RIGHTS",
                item_text: user_rights_out,
                is_block: true,
                incfile: &user_rights.__block_info.incfile,
                uid: user_rights.__block_info.uid,
                line: user_rights.__block_info.line,
                start_offset: user_rights.__block_info.start_offset,
                end_offset: user_rights.__block_info.end_offset,
                position_restriction: user_rights.pos_restrict(),
            });
        }
        if let Some(variant_coding) = &self.variant_coding {
            let variant_coding_out = variant_coding.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "VARIANT_CODING",
                item_text: variant_coding_out,
                is_block: true,
                incfile: &variant_coding.__block_info.incfile,
                uid: variant_coding.__block_info.uid,
                line: variant_coding.__block_info.line,
                start_offset: variant_coding.__block_info.start_offset,
                end_offset: variant_coding.__block_info.end_offset,
                position_restriction: variant_coding.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// specifies the monotony of an adjustment object
#[derive(Clone)]
pub struct Monotony {
    pub monotony: MonotonyType,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for Monotony {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Monotony")
            .field("monotony", &self.monotony)
            .finish()
    }
}

impl Monotony {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(monotony: MonotonyType) -> Self {
        Self {
            monotony,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for Monotony {
    fn eq(&self, other: &Self) -> bool {
        self.monotony == other.monotony
    }
}

impl A2lObject<(u32, ())> for Monotony {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Monotony {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__monotony_location, monotony) = (
            parser.get_current_line_offset(),
            MonotonyType::parse(parser, context, 0)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__monotony_location, __dummy),
            },
            monotony,
        })
    }
}

impl Monotony {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(
            &self.monotony.to_string(),
            self.__block_info.item_location.0,
        );
        writer.finish()
    }
}

/// describes the possible ways an adjustment object can be monotonous
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MonotonyType {
    MonDecrease,
    MonIncrease,
    StrictDecrease,
    StrictIncrease,
    Monotonous,
    StrictMon,
    NotMon,
}

impl ParseableA2lObject for MonotonyType {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "MON_DECREASE" => Ok(Self::MonDecrease),
            "MON_INCREASE" => Ok(Self::MonIncrease),
            "STRICT_DECREASE" => Ok(Self::StrictDecrease),
            "STRICT_INCREASE" => Ok(Self::StrictIncrease),
            "MONOTONOUS" => {
                parser.check_enumitem_version_lower(context, "MONOTONOUS", A2lVersion::V1_6_0)?;
                Ok(Self::Monotonous)
            }
            "STRICT_MON" => {
                parser.check_enumitem_version_lower(context, "STRICT_MON", A2lVersion::V1_6_0)?;
                Ok(Self::StrictMon)
            }
            "NOT_MON" => {
                parser.check_enumitem_version_lower(context, "NOT_MON", A2lVersion::V1_6_0)?;
                Ok(Self::NotMon)
            }
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for MonotonyType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::MonDecrease => "MON_DECREASE",
            Self::MonIncrease => "MON_INCREASE",
            Self::StrictDecrease => "STRICT_DECREASE",
            Self::StrictIncrease => "STRICT_INCREASE",
            Self::Monotonous => "MONOTONOUS",
            Self::StrictMon => "STRICT_MON",
            Self::NotMon => "NOT_MON",
        };
        f.write_str(tag)
    }
}

/// Description of the number of axis points in an adjustable object
#[derive(Clone)]
pub struct NoAxisPtsDim {
    pub position: u16,
    pub datatype: DataType,
    pub(crate) __block_info: BlockInfo<((u32, bool), u32)>,
}

impl std::fmt::Debug for NoAxisPtsDim {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("NoAxisPtsDim")
            .field("position", &self.position)
            .field("datatype", &self.datatype)
            .finish()
    }
}

impl NoAxisPtsDim {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(position: u16, datatype: DataType) -> Self {
        Self {
            position,
            datatype,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), 0u32),
            },
        }
    }
}

impl PartialEq for NoAxisPtsDim {
    fn eq(&self, other: &Self) -> bool {
        (self.position == other.position) && (self.datatype == other.datatype)
    }
}

impl A2lObject<((u32, bool), u32)> for NoAxisPtsDim {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for NoAxisPtsDim {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__position_location, position) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__datatype_location, datatype) = (
            parser.get_current_line_offset(),
            DataType::parse(parser, context, 0)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__position_location, __datatype_location),
            },
            position,
            datatype,
        })
    }
}

impl NoAxisPtsDim {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.position,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_str(
            &self.datatype.to_string(),
            self.__block_info.item_location.1,
        );
        writer.finish()
    }
}

/// the number of interfaces
#[derive(Clone)]
pub struct NoOfInterfaces {
    pub num: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for NoOfInterfaces {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("NoOfInterfaces")
            .field("num", &self.num)
            .finish()
    }
}

impl NoOfInterfaces {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(num: u16) -> Self {
        Self {
            num,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for NoOfInterfaces {
    fn eq(&self, other: &Self) -> bool {
        self.num == other.num
    }
}

impl A2lObject<((u32, bool), ())> for NoOfInterfaces {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for NoOfInterfaces {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__num_location, num) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__num_location, __dummy),
            },
            num,
        })
    }
}

impl NoOfInterfaces {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.num,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// number of rescaling axis point value pairs
#[derive(Clone)]
pub struct NoRescaleDim {
    pub position: u16,
    pub datatype: DataType,
    pub(crate) __block_info: BlockInfo<((u32, bool), u32)>,
}

impl std::fmt::Debug for NoRescaleDim {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("NoRescaleDim")
            .field("position", &self.position)
            .field("datatype", &self.datatype)
            .finish()
    }
}

impl NoRescaleDim {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(position: u16, datatype: DataType) -> Self {
        Self {
            position,
            datatype,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), 0u32),
            },
        }
    }
}

impl PartialEq for NoRescaleDim {
    fn eq(&self, other: &Self) -> bool {
        (self.position == other.position) && (self.datatype == other.datatype)
    }
}

impl A2lObject<((u32, bool), u32)> for NoRescaleDim {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for NoRescaleDim {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__position_location, position) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__datatype_location, datatype) = (
            parser.get_current_line_offset(),
            DataType::parse(parser, context, 0)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__position_location, __datatype_location),
            },
            position,
            datatype,
        })
    }
}

impl NoRescaleDim {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.position,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_str(
            &self.datatype.to_string(),
            self.__block_info.item_location.1,
        );
        writer.finish()
    }
}

/// specifies the number of values in an array. Obsolete, replaced by `MATRIX_DIM`
#[derive(Clone)]
pub struct Number {
    pub number: u16,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for Number {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Number")
            .field("number", &self.number)
            .finish()
    }
}

impl Number {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(number: u16) -> Self {
        Self {
            number,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for Number {
    fn eq(&self, other: &Self) -> bool {
        self.number == other.number
    }
}

impl A2lObject<((u32, bool), ())> for Number {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Number {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__number_location, number) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__number_location, __dummy),
            },
            number,
        })
    }
}

impl Number {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.number,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// Description of the \'offset\' parameter in the deposit structure
#[derive(Clone)]
pub struct OffsetDim {
    pub position: u16,
    pub datatype: DataType,
    pub(crate) __block_info: BlockInfo<((u32, bool), u32)>,
}

impl std::fmt::Debug for OffsetDim {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("OffsetDim")
            .field("position", &self.position)
            .field("datatype", &self.datatype)
            .finish()
    }
}

impl OffsetDim {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(position: u16, datatype: DataType) -> Self {
        Self {
            position,
            datatype,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), 0u32),
            },
        }
    }
}

impl PartialEq for OffsetDim {
    fn eq(&self, other: &Self) -> bool {
        (self.position == other.position) && (self.datatype == other.datatype)
    }
}

impl A2lObject<((u32, bool), u32)> for OffsetDim {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for OffsetDim {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__position_location, position) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__datatype_location, datatype) = (
            parser.get_current_line_offset(),
            DataType::parse(parser, context, 0)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__position_location, __datatype_location),
            },
            position,
            datatype,
        })
    }
}

impl OffsetDim {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.position,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_str(
            &self.datatype.to_string(),
            self.__block_info.item_location.1,
        );
        writer.finish()
    }
}

/// defines output quantities of a function
#[derive(Clone)]
pub struct OutMeasurement {
    pub identifier_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for OutMeasurement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("OutMeasurement")
            .field("identifier_list", &self.identifier_list)
            .finish()
    }
}

impl OutMeasurement {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            identifier_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for OutMeasurement {
    fn eq(&self, other: &Self) -> bool {
        self.identifier_list == other.identifier_list
    }
}

impl A2lObject<(Vec<u32>, ())> for OutMeasurement {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for OutMeasurement {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut identifier_list = Vec::new();
        let mut __identifier_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    identifier_list.push(value);
                    __identifier_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__identifier_list_location, __dummy),
            },
            identifier_list,
        })
    }
}

impl OutMeasurement {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.identifier_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// override some default attributes of a type definition in a specific INSTANCE.
#[derive(Clone)]
pub struct Overwrite {
    pub name: String,
    pub axis_number: u32,
    pub conversion: Option<Conversion>,
    pub extended_limits: Option<ExtendedLimits>,
    pub format: Option<Format>,
    pub input_quantity: Option<InputQuantity>,
    pub limits: Option<Limits>,
    pub monotony: Option<Monotony>,
    pub phys_unit: Option<PhysUnit>,
    pub(crate) __block_info: BlockInfo<(u32, (u32, bool))>,
}

impl std::fmt::Debug for Overwrite {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Overwrite")
            .field("name", &self.name)
            .field("axis_number", &self.axis_number)
            .field("conversion", &self.conversion)
            .field("extended_limits", &self.extended_limits)
            .field("format", &self.format)
            .field("input_quantity", &self.input_quantity)
            .field("limits", &self.limits)
            .field("monotony", &self.monotony)
            .field("phys_unit", &self.phys_unit)
            .finish()
    }
}

impl Overwrite {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String, axis_number: u32) -> Self {
        Self {
            name,
            axis_number,
            conversion: None,
            extended_limits: None,
            format: None,
            input_quantity: None,
            limits: None,
            monotony: None,
            phys_unit: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (1u32, (0u32, false)),
            },
        }
    }
}

impl PartialEq for Overwrite {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.axis_number == other.axis_number)
            && (self.conversion == other.conversion)
            && (self.extended_limits == other.extended_limits)
            && (self.format == other.format)
            && (self.input_quantity == other.input_quantity)
            && (self.limits == other.limits)
            && (self.monotony == other.monotony)
            && (self.phys_unit == other.phys_unit)
    }
}

impl A2lObject<(u32, (u32, bool))> for Overwrite {
    fn get_layout(&self) -> &BlockInfo<(u32, (u32, bool))> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, (u32, bool))> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(conversion) = &mut self.conversion {
            conversion.merge_includes();
        }
        if let Some(extended_limits) = &mut self.extended_limits {
            extended_limits.merge_includes();
        }
        if let Some(format) = &mut self.format {
            format.merge_includes();
        }
        if let Some(input_quantity) = &mut self.input_quantity {
            input_quantity.merge_includes();
        }
        if let Some(limits) = &mut self.limits {
            limits.merge_includes();
        }
        if let Some(monotony) = &mut self.monotony {
            monotony.merge_includes();
        }
        if let Some(phys_unit) = &mut self.phys_unit {
            phys_unit.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for Overwrite {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for Overwrite {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__axis_number_location, axis_number) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let mut conversion: Option<Conversion> = None;
        let mut extended_limits: Option<ExtendedLimits> = None;
        let mut format: Option<Format> = None;
        let mut input_quantity: Option<InputQuantity> = None;
        let mut limits: Option<Limits> = None;
        let mut monotony: Option<Monotony> = None;
        let mut phys_unit: Option<PhysUnit> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 7usize] = [
                "CONVERSION",
                "EXTENDED_LIMITS",
                "FORMAT",
                "INPUT_QUANTITY",
                "LIMITS",
                "MONOTONY",
                "PHYS_UNIT",
            ];
            match tag {
                "CONVERSION" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Conversion::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, conversion.is_some())?;
                    conversion = Some(newitem);
                }
                "EXTENDED_LIMITS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ExtendedLimits::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, extended_limits.is_some())?;
                    extended_limits = Some(newitem);
                }
                "FORMAT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Format::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, format.is_some())?;
                    format = Some(newitem);
                }
                "INPUT_QUANTITY" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = InputQuantity::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, input_quantity.is_some())?;
                    input_quantity = Some(newitem);
                }
                "LIMITS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Limits::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, limits.is_some())?;
                    limits = Some(newitem);
                }
                "MONOTONY" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Monotony::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, monotony.is_some())?;
                    monotony = Some(newitem);
                }
                "PHYS_UNIT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = PhysUnit::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, phys_unit.is_some())?;
                    phys_unit = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __axis_number_location),
            },
            name,
            axis_number,
            conversion,
            extended_limits,
            format,
            input_quantity,
            limits,
            monotony,
            phys_unit,
        })
    }
}

impl Overwrite {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_integer(
            self.axis_number,
            self.__block_info.item_location.1 .1,
            self.__block_info.item_location.1 .0,
        );
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(conversion) = &self.conversion {
            let conversion_out = conversion.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "CONVERSION",
                item_text: conversion_out,
                is_block: false,
                incfile: &conversion.__block_info.incfile,
                uid: conversion.__block_info.uid,
                line: conversion.__block_info.line,
                start_offset: conversion.__block_info.start_offset,
                end_offset: conversion.__block_info.end_offset,
                position_restriction: conversion.pos_restrict(),
            });
        }
        if let Some(extended_limits) = &self.extended_limits {
            let extended_limits_out = extended_limits.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "EXTENDED_LIMITS",
                item_text: extended_limits_out,
                is_block: false,
                incfile: &extended_limits.__block_info.incfile,
                uid: extended_limits.__block_info.uid,
                line: extended_limits.__block_info.line,
                start_offset: extended_limits.__block_info.start_offset,
                end_offset: extended_limits.__block_info.end_offset,
                position_restriction: extended_limits.pos_restrict(),
            });
        }
        if let Some(format) = &self.format {
            let format_out = format.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FORMAT",
                item_text: format_out,
                is_block: false,
                incfile: &format.__block_info.incfile,
                uid: format.__block_info.uid,
                line: format.__block_info.line,
                start_offset: format.__block_info.start_offset,
                end_offset: format.__block_info.end_offset,
                position_restriction: format.pos_restrict(),
            });
        }
        if let Some(input_quantity) = &self.input_quantity {
            let input_quantity_out = input_quantity.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "INPUT_QUANTITY",
                item_text: input_quantity_out,
                is_block: false,
                incfile: &input_quantity.__block_info.incfile,
                uid: input_quantity.__block_info.uid,
                line: input_quantity.__block_info.line,
                start_offset: input_quantity.__block_info.start_offset,
                end_offset: input_quantity.__block_info.end_offset,
                position_restriction: input_quantity.pos_restrict(),
            });
        }
        if let Some(limits) = &self.limits {
            let limits_out = limits.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "LIMITS",
                item_text: limits_out,
                is_block: false,
                incfile: &limits.__block_info.incfile,
                uid: limits.__block_info.uid,
                line: limits.__block_info.line,
                start_offset: limits.__block_info.start_offset,
                end_offset: limits.__block_info.end_offset,
                position_restriction: limits.pos_restrict(),
            });
        }
        if let Some(monotony) = &self.monotony {
            let monotony_out = monotony.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MONOTONY",
                item_text: monotony_out,
                is_block: false,
                incfile: &monotony.__block_info.incfile,
                uid: monotony.__block_info.uid,
                line: monotony.__block_info.line,
                start_offset: monotony.__block_info.start_offset,
                end_offset: monotony.__block_info.end_offset,
                position_restriction: monotony.pos_restrict(),
            });
        }
        if let Some(phys_unit) = &self.phys_unit {
            let phys_unit_out = phys_unit.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "PHYS_UNIT",
                item_text: phys_unit_out,
                is_block: false,
                incfile: &phys_unit.__block_info.incfile,
                uid: phys_unit.__block_info.uid,
                line: phys_unit.__block_info.line,
                start_offset: phys_unit.__block_info.start_offset,
                end_offset: phys_unit.__block_info.end_offset,
                position_restriction: phys_unit.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// contains a phone number, e.g. of the calibration engineer
#[derive(Clone)]
pub struct PhoneNo {
    pub telnum: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for PhoneNo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("PhoneNo")
            .field("telnum", &self.telnum)
            .finish()
    }
}

impl PhoneNo {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(telnum: String) -> Self {
        Self {
            telnum,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for PhoneNo {
    fn eq(&self, other: &Self) -> bool {
        self.telnum == other.telnum
    }
}

impl A2lObject<(u32, ())> for PhoneNo {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for PhoneNo {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__telnum_location, telnum) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__telnum_location, __dummy),
            },
            telnum,
        })
    }
}

impl PhoneNo {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.telnum, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// specifies the physical unit of a measurement or calibration object as a string
#[derive(Clone)]
pub struct PhysUnit {
    pub unit: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for PhysUnit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("PhysUnit")
            .field("unit", &self.unit)
            .finish()
    }
}

impl PhysUnit {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(unit: String) -> Self {
        Self {
            unit,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for PhysUnit {
    fn eq(&self, other: &Self) -> bool {
        self.unit == other.unit
    }
}

impl A2lObject<(u32, ())> for PhysUnit {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for PhysUnit {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__unit_location, unit) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__unit_location, __dummy),
            },
            unit,
        })
    }
}

impl PhysUnit {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.unit, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Describes the types of data in the ECU program
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PrgType {
    CalibrationVariables,
    Code,
    Data,
    ExcludeFromFlash,
    OfflineData,
    Reserved,
    Seram,
    Variables,
}

impl ParseableA2lObject for PrgType {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "CALIBRATION_VARIABLES" => Ok(Self::CalibrationVariables),
            "CODE" => Ok(Self::Code),
            "DATA" => Ok(Self::Data),
            "EXCLUDE_FROM_FLASH" => Ok(Self::ExcludeFromFlash),
            "OFFLINE_DATA" => Ok(Self::OfflineData),
            "RESERVED" => Ok(Self::Reserved),
            "SERAM" => Ok(Self::Seram),
            "VARIABLES" => Ok(Self::Variables),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for PrgType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::CalibrationVariables => "CALIBRATION_VARIABLES",
            Self::Code => "CODE",
            Self::Data => "DATA",
            Self::ExcludeFromFlash => "EXCLUDE_FROM_FLASH",
            Self::OfflineData => "OFFLINE_DATA",
            Self::Reserved => "RESERVED",
            Self::Seram => "SERAM",
            Self::Variables => "VARIABLES",
        };
        f.write_str(tag)
    }
}

/// describes the types of program segments
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ProgType {
    PrgCode,
    PrgData,
    PrgReserved,
}

impl ParseableA2lObject for ProgType {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "PRG_CODE" => Ok(Self::PrgCode),
            "PRG_DATA" => Ok(Self::PrgData),
            "PRG_RESERVED" => Ok(Self::PrgReserved),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for ProgType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::PrgCode => "PRG_CODE",
            Self::PrgData => "PRG_DATA",
            Self::PrgReserved => "PRG_RESERVED",
        };
        f.write_str(tag)
    }
}

/// Project description with project header and all modules belonging to the project. Required.
#[derive(Clone)]
pub struct Project {
    pub name: String,
    pub long_identifier: String,
    pub header: Option<Header>,
    pub module: Vec<Module>,
    pub(crate) __block_info: BlockInfo<(u32, u32)>,
}

impl std::fmt::Debug for Project {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Project")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("header", &self.header)
            .field("module", &self.module)
            .finish()
    }
}

impl Project {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String, long_identifier: String) -> Self {
        Self {
            name,
            long_identifier,
            header: None,
            module: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32),
            },
        }
    }
}

impl PartialEq for Project {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.header == other.header)
            && (self.module == other.module)
    }
}

impl A2lObject<(u32, u32)> for Project {
    fn get_layout(&self) -> &BlockInfo<(u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(header) = &mut self.header {
            header.merge_includes();
        }
        for module in &mut self.module {
            module.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for Project {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for Project {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let mut header: Option<Header> = None;
        let mut module: Vec<Module> = Vec::new();
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 2usize] = ["HEADER", "MODULE"];
            match tag {
                "HEADER" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Header::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, header.is_some())?;
                    header = Some(newitem);
                }
                "MODULE" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = Module::parse(parser, &newcontext, line_offset)?;
                    module.push(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        if module.is_empty() {
            parser.error_or_log(ParserError::InvalidMultiplicityNotPresent {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                tag: "MODULE".to_string(),
                block: context.element.clone(),
                block_line: context.line,
            })?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __long_identifier_location),
            },
            name,
            long_identifier,
            header,
            module,
        })
    }
}

impl Project {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(header) = &self.header {
            let header_out = header.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "HEADER",
                item_text: header_out,
                is_block: true,
                incfile: &header.__block_info.incfile,
                uid: header.__block_info.uid,
                line: header.__block_info.line,
                start_offset: header.__block_info.start_offset,
                end_offset: header.__block_info.end_offset,
                position_restriction: header.pos_restrict(),
            });
        }
        for module in &self.module {
            let module_out = module.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MODULE",
                item_text: module_out,
                is_block: true,
                incfile: &module.__block_info.incfile,
                uid: module.__block_info.uid,
                line: module.__block_info.line,
                start_offset: module.__block_info.start_offset,
                end_offset: module.__block_info.end_offset,
                position_restriction: module.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Gives the project identifier
#[derive(Clone)]
pub struct ProjectNo {
    pub project_number: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for ProjectNo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ProjectNo")
            .field("project_number", &self.project_number)
            .finish()
    }
}

impl ProjectNo {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(project_number: String) -> Self {
        Self {
            project_number,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for ProjectNo {
    fn eq(&self, other: &Self) -> bool {
        self.project_number == other.project_number
    }
}

impl A2lObject<(u32, ())> for ProjectNo {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for ProjectNo {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__project_number_location, project_number) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__project_number_location, __dummy),
            },
            project_number,
        })
    }
}

impl ProjectNo {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.project_number, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// used to indicate that an adjustable object is read-only
#[derive(Clone)]
pub struct ReadOnly {
    pub(crate) __block_info: BlockInfo<()>,
}

impl std::fmt::Debug for ReadOnly {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ReadOnly").finish()
    }
}

impl ReadOnly {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (),
            },
        }
    }
}

impl PartialEq for ReadOnly {
    fn eq(&self, _other: &Self) -> bool {
        true
    }
}

impl A2lObject<()> for ReadOnly {
    fn get_layout(&self) -> &BlockInfo<()> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<()> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for ReadOnly {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (),
            },
        })
    }
}

impl ReadOnly {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let writer = writer::Writer::new(indent);
        writer.finish()
    }
}

/// used to indicate that a measurement object is writeable
#[derive(Clone)]
pub struct ReadWrite {
    pub(crate) __block_info: BlockInfo<()>,
}

impl std::fmt::Debug for ReadWrite {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ReadWrite").finish()
    }
}

impl ReadWrite {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (),
            },
        }
    }
}

impl PartialEq for ReadWrite {
    fn eq(&self, _other: &Self) -> bool {
        true
    }
}

impl A2lObject<()> for ReadWrite {
    fn get_layout(&self) -> &BlockInfo<()> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<()> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for ReadWrite {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (),
            },
        })
    }
}

impl ReadWrite {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let writer = writer::Writer::new(indent);
        writer.finish()
    }
}

/// specifies the various data structures of an adjustable objects in memory
#[derive(Clone)]
pub struct RecordLayout {
    pub name: String,
    pub alignment_byte: Option<AlignmentByte>,
    pub alignment_float16_ieee: Option<AlignmentFloat16Ieee>,
    pub alignment_float32_ieee: Option<AlignmentFloat32Ieee>,
    pub alignment_float64_ieee: Option<AlignmentFloat64Ieee>,
    pub alignment_int64: Option<AlignmentInt64>,
    pub alignment_long: Option<AlignmentLong>,
    pub alignment_word: Option<AlignmentWord>,
    pub axis_pts_x: Option<AxisPtsDim>,
    pub axis_pts_y: Option<AxisPtsDim>,
    pub axis_pts_z: Option<AxisPtsDim>,
    pub axis_pts_4: Option<AxisPtsDim>,
    pub axis_pts_5: Option<AxisPtsDim>,
    pub axis_rescale_x: Option<AxisRescaleDim>,
    pub axis_rescale_y: Option<AxisRescaleDim>,
    pub axis_rescale_z: Option<AxisRescaleDim>,
    pub axis_rescale_4: Option<AxisRescaleDim>,
    pub axis_rescale_5: Option<AxisRescaleDim>,
    pub dist_op_x: Option<DistOpDim>,
    pub dist_op_y: Option<DistOpDim>,
    pub dist_op_z: Option<DistOpDim>,
    pub dist_op_4: Option<DistOpDim>,
    pub dist_op_5: Option<DistOpDim>,
    pub fix_no_axis_pts_x: Option<FixNoAxisPtsDim>,
    pub fix_no_axis_pts_y: Option<FixNoAxisPtsDim>,
    pub fix_no_axis_pts_z: Option<FixNoAxisPtsDim>,
    pub fix_no_axis_pts_4: Option<FixNoAxisPtsDim>,
    pub fix_no_axis_pts_5: Option<FixNoAxisPtsDim>,
    pub fnc_values: Option<FncValues>,
    pub identification: Option<Identification>,
    pub no_axis_pts_x: Option<NoAxisPtsDim>,
    pub no_axis_pts_y: Option<NoAxisPtsDim>,
    pub no_axis_pts_z: Option<NoAxisPtsDim>,
    pub no_axis_pts_4: Option<NoAxisPtsDim>,
    pub no_axis_pts_5: Option<NoAxisPtsDim>,
    pub no_rescale_x: Option<NoRescaleDim>,
    pub no_rescale_y: Option<NoRescaleDim>,
    pub no_rescale_z: Option<NoRescaleDim>,
    pub no_rescale_4: Option<NoRescaleDim>,
    pub no_rescale_5: Option<NoRescaleDim>,
    pub offset_x: Option<OffsetDim>,
    pub offset_y: Option<OffsetDim>,
    pub offset_z: Option<OffsetDim>,
    pub offset_4: Option<OffsetDim>,
    pub offset_5: Option<OffsetDim>,
    pub reserved: Vec<Reserved>,
    pub rip_addr_w: Option<RipAddrDim>,
    pub rip_addr_x: Option<RipAddrDim>,
    pub rip_addr_y: Option<RipAddrDim>,
    pub rip_addr_z: Option<RipAddrDim>,
    pub rip_addr_4: Option<RipAddrDim>,
    pub rip_addr_5: Option<RipAddrDim>,
    pub src_addr_x: Option<SrcAddrDim>,
    pub src_addr_y: Option<SrcAddrDim>,
    pub src_addr_z: Option<SrcAddrDim>,
    pub src_addr_4: Option<SrcAddrDim>,
    pub src_addr_5: Option<SrcAddrDim>,
    pub shift_op_x: Option<ShiftOpDim>,
    pub shift_op_y: Option<ShiftOpDim>,
    pub shift_op_z: Option<ShiftOpDim>,
    pub shift_op_4: Option<ShiftOpDim>,
    pub shift_op_5: Option<ShiftOpDim>,
    pub static_record_layout: Option<StaticRecordLayout>,
    pub static_address_offsets: Option<StaticAddressOffsets>,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for RecordLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("RecordLayout")
            .field("name", &self.name)
            .field("alignment_byte", &self.alignment_byte)
            .field("alignment_float16_ieee", &self.alignment_float16_ieee)
            .field("alignment_float32_ieee", &self.alignment_float32_ieee)
            .field("alignment_float64_ieee", &self.alignment_float64_ieee)
            .field("alignment_int64", &self.alignment_int64)
            .field("alignment_long", &self.alignment_long)
            .field("alignment_word", &self.alignment_word)
            .field("axis_pts_x", &self.axis_pts_x)
            .field("axis_pts_y", &self.axis_pts_y)
            .field("axis_pts_z", &self.axis_pts_z)
            .field("axis_pts_4", &self.axis_pts_4)
            .field("axis_pts_5", &self.axis_pts_5)
            .field("axis_rescale_x", &self.axis_rescale_x)
            .field("axis_rescale_y", &self.axis_rescale_y)
            .field("axis_rescale_z", &self.axis_rescale_z)
            .field("axis_rescale_4", &self.axis_rescale_4)
            .field("axis_rescale_5", &self.axis_rescale_5)
            .field("dist_op_x", &self.dist_op_x)
            .field("dist_op_y", &self.dist_op_y)
            .field("dist_op_z", &self.dist_op_z)
            .field("dist_op_4", &self.dist_op_4)
            .field("dist_op_5", &self.dist_op_5)
            .field("fix_no_axis_pts_x", &self.fix_no_axis_pts_x)
            .field("fix_no_axis_pts_y", &self.fix_no_axis_pts_y)
            .field("fix_no_axis_pts_z", &self.fix_no_axis_pts_z)
            .field("fix_no_axis_pts_4", &self.fix_no_axis_pts_4)
            .field("fix_no_axis_pts_5", &self.fix_no_axis_pts_5)
            .field("fnc_values", &self.fnc_values)
            .field("identification", &self.identification)
            .field("no_axis_pts_x", &self.no_axis_pts_x)
            .field("no_axis_pts_y", &self.no_axis_pts_y)
            .field("no_axis_pts_z", &self.no_axis_pts_z)
            .field("no_axis_pts_4", &self.no_axis_pts_4)
            .field("no_axis_pts_5", &self.no_axis_pts_5)
            .field("no_rescale_x", &self.no_rescale_x)
            .field("no_rescale_y", &self.no_rescale_y)
            .field("no_rescale_z", &self.no_rescale_z)
            .field("no_rescale_4", &self.no_rescale_4)
            .field("no_rescale_5", &self.no_rescale_5)
            .field("offset_x", &self.offset_x)
            .field("offset_y", &self.offset_y)
            .field("offset_z", &self.offset_z)
            .field("offset_4", &self.offset_4)
            .field("offset_5", &self.offset_5)
            .field("reserved", &self.reserved)
            .field("rip_addr_w", &self.rip_addr_w)
            .field("rip_addr_x", &self.rip_addr_x)
            .field("rip_addr_y", &self.rip_addr_y)
            .field("rip_addr_z", &self.rip_addr_z)
            .field("rip_addr_4", &self.rip_addr_4)
            .field("rip_addr_5", &self.rip_addr_5)
            .field("src_addr_x", &self.src_addr_x)
            .field("src_addr_y", &self.src_addr_y)
            .field("src_addr_z", &self.src_addr_z)
            .field("src_addr_4", &self.src_addr_4)
            .field("src_addr_5", &self.src_addr_5)
            .field("shift_op_x", &self.shift_op_x)
            .field("shift_op_y", &self.shift_op_y)
            .field("shift_op_z", &self.shift_op_z)
            .field("shift_op_4", &self.shift_op_4)
            .field("shift_op_5", &self.shift_op_5)
            .field("static_record_layout", &self.static_record_layout)
            .field("static_address_offsets", &self.static_address_offsets)
            .finish()
    }
}

impl RecordLayout {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String) -> Self {
        Self {
            name,
            alignment_byte: None,
            alignment_float16_ieee: None,
            alignment_float32_ieee: None,
            alignment_float64_ieee: None,
            alignment_int64: None,
            alignment_long: None,
            alignment_word: None,
            axis_pts_x: None,
            axis_pts_y: None,
            axis_pts_z: None,
            axis_pts_4: None,
            axis_pts_5: None,
            axis_rescale_x: None,
            axis_rescale_y: None,
            axis_rescale_z: None,
            axis_rescale_4: None,
            axis_rescale_5: None,
            dist_op_x: None,
            dist_op_y: None,
            dist_op_z: None,
            dist_op_4: None,
            dist_op_5: None,
            fix_no_axis_pts_x: None,
            fix_no_axis_pts_y: None,
            fix_no_axis_pts_z: None,
            fix_no_axis_pts_4: None,
            fix_no_axis_pts_5: None,
            fnc_values: None,
            identification: None,
            no_axis_pts_x: None,
            no_axis_pts_y: None,
            no_axis_pts_z: None,
            no_axis_pts_4: None,
            no_axis_pts_5: None,
            no_rescale_x: None,
            no_rescale_y: None,
            no_rescale_z: None,
            no_rescale_4: None,
            no_rescale_5: None,
            offset_x: None,
            offset_y: None,
            offset_z: None,
            offset_4: None,
            offset_5: None,
            reserved: Vec::new(),
            rip_addr_w: None,
            rip_addr_x: None,
            rip_addr_y: None,
            rip_addr_z: None,
            rip_addr_4: None,
            rip_addr_5: None,
            src_addr_x: None,
            src_addr_y: None,
            src_addr_z: None,
            src_addr_4: None,
            src_addr_5: None,
            shift_op_x: None,
            shift_op_y: None,
            shift_op_z: None,
            shift_op_4: None,
            shift_op_5: None,
            static_record_layout: None,
            static_address_offsets: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (1u32, ()),
            },
        }
    }
}

impl PartialEq for RecordLayout {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.alignment_byte == other.alignment_byte)
            && (self.alignment_float16_ieee == other.alignment_float16_ieee)
            && (self.alignment_float32_ieee == other.alignment_float32_ieee)
            && (self.alignment_float64_ieee == other.alignment_float64_ieee)
            && (self.alignment_int64 == other.alignment_int64)
            && (self.alignment_long == other.alignment_long)
            && (self.alignment_word == other.alignment_word)
            && (self.axis_pts_x == other.axis_pts_x)
            && (self.axis_pts_y == other.axis_pts_y)
            && (self.axis_pts_z == other.axis_pts_z)
            && (self.axis_pts_4 == other.axis_pts_4)
            && (self.axis_pts_5 == other.axis_pts_5)
            && (self.axis_rescale_x == other.axis_rescale_x)
            && (self.axis_rescale_y == other.axis_rescale_y)
            && (self.axis_rescale_z == other.axis_rescale_z)
            && (self.axis_rescale_4 == other.axis_rescale_4)
            && (self.axis_rescale_5 == other.axis_rescale_5)
            && (self.dist_op_x == other.dist_op_x)
            && (self.dist_op_y == other.dist_op_y)
            && (self.dist_op_z == other.dist_op_z)
            && (self.dist_op_4 == other.dist_op_4)
            && (self.dist_op_5 == other.dist_op_5)
            && (self.fix_no_axis_pts_x == other.fix_no_axis_pts_x)
            && (self.fix_no_axis_pts_y == other.fix_no_axis_pts_y)
            && (self.fix_no_axis_pts_z == other.fix_no_axis_pts_z)
            && (self.fix_no_axis_pts_4 == other.fix_no_axis_pts_4)
            && (self.fix_no_axis_pts_5 == other.fix_no_axis_pts_5)
            && (self.fnc_values == other.fnc_values)
            && (self.identification == other.identification)
            && (self.no_axis_pts_x == other.no_axis_pts_x)
            && (self.no_axis_pts_y == other.no_axis_pts_y)
            && (self.no_axis_pts_z == other.no_axis_pts_z)
            && (self.no_axis_pts_4 == other.no_axis_pts_4)
            && (self.no_axis_pts_5 == other.no_axis_pts_5)
            && (self.no_rescale_x == other.no_rescale_x)
            && (self.no_rescale_y == other.no_rescale_y)
            && (self.no_rescale_z == other.no_rescale_z)
            && (self.no_rescale_4 == other.no_rescale_4)
            && (self.no_rescale_5 == other.no_rescale_5)
            && (self.offset_x == other.offset_x)
            && (self.offset_y == other.offset_y)
            && (self.offset_z == other.offset_z)
            && (self.offset_4 == other.offset_4)
            && (self.offset_5 == other.offset_5)
            && (self.reserved == other.reserved)
            && (self.rip_addr_w == other.rip_addr_w)
            && (self.rip_addr_x == other.rip_addr_x)
            && (self.rip_addr_y == other.rip_addr_y)
            && (self.rip_addr_z == other.rip_addr_z)
            && (self.rip_addr_4 == other.rip_addr_4)
            && (self.rip_addr_5 == other.rip_addr_5)
            && (self.src_addr_x == other.src_addr_x)
            && (self.src_addr_y == other.src_addr_y)
            && (self.src_addr_z == other.src_addr_z)
            && (self.src_addr_4 == other.src_addr_4)
            && (self.src_addr_5 == other.src_addr_5)
            && (self.shift_op_x == other.shift_op_x)
            && (self.shift_op_y == other.shift_op_y)
            && (self.shift_op_z == other.shift_op_z)
            && (self.shift_op_4 == other.shift_op_4)
            && (self.shift_op_5 == other.shift_op_5)
            && (self.static_record_layout == other.static_record_layout)
            && (self.static_address_offsets == other.static_address_offsets)
    }
}

impl A2lObject<(u32, ())> for RecordLayout {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(alignment_byte) = &mut self.alignment_byte {
            alignment_byte.merge_includes();
        }
        if let Some(alignment_float16_ieee) = &mut self.alignment_float16_ieee {
            alignment_float16_ieee.merge_includes();
        }
        if let Some(alignment_float32_ieee) = &mut self.alignment_float32_ieee {
            alignment_float32_ieee.merge_includes();
        }
        if let Some(alignment_float64_ieee) = &mut self.alignment_float64_ieee {
            alignment_float64_ieee.merge_includes();
        }
        if let Some(alignment_int64) = &mut self.alignment_int64 {
            alignment_int64.merge_includes();
        }
        if let Some(alignment_long) = &mut self.alignment_long {
            alignment_long.merge_includes();
        }
        if let Some(alignment_word) = &mut self.alignment_word {
            alignment_word.merge_includes();
        }
        if let Some(axis_pts_x) = &mut self.axis_pts_x {
            axis_pts_x.merge_includes();
        }
        if let Some(axis_pts_y) = &mut self.axis_pts_y {
            axis_pts_y.merge_includes();
        }
        if let Some(axis_pts_z) = &mut self.axis_pts_z {
            axis_pts_z.merge_includes();
        }
        if let Some(axis_pts_4) = &mut self.axis_pts_4 {
            axis_pts_4.merge_includes();
        }
        if let Some(axis_pts_5) = &mut self.axis_pts_5 {
            axis_pts_5.merge_includes();
        }
        if let Some(axis_rescale_x) = &mut self.axis_rescale_x {
            axis_rescale_x.merge_includes();
        }
        if let Some(axis_rescale_y) = &mut self.axis_rescale_y {
            axis_rescale_y.merge_includes();
        }
        if let Some(axis_rescale_z) = &mut self.axis_rescale_z {
            axis_rescale_z.merge_includes();
        }
        if let Some(axis_rescale_4) = &mut self.axis_rescale_4 {
            axis_rescale_4.merge_includes();
        }
        if let Some(axis_rescale_5) = &mut self.axis_rescale_5 {
            axis_rescale_5.merge_includes();
        }
        if let Some(dist_op_x) = &mut self.dist_op_x {
            dist_op_x.merge_includes();
        }
        if let Some(dist_op_y) = &mut self.dist_op_y {
            dist_op_y.merge_includes();
        }
        if let Some(dist_op_z) = &mut self.dist_op_z {
            dist_op_z.merge_includes();
        }
        if let Some(dist_op_4) = &mut self.dist_op_4 {
            dist_op_4.merge_includes();
        }
        if let Some(dist_op_5) = &mut self.dist_op_5 {
            dist_op_5.merge_includes();
        }
        if let Some(fix_no_axis_pts_x) = &mut self.fix_no_axis_pts_x {
            fix_no_axis_pts_x.merge_includes();
        }
        if let Some(fix_no_axis_pts_y) = &mut self.fix_no_axis_pts_y {
            fix_no_axis_pts_y.merge_includes();
        }
        if let Some(fix_no_axis_pts_z) = &mut self.fix_no_axis_pts_z {
            fix_no_axis_pts_z.merge_includes();
        }
        if let Some(fix_no_axis_pts_4) = &mut self.fix_no_axis_pts_4 {
            fix_no_axis_pts_4.merge_includes();
        }
        if let Some(fix_no_axis_pts_5) = &mut self.fix_no_axis_pts_5 {
            fix_no_axis_pts_5.merge_includes();
        }
        if let Some(fnc_values) = &mut self.fnc_values {
            fnc_values.merge_includes();
        }
        if let Some(identification) = &mut self.identification {
            identification.merge_includes();
        }
        if let Some(no_axis_pts_x) = &mut self.no_axis_pts_x {
            no_axis_pts_x.merge_includes();
        }
        if let Some(no_axis_pts_y) = &mut self.no_axis_pts_y {
            no_axis_pts_y.merge_includes();
        }
        if let Some(no_axis_pts_z) = &mut self.no_axis_pts_z {
            no_axis_pts_z.merge_includes();
        }
        if let Some(no_axis_pts_4) = &mut self.no_axis_pts_4 {
            no_axis_pts_4.merge_includes();
        }
        if let Some(no_axis_pts_5) = &mut self.no_axis_pts_5 {
            no_axis_pts_5.merge_includes();
        }
        if let Some(no_rescale_x) = &mut self.no_rescale_x {
            no_rescale_x.merge_includes();
        }
        if let Some(no_rescale_y) = &mut self.no_rescale_y {
            no_rescale_y.merge_includes();
        }
        if let Some(no_rescale_z) = &mut self.no_rescale_z {
            no_rescale_z.merge_includes();
        }
        if let Some(no_rescale_4) = &mut self.no_rescale_4 {
            no_rescale_4.merge_includes();
        }
        if let Some(no_rescale_5) = &mut self.no_rescale_5 {
            no_rescale_5.merge_includes();
        }
        if let Some(offset_x) = &mut self.offset_x {
            offset_x.merge_includes();
        }
        if let Some(offset_y) = &mut self.offset_y {
            offset_y.merge_includes();
        }
        if let Some(offset_z) = &mut self.offset_z {
            offset_z.merge_includes();
        }
        if let Some(offset_4) = &mut self.offset_4 {
            offset_4.merge_includes();
        }
        if let Some(offset_5) = &mut self.offset_5 {
            offset_5.merge_includes();
        }
        for reserved in &mut self.reserved {
            reserved.merge_includes();
        }
        if let Some(rip_addr_w) = &mut self.rip_addr_w {
            rip_addr_w.merge_includes();
        }
        if let Some(rip_addr_x) = &mut self.rip_addr_x {
            rip_addr_x.merge_includes();
        }
        if let Some(rip_addr_y) = &mut self.rip_addr_y {
            rip_addr_y.merge_includes();
        }
        if let Some(rip_addr_z) = &mut self.rip_addr_z {
            rip_addr_z.merge_includes();
        }
        if let Some(rip_addr_4) = &mut self.rip_addr_4 {
            rip_addr_4.merge_includes();
        }
        if let Some(rip_addr_5) = &mut self.rip_addr_5 {
            rip_addr_5.merge_includes();
        }
        if let Some(src_addr_x) = &mut self.src_addr_x {
            src_addr_x.merge_includes();
        }
        if let Some(src_addr_y) = &mut self.src_addr_y {
            src_addr_y.merge_includes();
        }
        if let Some(src_addr_z) = &mut self.src_addr_z {
            src_addr_z.merge_includes();
        }
        if let Some(src_addr_4) = &mut self.src_addr_4 {
            src_addr_4.merge_includes();
        }
        if let Some(src_addr_5) = &mut self.src_addr_5 {
            src_addr_5.merge_includes();
        }
        if let Some(shift_op_x) = &mut self.shift_op_x {
            shift_op_x.merge_includes();
        }
        if let Some(shift_op_y) = &mut self.shift_op_y {
            shift_op_y.merge_includes();
        }
        if let Some(shift_op_z) = &mut self.shift_op_z {
            shift_op_z.merge_includes();
        }
        if let Some(shift_op_4) = &mut self.shift_op_4 {
            shift_op_4.merge_includes();
        }
        if let Some(shift_op_5) = &mut self.shift_op_5 {
            shift_op_5.merge_includes();
        }
        if let Some(static_record_layout) = &mut self.static_record_layout {
            static_record_layout.merge_includes();
        }
        if let Some(static_address_offsets) = &mut self.static_address_offsets {
            static_address_offsets.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for RecordLayout {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for RecordLayout {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let mut alignment_byte: Option<AlignmentByte> = None;
        let mut alignment_float16_ieee: Option<AlignmentFloat16Ieee> = None;
        let mut alignment_float32_ieee: Option<AlignmentFloat32Ieee> = None;
        let mut alignment_float64_ieee: Option<AlignmentFloat64Ieee> = None;
        let mut alignment_int64: Option<AlignmentInt64> = None;
        let mut alignment_long: Option<AlignmentLong> = None;
        let mut alignment_word: Option<AlignmentWord> = None;
        let mut axis_pts_x: Option<AxisPtsDim> = None;
        let mut axis_pts_y: Option<AxisPtsDim> = None;
        let mut axis_pts_z: Option<AxisPtsDim> = None;
        let mut axis_pts_4: Option<AxisPtsDim> = None;
        let mut axis_pts_5: Option<AxisPtsDim> = None;
        let mut axis_rescale_x: Option<AxisRescaleDim> = None;
        let mut axis_rescale_y: Option<AxisRescaleDim> = None;
        let mut axis_rescale_z: Option<AxisRescaleDim> = None;
        let mut axis_rescale_4: Option<AxisRescaleDim> = None;
        let mut axis_rescale_5: Option<AxisRescaleDim> = None;
        let mut dist_op_x: Option<DistOpDim> = None;
        let mut dist_op_y: Option<DistOpDim> = None;
        let mut dist_op_z: Option<DistOpDim> = None;
        let mut dist_op_4: Option<DistOpDim> = None;
        let mut dist_op_5: Option<DistOpDim> = None;
        let mut fix_no_axis_pts_x: Option<FixNoAxisPtsDim> = None;
        let mut fix_no_axis_pts_y: Option<FixNoAxisPtsDim> = None;
        let mut fix_no_axis_pts_z: Option<FixNoAxisPtsDim> = None;
        let mut fix_no_axis_pts_4: Option<FixNoAxisPtsDim> = None;
        let mut fix_no_axis_pts_5: Option<FixNoAxisPtsDim> = None;
        let mut fnc_values: Option<FncValues> = None;
        let mut identification: Option<Identification> = None;
        let mut no_axis_pts_x: Option<NoAxisPtsDim> = None;
        let mut no_axis_pts_y: Option<NoAxisPtsDim> = None;
        let mut no_axis_pts_z: Option<NoAxisPtsDim> = None;
        let mut no_axis_pts_4: Option<NoAxisPtsDim> = None;
        let mut no_axis_pts_5: Option<NoAxisPtsDim> = None;
        let mut no_rescale_x: Option<NoRescaleDim> = None;
        let mut no_rescale_y: Option<NoRescaleDim> = None;
        let mut no_rescale_z: Option<NoRescaleDim> = None;
        let mut no_rescale_4: Option<NoRescaleDim> = None;
        let mut no_rescale_5: Option<NoRescaleDim> = None;
        let mut offset_x: Option<OffsetDim> = None;
        let mut offset_y: Option<OffsetDim> = None;
        let mut offset_z: Option<OffsetDim> = None;
        let mut offset_4: Option<OffsetDim> = None;
        let mut offset_5: Option<OffsetDim> = None;
        let mut reserved: Vec<Reserved> = Vec::new();
        let mut rip_addr_w: Option<RipAddrDim> = None;
        let mut rip_addr_x: Option<RipAddrDim> = None;
        let mut rip_addr_y: Option<RipAddrDim> = None;
        let mut rip_addr_z: Option<RipAddrDim> = None;
        let mut rip_addr_4: Option<RipAddrDim> = None;
        let mut rip_addr_5: Option<RipAddrDim> = None;
        let mut src_addr_x: Option<SrcAddrDim> = None;
        let mut src_addr_y: Option<SrcAddrDim> = None;
        let mut src_addr_z: Option<SrcAddrDim> = None;
        let mut src_addr_4: Option<SrcAddrDim> = None;
        let mut src_addr_5: Option<SrcAddrDim> = None;
        let mut shift_op_x: Option<ShiftOpDim> = None;
        let mut shift_op_y: Option<ShiftOpDim> = None;
        let mut shift_op_z: Option<ShiftOpDim> = None;
        let mut shift_op_4: Option<ShiftOpDim> = None;
        let mut shift_op_5: Option<ShiftOpDim> = None;
        let mut static_record_layout: Option<StaticRecordLayout> = None;
        let mut static_address_offsets: Option<StaticAddressOffsets> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 63usize] = [
                "ALIGNMENT_BYTE",
                "ALIGNMENT_FLOAT16_IEEE",
                "ALIGNMENT_FLOAT32_IEEE",
                "ALIGNMENT_FLOAT64_IEEE",
                "ALIGNMENT_INT64",
                "ALIGNMENT_LONG",
                "ALIGNMENT_WORD",
                "AXIS_PTS_X",
                "AXIS_PTS_Y",
                "AXIS_PTS_Z",
                "AXIS_PTS_4",
                "AXIS_PTS_5",
                "AXIS_RESCALE_X",
                "AXIS_RESCALE_Y",
                "AXIS_RESCALE_Z",
                "AXIS_RESCALE_4",
                "AXIS_RESCALE_5",
                "DIST_OP_X",
                "DIST_OP_Y",
                "DIST_OP_Z",
                "DIST_OP_4",
                "DIST_OP_5",
                "FIX_NO_AXIS_PTS_X",
                "FIX_NO_AXIS_PTS_Y",
                "FIX_NO_AXIS_PTS_Z",
                "FIX_NO_AXIS_PTS_4",
                "FIX_NO_AXIS_PTS_5",
                "FNC_VALUES",
                "IDENTIFICATION",
                "NO_AXIS_PTS_X",
                "NO_AXIS_PTS_Y",
                "NO_AXIS_PTS_Z",
                "NO_AXIS_PTS_4",
                "NO_AXIS_PTS_5",
                "NO_RESCALE_X",
                "NO_RESCALE_Y",
                "NO_RESCALE_Z",
                "NO_RESCALE_4",
                "NO_RESCALE_5",
                "OFFSET_X",
                "OFFSET_Y",
                "OFFSET_Z",
                "OFFSET_4",
                "OFFSET_5",
                "RESERVED",
                "RIP_ADDR_W",
                "RIP_ADDR_X",
                "RIP_ADDR_Y",
                "RIP_ADDR_Z",
                "RIP_ADDR_4",
                "RIP_ADDR_5",
                "SRC_ADDR_X",
                "SRC_ADDR_Y",
                "SRC_ADDR_Z",
                "SRC_ADDR_4",
                "SRC_ADDR_5",
                "SHIFT_OP_X",
                "SHIFT_OP_Y",
                "SHIFT_OP_Z",
                "SHIFT_OP_4",
                "SHIFT_OP_5",
                "STATIC_RECORD_LAYOUT",
                "STATIC_ADDRESS_OFFSETS",
            ];
            match tag {
                "ALIGNMENT_BYTE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AlignmentByte::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, alignment_byte.is_some())?;
                    alignment_byte = Some(newitem);
                }
                "ALIGNMENT_FLOAT16_IEEE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "ALIGNMENT_FLOAT16_IEEE",
                        A2lVersion::V1_7_1,
                    )?;
                    let newitem = AlignmentFloat16Ieee::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        alignment_float16_ieee.is_some(),
                    )?;
                    alignment_float16_ieee = Some(newitem);
                }
                "ALIGNMENT_FLOAT32_IEEE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AlignmentFloat32Ieee::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        alignment_float32_ieee.is_some(),
                    )?;
                    alignment_float32_ieee = Some(newitem);
                }
                "ALIGNMENT_FLOAT64_IEEE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AlignmentFloat64Ieee::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        alignment_float64_ieee.is_some(),
                    )?;
                    alignment_float64_ieee = Some(newitem);
                }
                "ALIGNMENT_INT64" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AlignmentInt64::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, alignment_int64.is_some())?;
                    alignment_int64 = Some(newitem);
                }
                "ALIGNMENT_LONG" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AlignmentLong::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, alignment_long.is_some())?;
                    alignment_long = Some(newitem);
                }
                "ALIGNMENT_WORD" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AlignmentWord::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, alignment_word.is_some())?;
                    alignment_word = Some(newitem);
                }
                "AXIS_PTS_X" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AxisPtsDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, axis_pts_x.is_some())?;
                    axis_pts_x = Some(newitem);
                }
                "AXIS_PTS_Y" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AxisPtsDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, axis_pts_y.is_some())?;
                    axis_pts_y = Some(newitem);
                }
                "AXIS_PTS_Z" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AxisPtsDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, axis_pts_z.is_some())?;
                    axis_pts_z = Some(newitem);
                }
                "AXIS_PTS_4" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AxisPtsDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, axis_pts_4.is_some())?;
                    axis_pts_4 = Some(newitem);
                }
                "AXIS_PTS_5" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AxisPtsDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, axis_pts_5.is_some())?;
                    axis_pts_5 = Some(newitem);
                }
                "AXIS_RESCALE_X" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AxisRescaleDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, axis_rescale_x.is_some())?;
                    axis_rescale_x = Some(newitem);
                }
                "AXIS_RESCALE_Y" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AxisRescaleDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, axis_rescale_y.is_some())?;
                    axis_rescale_y = Some(newitem);
                }
                "AXIS_RESCALE_Z" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AxisRescaleDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, axis_rescale_z.is_some())?;
                    axis_rescale_z = Some(newitem);
                }
                "AXIS_RESCALE_4" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AxisRescaleDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, axis_rescale_4.is_some())?;
                    axis_rescale_4 = Some(newitem);
                }
                "AXIS_RESCALE_5" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AxisRescaleDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, axis_rescale_5.is_some())?;
                    axis_rescale_5 = Some(newitem);
                }
                "DIST_OP_X" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = DistOpDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, dist_op_x.is_some())?;
                    dist_op_x = Some(newitem);
                }
                "DIST_OP_Y" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = DistOpDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, dist_op_y.is_some())?;
                    dist_op_y = Some(newitem);
                }
                "DIST_OP_Z" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = DistOpDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, dist_op_z.is_some())?;
                    dist_op_z = Some(newitem);
                }
                "DIST_OP_4" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = DistOpDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, dist_op_4.is_some())?;
                    dist_op_4 = Some(newitem);
                }
                "DIST_OP_5" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = DistOpDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, dist_op_5.is_some())?;
                    dist_op_5 = Some(newitem);
                }
                "FIX_NO_AXIS_PTS_X" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = FixNoAxisPtsDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, fix_no_axis_pts_x.is_some())?;
                    fix_no_axis_pts_x = Some(newitem);
                }
                "FIX_NO_AXIS_PTS_Y" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = FixNoAxisPtsDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, fix_no_axis_pts_y.is_some())?;
                    fix_no_axis_pts_y = Some(newitem);
                }
                "FIX_NO_AXIS_PTS_Z" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = FixNoAxisPtsDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, fix_no_axis_pts_z.is_some())?;
                    fix_no_axis_pts_z = Some(newitem);
                }
                "FIX_NO_AXIS_PTS_4" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = FixNoAxisPtsDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, fix_no_axis_pts_4.is_some())?;
                    fix_no_axis_pts_4 = Some(newitem);
                }
                "FIX_NO_AXIS_PTS_5" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = FixNoAxisPtsDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, fix_no_axis_pts_5.is_some())?;
                    fix_no_axis_pts_5 = Some(newitem);
                }
                "FNC_VALUES" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = FncValues::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, fnc_values.is_some())?;
                    fnc_values = Some(newitem);
                }
                "IDENTIFICATION" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Identification::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, identification.is_some())?;
                    identification = Some(newitem);
                }
                "NO_AXIS_PTS_X" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = NoAxisPtsDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, no_axis_pts_x.is_some())?;
                    no_axis_pts_x = Some(newitem);
                }
                "NO_AXIS_PTS_Y" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = NoAxisPtsDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, no_axis_pts_y.is_some())?;
                    no_axis_pts_y = Some(newitem);
                }
                "NO_AXIS_PTS_Z" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = NoAxisPtsDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, no_axis_pts_z.is_some())?;
                    no_axis_pts_z = Some(newitem);
                }
                "NO_AXIS_PTS_4" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = NoAxisPtsDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, no_axis_pts_4.is_some())?;
                    no_axis_pts_4 = Some(newitem);
                }
                "NO_AXIS_PTS_5" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = NoAxisPtsDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, no_axis_pts_5.is_some())?;
                    no_axis_pts_5 = Some(newitem);
                }
                "NO_RESCALE_X" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = NoRescaleDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, no_rescale_x.is_some())?;
                    no_rescale_x = Some(newitem);
                }
                "NO_RESCALE_Y" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = NoRescaleDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, no_rescale_y.is_some())?;
                    no_rescale_y = Some(newitem);
                }
                "NO_RESCALE_Z" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = NoRescaleDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, no_rescale_z.is_some())?;
                    no_rescale_z = Some(newitem);
                }
                "NO_RESCALE_4" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = NoRescaleDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, no_rescale_4.is_some())?;
                    no_rescale_4 = Some(newitem);
                }
                "NO_RESCALE_5" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = NoRescaleDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, no_rescale_5.is_some())?;
                    no_rescale_5 = Some(newitem);
                }
                "OFFSET_X" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = OffsetDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, offset_x.is_some())?;
                    offset_x = Some(newitem);
                }
                "OFFSET_Y" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = OffsetDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, offset_y.is_some())?;
                    offset_y = Some(newitem);
                }
                "OFFSET_Z" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = OffsetDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, offset_z.is_some())?;
                    offset_z = Some(newitem);
                }
                "OFFSET_4" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = OffsetDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, offset_4.is_some())?;
                    offset_4 = Some(newitem);
                }
                "OFFSET_5" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = OffsetDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, offset_5.is_some())?;
                    offset_5 = Some(newitem);
                }
                "RESERVED" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Reserved::parse(parser, &newcontext, line_offset)?;
                    reserved.push(newitem);
                }
                "RIP_ADDR_W" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = RipAddrDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, rip_addr_w.is_some())?;
                    rip_addr_w = Some(newitem);
                }
                "RIP_ADDR_X" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = RipAddrDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, rip_addr_x.is_some())?;
                    rip_addr_x = Some(newitem);
                }
                "RIP_ADDR_Y" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = RipAddrDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, rip_addr_y.is_some())?;
                    rip_addr_y = Some(newitem);
                }
                "RIP_ADDR_Z" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = RipAddrDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, rip_addr_z.is_some())?;
                    rip_addr_z = Some(newitem);
                }
                "RIP_ADDR_4" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = RipAddrDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, rip_addr_4.is_some())?;
                    rip_addr_4 = Some(newitem);
                }
                "RIP_ADDR_5" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = RipAddrDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, rip_addr_5.is_some())?;
                    rip_addr_5 = Some(newitem);
                }
                "SRC_ADDR_X" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = SrcAddrDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, src_addr_x.is_some())?;
                    src_addr_x = Some(newitem);
                }
                "SRC_ADDR_Y" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = SrcAddrDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, src_addr_y.is_some())?;
                    src_addr_y = Some(newitem);
                }
                "SRC_ADDR_Z" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = SrcAddrDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, src_addr_z.is_some())?;
                    src_addr_z = Some(newitem);
                }
                "SRC_ADDR_4" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = SrcAddrDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, src_addr_4.is_some())?;
                    src_addr_4 = Some(newitem);
                }
                "SRC_ADDR_5" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = SrcAddrDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, src_addr_5.is_some())?;
                    src_addr_5 = Some(newitem);
                }
                "SHIFT_OP_X" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ShiftOpDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, shift_op_x.is_some())?;
                    shift_op_x = Some(newitem);
                }
                "SHIFT_OP_Y" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ShiftOpDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, shift_op_y.is_some())?;
                    shift_op_y = Some(newitem);
                }
                "SHIFT_OP_Z" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ShiftOpDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, shift_op_z.is_some())?;
                    shift_op_z = Some(newitem);
                }
                "SHIFT_OP_4" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ShiftOpDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, shift_op_4.is_some())?;
                    shift_op_4 = Some(newitem);
                }
                "SHIFT_OP_5" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ShiftOpDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, shift_op_5.is_some())?;
                    shift_op_5 = Some(newitem);
                }
                "STATIC_RECORD_LAYOUT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "STATIC_RECORD_LAYOUT",
                        A2lVersion::V1_6_0,
                    )?;
                    let newitem = StaticRecordLayout::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        static_record_layout.is_some(),
                    )?;
                    static_record_layout = Some(newitem);
                }
                "STATIC_ADDRESS_OFFSETS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "STATIC_ADDRESS_OFFSETS",
                        A2lVersion::V1_7_0,
                    )?;
                    let newitem = StaticAddressOffsets::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        static_address_offsets.is_some(),
                    )?;
                    static_address_offsets = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __dummy),
            },
            name,
            alignment_byte,
            alignment_float16_ieee,
            alignment_float32_ieee,
            alignment_float64_ieee,
            alignment_int64,
            alignment_long,
            alignment_word,
            axis_pts_x,
            axis_pts_y,
            axis_pts_z,
            axis_pts_4,
            axis_pts_5,
            axis_rescale_x,
            axis_rescale_y,
            axis_rescale_z,
            axis_rescale_4,
            axis_rescale_5,
            dist_op_x,
            dist_op_y,
            dist_op_z,
            dist_op_4,
            dist_op_5,
            fix_no_axis_pts_x,
            fix_no_axis_pts_y,
            fix_no_axis_pts_z,
            fix_no_axis_pts_4,
            fix_no_axis_pts_5,
            fnc_values,
            identification,
            no_axis_pts_x,
            no_axis_pts_y,
            no_axis_pts_z,
            no_axis_pts_4,
            no_axis_pts_5,
            no_rescale_x,
            no_rescale_y,
            no_rescale_z,
            no_rescale_4,
            no_rescale_5,
            offset_x,
            offset_y,
            offset_z,
            offset_4,
            offset_5,
            reserved,
            rip_addr_w,
            rip_addr_x,
            rip_addr_y,
            rip_addr_z,
            rip_addr_4,
            rip_addr_5,
            src_addr_x,
            src_addr_y,
            src_addr_z,
            src_addr_4,
            src_addr_5,
            shift_op_x,
            shift_op_y,
            shift_op_z,
            shift_op_4,
            shift_op_5,
            static_record_layout,
            static_address_offsets,
        })
    }
}

impl RecordLayout {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(alignment_byte) = &self.alignment_byte {
            let alignment_byte_out = alignment_byte.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ALIGNMENT_BYTE",
                item_text: alignment_byte_out,
                is_block: false,
                incfile: &alignment_byte.__block_info.incfile,
                uid: alignment_byte.__block_info.uid,
                line: alignment_byte.__block_info.line,
                start_offset: alignment_byte.__block_info.start_offset,
                end_offset: alignment_byte.__block_info.end_offset,
                position_restriction: alignment_byte.pos_restrict(),
            });
        }
        if let Some(alignment_float16_ieee) = &self.alignment_float16_ieee {
            let alignment_float16_ieee_out = alignment_float16_ieee.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ALIGNMENT_FLOAT16_IEEE",
                item_text: alignment_float16_ieee_out,
                is_block: false,
                incfile: &alignment_float16_ieee.__block_info.incfile,
                uid: alignment_float16_ieee.__block_info.uid,
                line: alignment_float16_ieee.__block_info.line,
                start_offset: alignment_float16_ieee.__block_info.start_offset,
                end_offset: alignment_float16_ieee.__block_info.end_offset,
                position_restriction: alignment_float16_ieee.pos_restrict(),
            });
        }
        if let Some(alignment_float32_ieee) = &self.alignment_float32_ieee {
            let alignment_float32_ieee_out = alignment_float32_ieee.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ALIGNMENT_FLOAT32_IEEE",
                item_text: alignment_float32_ieee_out,
                is_block: false,
                incfile: &alignment_float32_ieee.__block_info.incfile,
                uid: alignment_float32_ieee.__block_info.uid,
                line: alignment_float32_ieee.__block_info.line,
                start_offset: alignment_float32_ieee.__block_info.start_offset,
                end_offset: alignment_float32_ieee.__block_info.end_offset,
                position_restriction: alignment_float32_ieee.pos_restrict(),
            });
        }
        if let Some(alignment_float64_ieee) = &self.alignment_float64_ieee {
            let alignment_float64_ieee_out = alignment_float64_ieee.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ALIGNMENT_FLOAT64_IEEE",
                item_text: alignment_float64_ieee_out,
                is_block: false,
                incfile: &alignment_float64_ieee.__block_info.incfile,
                uid: alignment_float64_ieee.__block_info.uid,
                line: alignment_float64_ieee.__block_info.line,
                start_offset: alignment_float64_ieee.__block_info.start_offset,
                end_offset: alignment_float64_ieee.__block_info.end_offset,
                position_restriction: alignment_float64_ieee.pos_restrict(),
            });
        }
        if let Some(alignment_int64) = &self.alignment_int64 {
            let alignment_int64_out = alignment_int64.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ALIGNMENT_INT64",
                item_text: alignment_int64_out,
                is_block: false,
                incfile: &alignment_int64.__block_info.incfile,
                uid: alignment_int64.__block_info.uid,
                line: alignment_int64.__block_info.line,
                start_offset: alignment_int64.__block_info.start_offset,
                end_offset: alignment_int64.__block_info.end_offset,
                position_restriction: alignment_int64.pos_restrict(),
            });
        }
        if let Some(alignment_long) = &self.alignment_long {
            let alignment_long_out = alignment_long.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ALIGNMENT_LONG",
                item_text: alignment_long_out,
                is_block: false,
                incfile: &alignment_long.__block_info.incfile,
                uid: alignment_long.__block_info.uid,
                line: alignment_long.__block_info.line,
                start_offset: alignment_long.__block_info.start_offset,
                end_offset: alignment_long.__block_info.end_offset,
                position_restriction: alignment_long.pos_restrict(),
            });
        }
        if let Some(alignment_word) = &self.alignment_word {
            let alignment_word_out = alignment_word.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ALIGNMENT_WORD",
                item_text: alignment_word_out,
                is_block: false,
                incfile: &alignment_word.__block_info.incfile,
                uid: alignment_word.__block_info.uid,
                line: alignment_word.__block_info.line,
                start_offset: alignment_word.__block_info.start_offset,
                end_offset: alignment_word.__block_info.end_offset,
                position_restriction: alignment_word.pos_restrict(),
            });
        }
        if let Some(axis_pts_x) = &self.axis_pts_x {
            let axis_pts_x_out = axis_pts_x.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AXIS_PTS_X",
                item_text: axis_pts_x_out,
                is_block: false,
                incfile: &axis_pts_x.__block_info.incfile,
                uid: axis_pts_x.__block_info.uid,
                line: axis_pts_x.__block_info.line,
                start_offset: axis_pts_x.__block_info.start_offset,
                end_offset: axis_pts_x.__block_info.end_offset,
                position_restriction: axis_pts_x.pos_restrict(),
            });
        }
        if let Some(axis_pts_y) = &self.axis_pts_y {
            let axis_pts_y_out = axis_pts_y.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AXIS_PTS_Y",
                item_text: axis_pts_y_out,
                is_block: false,
                incfile: &axis_pts_y.__block_info.incfile,
                uid: axis_pts_y.__block_info.uid,
                line: axis_pts_y.__block_info.line,
                start_offset: axis_pts_y.__block_info.start_offset,
                end_offset: axis_pts_y.__block_info.end_offset,
                position_restriction: axis_pts_y.pos_restrict(),
            });
        }
        if let Some(axis_pts_z) = &self.axis_pts_z {
            let axis_pts_z_out = axis_pts_z.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AXIS_PTS_Z",
                item_text: axis_pts_z_out,
                is_block: false,
                incfile: &axis_pts_z.__block_info.incfile,
                uid: axis_pts_z.__block_info.uid,
                line: axis_pts_z.__block_info.line,
                start_offset: axis_pts_z.__block_info.start_offset,
                end_offset: axis_pts_z.__block_info.end_offset,
                position_restriction: axis_pts_z.pos_restrict(),
            });
        }
        if let Some(axis_pts_4) = &self.axis_pts_4 {
            let axis_pts_4_out = axis_pts_4.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AXIS_PTS_4",
                item_text: axis_pts_4_out,
                is_block: false,
                incfile: &axis_pts_4.__block_info.incfile,
                uid: axis_pts_4.__block_info.uid,
                line: axis_pts_4.__block_info.line,
                start_offset: axis_pts_4.__block_info.start_offset,
                end_offset: axis_pts_4.__block_info.end_offset,
                position_restriction: axis_pts_4.pos_restrict(),
            });
        }
        if let Some(axis_pts_5) = &self.axis_pts_5 {
            let axis_pts_5_out = axis_pts_5.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AXIS_PTS_5",
                item_text: axis_pts_5_out,
                is_block: false,
                incfile: &axis_pts_5.__block_info.incfile,
                uid: axis_pts_5.__block_info.uid,
                line: axis_pts_5.__block_info.line,
                start_offset: axis_pts_5.__block_info.start_offset,
                end_offset: axis_pts_5.__block_info.end_offset,
                position_restriction: axis_pts_5.pos_restrict(),
            });
        }
        if let Some(axis_rescale_x) = &self.axis_rescale_x {
            let axis_rescale_x_out = axis_rescale_x.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AXIS_RESCALE_X",
                item_text: axis_rescale_x_out,
                is_block: false,
                incfile: &axis_rescale_x.__block_info.incfile,
                uid: axis_rescale_x.__block_info.uid,
                line: axis_rescale_x.__block_info.line,
                start_offset: axis_rescale_x.__block_info.start_offset,
                end_offset: axis_rescale_x.__block_info.end_offset,
                position_restriction: axis_rescale_x.pos_restrict(),
            });
        }
        if let Some(axis_rescale_y) = &self.axis_rescale_y {
            let axis_rescale_y_out = axis_rescale_y.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AXIS_RESCALE_Y",
                item_text: axis_rescale_y_out,
                is_block: false,
                incfile: &axis_rescale_y.__block_info.incfile,
                uid: axis_rescale_y.__block_info.uid,
                line: axis_rescale_y.__block_info.line,
                start_offset: axis_rescale_y.__block_info.start_offset,
                end_offset: axis_rescale_y.__block_info.end_offset,
                position_restriction: axis_rescale_y.pos_restrict(),
            });
        }
        if let Some(axis_rescale_z) = &self.axis_rescale_z {
            let axis_rescale_z_out = axis_rescale_z.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AXIS_RESCALE_Z",
                item_text: axis_rescale_z_out,
                is_block: false,
                incfile: &axis_rescale_z.__block_info.incfile,
                uid: axis_rescale_z.__block_info.uid,
                line: axis_rescale_z.__block_info.line,
                start_offset: axis_rescale_z.__block_info.start_offset,
                end_offset: axis_rescale_z.__block_info.end_offset,
                position_restriction: axis_rescale_z.pos_restrict(),
            });
        }
        if let Some(axis_rescale_4) = &self.axis_rescale_4 {
            let axis_rescale_4_out = axis_rescale_4.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AXIS_RESCALE_4",
                item_text: axis_rescale_4_out,
                is_block: false,
                incfile: &axis_rescale_4.__block_info.incfile,
                uid: axis_rescale_4.__block_info.uid,
                line: axis_rescale_4.__block_info.line,
                start_offset: axis_rescale_4.__block_info.start_offset,
                end_offset: axis_rescale_4.__block_info.end_offset,
                position_restriction: axis_rescale_4.pos_restrict(),
            });
        }
        if let Some(axis_rescale_5) = &self.axis_rescale_5 {
            let axis_rescale_5_out = axis_rescale_5.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AXIS_RESCALE_5",
                item_text: axis_rescale_5_out,
                is_block: false,
                incfile: &axis_rescale_5.__block_info.incfile,
                uid: axis_rescale_5.__block_info.uid,
                line: axis_rescale_5.__block_info.line,
                start_offset: axis_rescale_5.__block_info.start_offset,
                end_offset: axis_rescale_5.__block_info.end_offset,
                position_restriction: axis_rescale_5.pos_restrict(),
            });
        }
        if let Some(dist_op_x) = &self.dist_op_x {
            let dist_op_x_out = dist_op_x.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DIST_OP_X",
                item_text: dist_op_x_out,
                is_block: false,
                incfile: &dist_op_x.__block_info.incfile,
                uid: dist_op_x.__block_info.uid,
                line: dist_op_x.__block_info.line,
                start_offset: dist_op_x.__block_info.start_offset,
                end_offset: dist_op_x.__block_info.end_offset,
                position_restriction: dist_op_x.pos_restrict(),
            });
        }
        if let Some(dist_op_y) = &self.dist_op_y {
            let dist_op_y_out = dist_op_y.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DIST_OP_Y",
                item_text: dist_op_y_out,
                is_block: false,
                incfile: &dist_op_y.__block_info.incfile,
                uid: dist_op_y.__block_info.uid,
                line: dist_op_y.__block_info.line,
                start_offset: dist_op_y.__block_info.start_offset,
                end_offset: dist_op_y.__block_info.end_offset,
                position_restriction: dist_op_y.pos_restrict(),
            });
        }
        if let Some(dist_op_z) = &self.dist_op_z {
            let dist_op_z_out = dist_op_z.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DIST_OP_Z",
                item_text: dist_op_z_out,
                is_block: false,
                incfile: &dist_op_z.__block_info.incfile,
                uid: dist_op_z.__block_info.uid,
                line: dist_op_z.__block_info.line,
                start_offset: dist_op_z.__block_info.start_offset,
                end_offset: dist_op_z.__block_info.end_offset,
                position_restriction: dist_op_z.pos_restrict(),
            });
        }
        if let Some(dist_op_4) = &self.dist_op_4 {
            let dist_op_4_out = dist_op_4.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DIST_OP_4",
                item_text: dist_op_4_out,
                is_block: false,
                incfile: &dist_op_4.__block_info.incfile,
                uid: dist_op_4.__block_info.uid,
                line: dist_op_4.__block_info.line,
                start_offset: dist_op_4.__block_info.start_offset,
                end_offset: dist_op_4.__block_info.end_offset,
                position_restriction: dist_op_4.pos_restrict(),
            });
        }
        if let Some(dist_op_5) = &self.dist_op_5 {
            let dist_op_5_out = dist_op_5.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DIST_OP_5",
                item_text: dist_op_5_out,
                is_block: false,
                incfile: &dist_op_5.__block_info.incfile,
                uid: dist_op_5.__block_info.uid,
                line: dist_op_5.__block_info.line,
                start_offset: dist_op_5.__block_info.start_offset,
                end_offset: dist_op_5.__block_info.end_offset,
                position_restriction: dist_op_5.pos_restrict(),
            });
        }
        if let Some(fix_no_axis_pts_x) = &self.fix_no_axis_pts_x {
            let fix_no_axis_pts_x_out = fix_no_axis_pts_x.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FIX_NO_AXIS_PTS_X",
                item_text: fix_no_axis_pts_x_out,
                is_block: false,
                incfile: &fix_no_axis_pts_x.__block_info.incfile,
                uid: fix_no_axis_pts_x.__block_info.uid,
                line: fix_no_axis_pts_x.__block_info.line,
                start_offset: fix_no_axis_pts_x.__block_info.start_offset,
                end_offset: fix_no_axis_pts_x.__block_info.end_offset,
                position_restriction: fix_no_axis_pts_x.pos_restrict(),
            });
        }
        if let Some(fix_no_axis_pts_y) = &self.fix_no_axis_pts_y {
            let fix_no_axis_pts_y_out = fix_no_axis_pts_y.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FIX_NO_AXIS_PTS_Y",
                item_text: fix_no_axis_pts_y_out,
                is_block: false,
                incfile: &fix_no_axis_pts_y.__block_info.incfile,
                uid: fix_no_axis_pts_y.__block_info.uid,
                line: fix_no_axis_pts_y.__block_info.line,
                start_offset: fix_no_axis_pts_y.__block_info.start_offset,
                end_offset: fix_no_axis_pts_y.__block_info.end_offset,
                position_restriction: fix_no_axis_pts_y.pos_restrict(),
            });
        }
        if let Some(fix_no_axis_pts_z) = &self.fix_no_axis_pts_z {
            let fix_no_axis_pts_z_out = fix_no_axis_pts_z.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FIX_NO_AXIS_PTS_Z",
                item_text: fix_no_axis_pts_z_out,
                is_block: false,
                incfile: &fix_no_axis_pts_z.__block_info.incfile,
                uid: fix_no_axis_pts_z.__block_info.uid,
                line: fix_no_axis_pts_z.__block_info.line,
                start_offset: fix_no_axis_pts_z.__block_info.start_offset,
                end_offset: fix_no_axis_pts_z.__block_info.end_offset,
                position_restriction: fix_no_axis_pts_z.pos_restrict(),
            });
        }
        if let Some(fix_no_axis_pts_4) = &self.fix_no_axis_pts_4 {
            let fix_no_axis_pts_4_out = fix_no_axis_pts_4.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FIX_NO_AXIS_PTS_4",
                item_text: fix_no_axis_pts_4_out,
                is_block: false,
                incfile: &fix_no_axis_pts_4.__block_info.incfile,
                uid: fix_no_axis_pts_4.__block_info.uid,
                line: fix_no_axis_pts_4.__block_info.line,
                start_offset: fix_no_axis_pts_4.__block_info.start_offset,
                end_offset: fix_no_axis_pts_4.__block_info.end_offset,
                position_restriction: fix_no_axis_pts_4.pos_restrict(),
            });
        }
        if let Some(fix_no_axis_pts_5) = &self.fix_no_axis_pts_5 {
            let fix_no_axis_pts_5_out = fix_no_axis_pts_5.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FIX_NO_AXIS_PTS_5",
                item_text: fix_no_axis_pts_5_out,
                is_block: false,
                incfile: &fix_no_axis_pts_5.__block_info.incfile,
                uid: fix_no_axis_pts_5.__block_info.uid,
                line: fix_no_axis_pts_5.__block_info.line,
                start_offset: fix_no_axis_pts_5.__block_info.start_offset,
                end_offset: fix_no_axis_pts_5.__block_info.end_offset,
                position_restriction: fix_no_axis_pts_5.pos_restrict(),
            });
        }
        if let Some(fnc_values) = &self.fnc_values {
            let fnc_values_out = fnc_values.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FNC_VALUES",
                item_text: fnc_values_out,
                is_block: false,
                incfile: &fnc_values.__block_info.incfile,
                uid: fnc_values.__block_info.uid,
                line: fnc_values.__block_info.line,
                start_offset: fnc_values.__block_info.start_offset,
                end_offset: fnc_values.__block_info.end_offset,
                position_restriction: fnc_values.pos_restrict(),
            });
        }
        if let Some(identification) = &self.identification {
            let identification_out = identification.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "IDENTIFICATION",
                item_text: identification_out,
                is_block: false,
                incfile: &identification.__block_info.incfile,
                uid: identification.__block_info.uid,
                line: identification.__block_info.line,
                start_offset: identification.__block_info.start_offset,
                end_offset: identification.__block_info.end_offset,
                position_restriction: identification.pos_restrict(),
            });
        }
        if let Some(no_axis_pts_x) = &self.no_axis_pts_x {
            let no_axis_pts_x_out = no_axis_pts_x.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "NO_AXIS_PTS_X",
                item_text: no_axis_pts_x_out,
                is_block: false,
                incfile: &no_axis_pts_x.__block_info.incfile,
                uid: no_axis_pts_x.__block_info.uid,
                line: no_axis_pts_x.__block_info.line,
                start_offset: no_axis_pts_x.__block_info.start_offset,
                end_offset: no_axis_pts_x.__block_info.end_offset,
                position_restriction: no_axis_pts_x.pos_restrict(),
            });
        }
        if let Some(no_axis_pts_y) = &self.no_axis_pts_y {
            let no_axis_pts_y_out = no_axis_pts_y.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "NO_AXIS_PTS_Y",
                item_text: no_axis_pts_y_out,
                is_block: false,
                incfile: &no_axis_pts_y.__block_info.incfile,
                uid: no_axis_pts_y.__block_info.uid,
                line: no_axis_pts_y.__block_info.line,
                start_offset: no_axis_pts_y.__block_info.start_offset,
                end_offset: no_axis_pts_y.__block_info.end_offset,
                position_restriction: no_axis_pts_y.pos_restrict(),
            });
        }
        if let Some(no_axis_pts_z) = &self.no_axis_pts_z {
            let no_axis_pts_z_out = no_axis_pts_z.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "NO_AXIS_PTS_Z",
                item_text: no_axis_pts_z_out,
                is_block: false,
                incfile: &no_axis_pts_z.__block_info.incfile,
                uid: no_axis_pts_z.__block_info.uid,
                line: no_axis_pts_z.__block_info.line,
                start_offset: no_axis_pts_z.__block_info.start_offset,
                end_offset: no_axis_pts_z.__block_info.end_offset,
                position_restriction: no_axis_pts_z.pos_restrict(),
            });
        }
        if let Some(no_axis_pts_4) = &self.no_axis_pts_4 {
            let no_axis_pts_4_out = no_axis_pts_4.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "NO_AXIS_PTS_4",
                item_text: no_axis_pts_4_out,
                is_block: false,
                incfile: &no_axis_pts_4.__block_info.incfile,
                uid: no_axis_pts_4.__block_info.uid,
                line: no_axis_pts_4.__block_info.line,
                start_offset: no_axis_pts_4.__block_info.start_offset,
                end_offset: no_axis_pts_4.__block_info.end_offset,
                position_restriction: no_axis_pts_4.pos_restrict(),
            });
        }
        if let Some(no_axis_pts_5) = &self.no_axis_pts_5 {
            let no_axis_pts_5_out = no_axis_pts_5.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "NO_AXIS_PTS_5",
                item_text: no_axis_pts_5_out,
                is_block: false,
                incfile: &no_axis_pts_5.__block_info.incfile,
                uid: no_axis_pts_5.__block_info.uid,
                line: no_axis_pts_5.__block_info.line,
                start_offset: no_axis_pts_5.__block_info.start_offset,
                end_offset: no_axis_pts_5.__block_info.end_offset,
                position_restriction: no_axis_pts_5.pos_restrict(),
            });
        }
        if let Some(no_rescale_x) = &self.no_rescale_x {
            let no_rescale_x_out = no_rescale_x.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "NO_RESCALE_X",
                item_text: no_rescale_x_out,
                is_block: false,
                incfile: &no_rescale_x.__block_info.incfile,
                uid: no_rescale_x.__block_info.uid,
                line: no_rescale_x.__block_info.line,
                start_offset: no_rescale_x.__block_info.start_offset,
                end_offset: no_rescale_x.__block_info.end_offset,
                position_restriction: no_rescale_x.pos_restrict(),
            });
        }
        if let Some(no_rescale_y) = &self.no_rescale_y {
            let no_rescale_y_out = no_rescale_y.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "NO_RESCALE_Y",
                item_text: no_rescale_y_out,
                is_block: false,
                incfile: &no_rescale_y.__block_info.incfile,
                uid: no_rescale_y.__block_info.uid,
                line: no_rescale_y.__block_info.line,
                start_offset: no_rescale_y.__block_info.start_offset,
                end_offset: no_rescale_y.__block_info.end_offset,
                position_restriction: no_rescale_y.pos_restrict(),
            });
        }
        if let Some(no_rescale_z) = &self.no_rescale_z {
            let no_rescale_z_out = no_rescale_z.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "NO_RESCALE_Z",
                item_text: no_rescale_z_out,
                is_block: false,
                incfile: &no_rescale_z.__block_info.incfile,
                uid: no_rescale_z.__block_info.uid,
                line: no_rescale_z.__block_info.line,
                start_offset: no_rescale_z.__block_info.start_offset,
                end_offset: no_rescale_z.__block_info.end_offset,
                position_restriction: no_rescale_z.pos_restrict(),
            });
        }
        if let Some(no_rescale_4) = &self.no_rescale_4 {
            let no_rescale_4_out = no_rescale_4.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "NO_RESCALE_4",
                item_text: no_rescale_4_out,
                is_block: false,
                incfile: &no_rescale_4.__block_info.incfile,
                uid: no_rescale_4.__block_info.uid,
                line: no_rescale_4.__block_info.line,
                start_offset: no_rescale_4.__block_info.start_offset,
                end_offset: no_rescale_4.__block_info.end_offset,
                position_restriction: no_rescale_4.pos_restrict(),
            });
        }
        if let Some(no_rescale_5) = &self.no_rescale_5 {
            let no_rescale_5_out = no_rescale_5.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "NO_RESCALE_5",
                item_text: no_rescale_5_out,
                is_block: false,
                incfile: &no_rescale_5.__block_info.incfile,
                uid: no_rescale_5.__block_info.uid,
                line: no_rescale_5.__block_info.line,
                start_offset: no_rescale_5.__block_info.start_offset,
                end_offset: no_rescale_5.__block_info.end_offset,
                position_restriction: no_rescale_5.pos_restrict(),
            });
        }
        if let Some(offset_x) = &self.offset_x {
            let offset_x_out = offset_x.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "OFFSET_X",
                item_text: offset_x_out,
                is_block: false,
                incfile: &offset_x.__block_info.incfile,
                uid: offset_x.__block_info.uid,
                line: offset_x.__block_info.line,
                start_offset: offset_x.__block_info.start_offset,
                end_offset: offset_x.__block_info.end_offset,
                position_restriction: offset_x.pos_restrict(),
            });
        }
        if let Some(offset_y) = &self.offset_y {
            let offset_y_out = offset_y.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "OFFSET_Y",
                item_text: offset_y_out,
                is_block: false,
                incfile: &offset_y.__block_info.incfile,
                uid: offset_y.__block_info.uid,
                line: offset_y.__block_info.line,
                start_offset: offset_y.__block_info.start_offset,
                end_offset: offset_y.__block_info.end_offset,
                position_restriction: offset_y.pos_restrict(),
            });
        }
        if let Some(offset_z) = &self.offset_z {
            let offset_z_out = offset_z.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "OFFSET_Z",
                item_text: offset_z_out,
                is_block: false,
                incfile: &offset_z.__block_info.incfile,
                uid: offset_z.__block_info.uid,
                line: offset_z.__block_info.line,
                start_offset: offset_z.__block_info.start_offset,
                end_offset: offset_z.__block_info.end_offset,
                position_restriction: offset_z.pos_restrict(),
            });
        }
        if let Some(offset_4) = &self.offset_4 {
            let offset_4_out = offset_4.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "OFFSET_4",
                item_text: offset_4_out,
                is_block: false,
                incfile: &offset_4.__block_info.incfile,
                uid: offset_4.__block_info.uid,
                line: offset_4.__block_info.line,
                start_offset: offset_4.__block_info.start_offset,
                end_offset: offset_4.__block_info.end_offset,
                position_restriction: offset_4.pos_restrict(),
            });
        }
        if let Some(offset_5) = &self.offset_5 {
            let offset_5_out = offset_5.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "OFFSET_5",
                item_text: offset_5_out,
                is_block: false,
                incfile: &offset_5.__block_info.incfile,
                uid: offset_5.__block_info.uid,
                line: offset_5.__block_info.line,
                start_offset: offset_5.__block_info.start_offset,
                end_offset: offset_5.__block_info.end_offset,
                position_restriction: offset_5.pos_restrict(),
            });
        }
        for reserved in &self.reserved {
            let reserved_out = reserved.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "RESERVED",
                item_text: reserved_out,
                is_block: false,
                incfile: &reserved.__block_info.incfile,
                uid: reserved.__block_info.uid,
                line: reserved.__block_info.line,
                start_offset: reserved.__block_info.start_offset,
                end_offset: reserved.__block_info.end_offset,
                position_restriction: reserved.pos_restrict(),
            });
        }
        if let Some(rip_addr_w) = &self.rip_addr_w {
            let rip_addr_w_out = rip_addr_w.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "RIP_ADDR_W",
                item_text: rip_addr_w_out,
                is_block: false,
                incfile: &rip_addr_w.__block_info.incfile,
                uid: rip_addr_w.__block_info.uid,
                line: rip_addr_w.__block_info.line,
                start_offset: rip_addr_w.__block_info.start_offset,
                end_offset: rip_addr_w.__block_info.end_offset,
                position_restriction: rip_addr_w.pos_restrict(),
            });
        }
        if let Some(rip_addr_x) = &self.rip_addr_x {
            let rip_addr_x_out = rip_addr_x.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "RIP_ADDR_X",
                item_text: rip_addr_x_out,
                is_block: false,
                incfile: &rip_addr_x.__block_info.incfile,
                uid: rip_addr_x.__block_info.uid,
                line: rip_addr_x.__block_info.line,
                start_offset: rip_addr_x.__block_info.start_offset,
                end_offset: rip_addr_x.__block_info.end_offset,
                position_restriction: rip_addr_x.pos_restrict(),
            });
        }
        if let Some(rip_addr_y) = &self.rip_addr_y {
            let rip_addr_y_out = rip_addr_y.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "RIP_ADDR_Y",
                item_text: rip_addr_y_out,
                is_block: false,
                incfile: &rip_addr_y.__block_info.incfile,
                uid: rip_addr_y.__block_info.uid,
                line: rip_addr_y.__block_info.line,
                start_offset: rip_addr_y.__block_info.start_offset,
                end_offset: rip_addr_y.__block_info.end_offset,
                position_restriction: rip_addr_y.pos_restrict(),
            });
        }
        if let Some(rip_addr_z) = &self.rip_addr_z {
            let rip_addr_z_out = rip_addr_z.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "RIP_ADDR_Z",
                item_text: rip_addr_z_out,
                is_block: false,
                incfile: &rip_addr_z.__block_info.incfile,
                uid: rip_addr_z.__block_info.uid,
                line: rip_addr_z.__block_info.line,
                start_offset: rip_addr_z.__block_info.start_offset,
                end_offset: rip_addr_z.__block_info.end_offset,
                position_restriction: rip_addr_z.pos_restrict(),
            });
        }
        if let Some(rip_addr_4) = &self.rip_addr_4 {
            let rip_addr_4_out = rip_addr_4.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "RIP_ADDR_4",
                item_text: rip_addr_4_out,
                is_block: false,
                incfile: &rip_addr_4.__block_info.incfile,
                uid: rip_addr_4.__block_info.uid,
                line: rip_addr_4.__block_info.line,
                start_offset: rip_addr_4.__block_info.start_offset,
                end_offset: rip_addr_4.__block_info.end_offset,
                position_restriction: rip_addr_4.pos_restrict(),
            });
        }
        if let Some(rip_addr_5) = &self.rip_addr_5 {
            let rip_addr_5_out = rip_addr_5.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "RIP_ADDR_5",
                item_text: rip_addr_5_out,
                is_block: false,
                incfile: &rip_addr_5.__block_info.incfile,
                uid: rip_addr_5.__block_info.uid,
                line: rip_addr_5.__block_info.line,
                start_offset: rip_addr_5.__block_info.start_offset,
                end_offset: rip_addr_5.__block_info.end_offset,
                position_restriction: rip_addr_5.pos_restrict(),
            });
        }
        if let Some(src_addr_x) = &self.src_addr_x {
            let src_addr_x_out = src_addr_x.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SRC_ADDR_X",
                item_text: src_addr_x_out,
                is_block: false,
                incfile: &src_addr_x.__block_info.incfile,
                uid: src_addr_x.__block_info.uid,
                line: src_addr_x.__block_info.line,
                start_offset: src_addr_x.__block_info.start_offset,
                end_offset: src_addr_x.__block_info.end_offset,
                position_restriction: src_addr_x.pos_restrict(),
            });
        }
        if let Some(src_addr_y) = &self.src_addr_y {
            let src_addr_y_out = src_addr_y.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SRC_ADDR_Y",
                item_text: src_addr_y_out,
                is_block: false,
                incfile: &src_addr_y.__block_info.incfile,
                uid: src_addr_y.__block_info.uid,
                line: src_addr_y.__block_info.line,
                start_offset: src_addr_y.__block_info.start_offset,
                end_offset: src_addr_y.__block_info.end_offset,
                position_restriction: src_addr_y.pos_restrict(),
            });
        }
        if let Some(src_addr_z) = &self.src_addr_z {
            let src_addr_z_out = src_addr_z.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SRC_ADDR_Z",
                item_text: src_addr_z_out,
                is_block: false,
                incfile: &src_addr_z.__block_info.incfile,
                uid: src_addr_z.__block_info.uid,
                line: src_addr_z.__block_info.line,
                start_offset: src_addr_z.__block_info.start_offset,
                end_offset: src_addr_z.__block_info.end_offset,
                position_restriction: src_addr_z.pos_restrict(),
            });
        }
        if let Some(src_addr_4) = &self.src_addr_4 {
            let src_addr_4_out = src_addr_4.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SRC_ADDR_4",
                item_text: src_addr_4_out,
                is_block: false,
                incfile: &src_addr_4.__block_info.incfile,
                uid: src_addr_4.__block_info.uid,
                line: src_addr_4.__block_info.line,
                start_offset: src_addr_4.__block_info.start_offset,
                end_offset: src_addr_4.__block_info.end_offset,
                position_restriction: src_addr_4.pos_restrict(),
            });
        }
        if let Some(src_addr_5) = &self.src_addr_5 {
            let src_addr_5_out = src_addr_5.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SRC_ADDR_5",
                item_text: src_addr_5_out,
                is_block: false,
                incfile: &src_addr_5.__block_info.incfile,
                uid: src_addr_5.__block_info.uid,
                line: src_addr_5.__block_info.line,
                start_offset: src_addr_5.__block_info.start_offset,
                end_offset: src_addr_5.__block_info.end_offset,
                position_restriction: src_addr_5.pos_restrict(),
            });
        }
        if let Some(shift_op_x) = &self.shift_op_x {
            let shift_op_x_out = shift_op_x.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SHIFT_OP_X",
                item_text: shift_op_x_out,
                is_block: false,
                incfile: &shift_op_x.__block_info.incfile,
                uid: shift_op_x.__block_info.uid,
                line: shift_op_x.__block_info.line,
                start_offset: shift_op_x.__block_info.start_offset,
                end_offset: shift_op_x.__block_info.end_offset,
                position_restriction: shift_op_x.pos_restrict(),
            });
        }
        if let Some(shift_op_y) = &self.shift_op_y {
            let shift_op_y_out = shift_op_y.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SHIFT_OP_Y",
                item_text: shift_op_y_out,
                is_block: false,
                incfile: &shift_op_y.__block_info.incfile,
                uid: shift_op_y.__block_info.uid,
                line: shift_op_y.__block_info.line,
                start_offset: shift_op_y.__block_info.start_offset,
                end_offset: shift_op_y.__block_info.end_offset,
                position_restriction: shift_op_y.pos_restrict(),
            });
        }
        if let Some(shift_op_z) = &self.shift_op_z {
            let shift_op_z_out = shift_op_z.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SHIFT_OP_Z",
                item_text: shift_op_z_out,
                is_block: false,
                incfile: &shift_op_z.__block_info.incfile,
                uid: shift_op_z.__block_info.uid,
                line: shift_op_z.__block_info.line,
                start_offset: shift_op_z.__block_info.start_offset,
                end_offset: shift_op_z.__block_info.end_offset,
                position_restriction: shift_op_z.pos_restrict(),
            });
        }
        if let Some(shift_op_4) = &self.shift_op_4 {
            let shift_op_4_out = shift_op_4.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SHIFT_OP_4",
                item_text: shift_op_4_out,
                is_block: false,
                incfile: &shift_op_4.__block_info.incfile,
                uid: shift_op_4.__block_info.uid,
                line: shift_op_4.__block_info.line,
                start_offset: shift_op_4.__block_info.start_offset,
                end_offset: shift_op_4.__block_info.end_offset,
                position_restriction: shift_op_4.pos_restrict(),
            });
        }
        if let Some(shift_op_5) = &self.shift_op_5 {
            let shift_op_5_out = shift_op_5.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SHIFT_OP_5",
                item_text: shift_op_5_out,
                is_block: false,
                incfile: &shift_op_5.__block_info.incfile,
                uid: shift_op_5.__block_info.uid,
                line: shift_op_5.__block_info.line,
                start_offset: shift_op_5.__block_info.start_offset,
                end_offset: shift_op_5.__block_info.end_offset,
                position_restriction: shift_op_5.pos_restrict(),
            });
        }
        if let Some(static_record_layout) = &self.static_record_layout {
            let static_record_layout_out = static_record_layout.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "STATIC_RECORD_LAYOUT",
                item_text: static_record_layout_out,
                is_block: false,
                incfile: &static_record_layout.__block_info.incfile,
                uid: static_record_layout.__block_info.uid,
                line: static_record_layout.__block_info.line,
                start_offset: static_record_layout.__block_info.start_offset,
                end_offset: static_record_layout.__block_info.end_offset,
                position_restriction: static_record_layout.pos_restrict(),
            });
        }
        if let Some(static_address_offsets) = &self.static_address_offsets {
            let static_address_offsets_out = static_address_offsets.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "STATIC_ADDRESS_OFFSETS",
                item_text: static_address_offsets_out,
                is_block: false,
                incfile: &static_address_offsets.__block_info.incfile,
                uid: static_address_offsets.__block_info.uid,
                line: static_address_offsets.__block_info.line,
                start_offset: static_address_offsets.__block_info.start_offset,
                end_offset: static_address_offsets.__block_info.end_offset,
                position_restriction: static_address_offsets.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// defines a list of adjustable objects that can be referenced by a function or group
#[derive(Clone)]
pub struct RefCharacteristic {
    pub identifier_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for RefCharacteristic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("RefCharacteristic")
            .field("identifier_list", &self.identifier_list)
            .finish()
    }
}

impl RefCharacteristic {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            identifier_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for RefCharacteristic {
    fn eq(&self, other: &Self) -> bool {
        self.identifier_list == other.identifier_list
    }
}

impl A2lObject<(Vec<u32>, ())> for RefCharacteristic {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for RefCharacteristic {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut identifier_list = Vec::new();
        let mut __identifier_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    identifier_list.push(value);
                    __identifier_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__identifier_list_location, __dummy),
            },
            identifier_list,
        })
    }
}

impl RefCharacteristic {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.identifier_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// defines a list of groups for use by `USER_RIGHTS`
#[derive(Clone)]
pub struct RefGroup {
    pub identifier_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for RefGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("RefGroup")
            .field("identifier_list", &self.identifier_list)
            .finish()
    }
}

impl RefGroup {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            identifier_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for RefGroup {
    fn eq(&self, other: &Self) -> bool {
        self.identifier_list == other.identifier_list
    }
}

impl A2lObject<(Vec<u32>, ())> for RefGroup {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for RefGroup {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut identifier_list = Vec::new();
        let mut __identifier_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    identifier_list.push(value);
                    __identifier_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__identifier_list_location, __dummy),
            },
            identifier_list,
        })
    }
}

impl RefGroup {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.identifier_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// defines a list of measurement objects that can be referenced by a group
#[derive(Clone)]
pub struct RefMeasurement {
    pub identifier_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for RefMeasurement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("RefMeasurement")
            .field("identifier_list", &self.identifier_list)
            .finish()
    }
}

impl RefMeasurement {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            identifier_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for RefMeasurement {
    fn eq(&self, other: &Self) -> bool {
        self.identifier_list == other.identifier_list
    }
}

impl A2lObject<(Vec<u32>, ())> for RefMeasurement {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for RefMeasurement {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut identifier_list = Vec::new();
        let mut __identifier_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    identifier_list.push(value);
                    __identifier_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__identifier_list_location, __dummy),
            },
            identifier_list,
        })
    }
}

impl RefMeasurement {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.identifier_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// reference to a `MEMORY_SEGMENT`
#[derive(Clone)]
pub struct RefMemorySegment {
    pub name: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for RefMemorySegment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("RefMemorySegment")
            .field("name", &self.name)
            .finish()
    }
}

impl RefMemorySegment {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String) -> Self {
        Self {
            name,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for RefMemorySegment {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name
    }
}

impl A2lObject<(u32, ())> for RefMemorySegment {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for RefMemorySegment {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for RefMemorySegment {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __dummy),
            },
            name,
        })
    }
}

impl RefMemorySegment {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// reference to a UNIT
#[derive(Clone)]
pub struct RefUnit {
    pub unit: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for RefUnit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("RefUnit").field("unit", &self.unit).finish()
    }
}

impl RefUnit {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(unit: String) -> Self {
        Self {
            unit,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for RefUnit {
    fn eq(&self, other: &Self) -> bool {
        self.unit == other.unit
    }
}

impl A2lObject<(u32, ())> for RefUnit {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for RefUnit {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__unit_location, unit) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__unit_location, __dummy),
            },
            unit,
        })
    }
}

impl RefUnit {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.unit, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// indicates that the data at the given position is reserved and should not be interpreted by the MCD system
#[derive(Clone)]
pub struct Reserved {
    pub position: u16,
    pub data_size: DataTypeSize,
    pub(crate) __block_info: BlockInfo<((u32, bool), u32)>,
}

impl std::fmt::Debug for Reserved {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Reserved")
            .field("position", &self.position)
            .field("data_size", &self.data_size)
            .finish()
    }
}

impl Reserved {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(position: u16, data_size: DataTypeSize) -> Self {
        Self {
            position,
            data_size,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), 0u32),
            },
        }
    }
}

impl PartialEq for Reserved {
    fn eq(&self, other: &Self) -> bool {
        (self.position == other.position) && (self.data_size == other.data_size)
    }
}

impl A2lObject<((u32, bool), u32)> for Reserved {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Reserved {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__position_location, position) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__data_size_location, data_size) = (
            parser.get_current_line_offset(),
            DataTypeSize::parse(parser, context, 0)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__position_location, __data_size_location),
            },
            position,
            data_size,
        })
    }
}

impl Reserved {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.position,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_str(
            &self.data_size.to_string(),
            self.__block_info.item_location.1,
        );
        writer.finish()
    }
}

/// Used within `BIT_OPERATION` to right-shift the bits of a value
#[derive(Clone)]
pub struct RightShift {
    pub bitcount: u32,
    pub(crate) __block_info: BlockInfo<((u32, bool), ())>,
}

impl std::fmt::Debug for RightShift {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("RightShift")
            .field("bitcount", &self.bitcount)
            .finish()
    }
}

impl RightShift {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(bitcount: u32) -> Self {
        Self {
            bitcount,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), ()),
            },
        }
    }
}

impl PartialEq for RightShift {
    fn eq(&self, other: &Self) -> bool {
        self.bitcount == other.bitcount
    }
}

impl A2lObject<((u32, bool), ())> for RightShift {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for RightShift {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__bitcount_location, bitcount) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__bitcount_location, __dummy),
            },
            bitcount,
        })
    }
}

impl RightShift {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.bitcount,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.finish()
    }
}

/// Describes the storage of the ECU-internal result of interpolation (RIP)
#[derive(Clone)]
pub struct RipAddrDim {
    pub position: u16,
    pub datatype: DataType,
    pub(crate) __block_info: BlockInfo<((u32, bool), u32)>,
}

impl std::fmt::Debug for RipAddrDim {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("RipAddrDim")
            .field("position", &self.position)
            .field("datatype", &self.datatype)
            .finish()
    }
}

impl RipAddrDim {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(position: u16, datatype: DataType) -> Self {
        Self {
            position,
            datatype,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), 0u32),
            },
        }
    }
}

impl PartialEq for RipAddrDim {
    fn eq(&self, other: &Self) -> bool {
        (self.position == other.position) && (self.datatype == other.datatype)
    }
}

impl A2lObject<((u32, bool), u32)> for RipAddrDim {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for RipAddrDim {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__position_location, position) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__datatype_location, datatype) = (
            parser.get_current_line_offset(),
            DataType::parse(parser, context, 0)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__position_location, __datatype_location),
            },
            position,
            datatype,
        })
    }
}

impl RipAddrDim {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.position,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_str(
            &self.datatype.to_string(),
            self.__block_info.item_location.1,
        );
        writer.finish()
    }
}

/// indicates that the current group is at the root of the navigation tree
#[derive(Clone)]
pub struct Root {
    pub(crate) __block_info: BlockInfo<()>,
}

impl std::fmt::Debug for Root {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Root").finish()
    }
}

impl Root {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (),
            },
        }
    }
}

impl PartialEq for Root {
    fn eq(&self, _other: &Self) -> bool {
        true
    }
}

impl A2lObject<()> for Root {
    fn get_layout(&self) -> &BlockInfo<()> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<()> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Root {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (),
            },
        })
    }
}

impl Root {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let writer = writer::Writer::new(indent);
        writer.finish()
    }
}

/// sets the standard record layout for the module
#[derive(Clone)]
pub struct SRecLayout {
    pub name: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for SRecLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SRecLayout")
            .field("name", &self.name)
            .finish()
    }
}

impl SRecLayout {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String) -> Self {
        Self {
            name,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for SRecLayout {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name
    }
}

impl A2lObject<(u32, ())> for SRecLayout {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for SRecLayout {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for SRecLayout {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __dummy),
            },
            name,
        })
    }
}

impl SRecLayout {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// Description of the shift operand in the deposit structure to compute the axis points for fixed characteristic curves and fixed characteristic maps
#[derive(Clone)]
pub struct ShiftOpDim {
    pub position: u16,
    pub datatype: DataType,
    pub(crate) __block_info: BlockInfo<((u32, bool), u32)>,
}

impl std::fmt::Debug for ShiftOpDim {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ShiftOpDim")
            .field("position", &self.position)
            .field("datatype", &self.datatype)
            .finish()
    }
}

impl ShiftOpDim {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(position: u16, datatype: DataType) -> Self {
        Self {
            position,
            datatype,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), 0u32),
            },
        }
    }
}

impl PartialEq for ShiftOpDim {
    fn eq(&self, other: &Self) -> bool {
        (self.position == other.position) && (self.datatype == other.datatype)
    }
}

impl A2lObject<((u32, bool), u32)> for ShiftOpDim {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for ShiftOpDim {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__position_location, position) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__datatype_location, datatype) = (
            parser.get_current_line_offset(),
            DataType::parse(parser, context, 0)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__position_location, __datatype_location),
            },
            position,
            datatype,
        })
    }
}

impl ShiftOpDim {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.position,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_str(
            &self.datatype.to_string(),
            self.__block_info.item_location.1,
        );
        writer.finish()
    }
}

/// the seven base dimensions required to define an extended SI unit
#[derive(Clone)]
pub struct SiExponents {
    pub length: i16,
    pub mass: i16,
    pub time: i16,
    pub electric_current: i16,
    pub temperature: i16,
    pub amount_of_substance: i16,
    pub luminous_intensity: i16,
    pub(crate) __block_info: BlockInfo<(
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
    )>,
}

impl std::fmt::Debug for SiExponents {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SiExponents")
            .field("length", &self.length)
            .field("mass", &self.mass)
            .field("time", &self.time)
            .field("electric_current", &self.electric_current)
            .field("temperature", &self.temperature)
            .field("amount_of_substance", &self.amount_of_substance)
            .field("luminous_intensity", &self.luminous_intensity)
            .finish()
    }
}

impl SiExponents {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        length: i16,
        mass: i16,
        time: i16,
        electric_current: i16,
        temperature: i16,
        amount_of_substance: i16,
        luminous_intensity: i16,
    ) -> Self {
        Self {
            length,
            mass,
            time,
            electric_current,
            temperature,
            amount_of_substance,
            luminous_intensity,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (
                    (0u32, false),
                    (0u32, false),
                    (0u32, false),
                    (0u32, false),
                    (0u32, false),
                    (0u32, false),
                    (0u32, false),
                ),
            },
        }
    }
}

impl PartialEq for SiExponents {
    fn eq(&self, other: &Self) -> bool {
        (self.length == other.length)
            && (self.mass == other.mass)
            && (self.time == other.time)
            && (self.electric_current == other.electric_current)
            && (self.temperature == other.temperature)
            && (self.amount_of_substance == other.amount_of_substance)
            && (self.luminous_intensity == other.luminous_intensity)
    }
}

impl
    A2lObject<(
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
    )> for SiExponents
{
    fn get_layout(
        &self,
    ) -> &BlockInfo<(
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
    )> {
        &self.__block_info
    }
    fn get_layout_mut(
        &mut self,
    ) -> &mut BlockInfo<(
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
        (u32, bool),
    )> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for SiExponents {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__length_location, length) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<i16>(context)?;
            ((line, is_hex), value)
        };
        let (__mass_location, mass) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<i16>(context)?;
            ((line, is_hex), value)
        };
        let (__time_location, time) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<i16>(context)?;
            ((line, is_hex), value)
        };
        let (__electric_current_location, electric_current) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<i16>(context)?;
            ((line, is_hex), value)
        };
        let (__temperature_location, temperature) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<i16>(context)?;
            ((line, is_hex), value)
        };
        let (__amount_of_substance_location, amount_of_substance) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<i16>(context)?;
            ((line, is_hex), value)
        };
        let (__luminous_intensity_location, luminous_intensity) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<i16>(context)?;
            ((line, is_hex), value)
        };
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __length_location,
                    __mass_location,
                    __time_location,
                    __electric_current_location,
                    __temperature_location,
                    __amount_of_substance_location,
                    __luminous_intensity_location,
                ),
            },
            length,
            mass,
            time,
            electric_current,
            temperature,
            amount_of_substance,
            luminous_intensity,
        })
    }
}

impl SiExponents {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.length,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_integer(
            self.mass,
            self.__block_info.item_location.1 .1,
            self.__block_info.item_location.1 .0,
        );
        writer.add_integer(
            self.time,
            self.__block_info.item_location.2 .1,
            self.__block_info.item_location.2 .0,
        );
        writer.add_integer(
            self.electric_current,
            self.__block_info.item_location.3 .1,
            self.__block_info.item_location.3 .0,
        );
        writer.add_integer(
            self.temperature,
            self.__block_info.item_location.4 .1,
            self.__block_info.item_location.4 .0,
        );
        writer.add_integer(
            self.amount_of_substance,
            self.__block_info.item_location.5 .1,
            self.__block_info.item_location.5 .0,
        );
        writer.add_integer(
            self.luminous_intensity,
            self.__block_info.item_location.6 .1,
            self.__block_info.item_location.6 .0,
        );
        writer.finish()
    }
}

/// used in `BIT_OPERATION` to specify that sign extension should be performed
#[derive(Clone)]
pub struct SignExtend {
    pub(crate) __block_info: BlockInfo<()>,
}

impl std::fmt::Debug for SignExtend {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SignExtend").finish()
    }
}

impl SignExtend {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (),
            },
        }
    }
}

impl PartialEq for SignExtend {
    fn eq(&self, _other: &Self) -> bool {
        true
    }
}

impl A2lObject<()> for SignExtend {
    fn get_layout(&self) -> &BlockInfo<()> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<()> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for SignExtend {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (),
            },
        })
    }
}

impl SignExtend {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let writer = writer::Writer::new(indent);
        writer.finish()
    }
}

/// Description of the address of the input quantity in an adjustable object
#[derive(Clone)]
pub struct SrcAddrDim {
    pub position: u16,
    pub datatype: DataType,
    pub(crate) __block_info: BlockInfo<((u32, bool), u32)>,
}

impl std::fmt::Debug for SrcAddrDim {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SrcAddrDim")
            .field("position", &self.position)
            .field("datatype", &self.datatype)
            .finish()
    }
}

impl SrcAddrDim {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(position: u16, datatype: DataType) -> Self {
        Self {
            position,
            datatype,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: ((0u32, false), 0u32),
            },
        }
    }
}

impl PartialEq for SrcAddrDim {
    fn eq(&self, other: &Self) -> bool {
        (self.position == other.position) && (self.datatype == other.datatype)
    }
}

impl A2lObject<((u32, bool), u32)> for SrcAddrDim {
    fn get_layout(&self) -> &BlockInfo<((u32, bool), u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<((u32, bool), u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for SrcAddrDim {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__position_location, position) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__datatype_location, datatype) = (
            parser.get_current_line_offset(),
            DataType::parse(parser, context, 0)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__position_location, __datatype_location),
            },
            position,
            datatype,
        })
    }
}

impl SrcAddrDim {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_integer(
            self.position,
            self.__block_info.item_location.0 .1,
            self.__block_info.item_location.0 .0,
        );
        writer.add_str(
            &self.datatype.to_string(),
            self.__block_info.item_location.1,
        );
        writer.finish()
    }
}

/// indicates that the start addresses of axes and function values of an adjustable object do not change when removing or inserting axis points
#[derive(Clone)]
pub struct StaticAddressOffsets {
    pub(crate) __block_info: BlockInfo<()>,
}

impl std::fmt::Debug for StaticAddressOffsets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("StaticAddressOffsets").finish()
    }
}

impl StaticAddressOffsets {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (),
            },
        }
    }
}

impl PartialEq for StaticAddressOffsets {
    fn eq(&self, _other: &Self) -> bool {
        true
    }
}

impl A2lObject<()> for StaticAddressOffsets {
    fn get_layout(&self) -> &BlockInfo<()> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<()> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for StaticAddressOffsets {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (),
            },
        })
    }
}

impl StaticAddressOffsets {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let writer = writer::Writer::new(indent);
        writer.finish()
    }
}

/// indicates that an adjustable object with dynamic number of axis points does not compact or expand data when removing or inserting axis points
#[derive(Clone)]
pub struct StaticRecordLayout {
    pub(crate) __block_info: BlockInfo<()>,
}

impl std::fmt::Debug for StaticRecordLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("StaticRecordLayout").finish()
    }
}

impl StaticRecordLayout {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (),
            },
        }
    }
}

impl PartialEq for StaticRecordLayout {
    fn eq(&self, _other: &Self) -> bool {
        true
    }
}

impl A2lObject<()> for StaticRecordLayout {
    fn get_layout(&self) -> &BlockInfo<()> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<()> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for StaticRecordLayout {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (),
            },
        })
    }
}

impl StaticRecordLayout {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let writer = writer::Writer::new(indent);
        writer.finish()
    }
}

/// used to split up the value range of ECU internal values into a numerical and a verbal part
#[derive(Clone)]
pub struct StatusStringRef {
    pub conversion_table: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for StatusStringRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("StatusStringRef")
            .field("conversion_table", &self.conversion_table)
            .finish()
    }
}

impl StatusStringRef {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(conversion_table: String) -> Self {
        Self {
            conversion_table,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for StatusStringRef {
    fn eq(&self, other: &Self) -> bool {
        self.conversion_table == other.conversion_table
    }
}

impl A2lObject<(u32, ())> for StatusStringRef {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for StatusStringRef {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__conversion_table_location, conversion_table) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__conversion_table_location, __dummy),
            },
            conversion_table,
        })
    }
}

impl StatusStringRef {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.conversion_table, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// step size when adjusting the value of a CHARACTERISTIC, `AXIS_PTS` or `AXIS_DESCR`
#[derive(Clone)]
pub struct StepSize {
    pub step_size: f64,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for StepSize {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("StepSize")
            .field("step_size", &self.step_size)
            .finish()
    }
}

impl StepSize {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(step_size: f64) -> Self {
        Self {
            step_size,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for StepSize {
    fn eq(&self, other: &Self) -> bool {
        self.step_size == other.step_size
    }
}

impl A2lObject<(u32, ())> for StepSize {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for StepSize {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__step_size_location, step_size) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__step_size_location, __dummy),
            },
            step_size,
        })
    }
}

impl StepSize {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_float(self.step_size, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// defines a single component of a `TYPEDEF_STRUCTURE`
#[derive(Clone)]
pub struct StructureComponent {
    pub component_name: String,
    pub component_type: String,
    pub address_offset: u32,
    pub address_type: Option<AddressType>,
    pub layout: Option<Layout>,
    pub matrix_dim: Option<MatrixDim>,
    pub symbol_type_link: Option<SymbolTypeLink>,
    pub(crate) __block_info: BlockInfo<(u32, u32, (u32, bool))>,
}

impl std::fmt::Debug for StructureComponent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("StructureComponent")
            .field("component_name", &self.component_name)
            .field("component_type", &self.component_type)
            .field("address_offset", &self.address_offset)
            .field("address_type", &self.address_type)
            .field("layout", &self.layout)
            .field("matrix_dim", &self.matrix_dim)
            .field("symbol_type_link", &self.symbol_type_link)
            .finish()
    }
}

impl StructureComponent {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(component_name: String, component_type: String, address_offset: u32) -> Self {
        Self {
            component_name,
            component_type,
            address_offset,
            address_type: None,
            layout: None,
            matrix_dim: None,
            symbol_type_link: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (1u32, 0u32, (0u32, false)),
            },
        }
    }
}

impl PartialEq for StructureComponent {
    fn eq(&self, other: &Self) -> bool {
        (self.component_name == other.component_name)
            && (self.component_type == other.component_type)
            && (self.address_offset == other.address_offset)
            && (self.address_type == other.address_type)
            && (self.layout == other.layout)
            && (self.matrix_dim == other.matrix_dim)
            && (self.symbol_type_link == other.symbol_type_link)
    }
}

impl A2lObject<(u32, u32, (u32, bool))> for StructureComponent {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, (u32, bool))> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, (u32, bool))> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(address_type) = &mut self.address_type {
            address_type.merge_includes();
        }
        if let Some(layout) = &mut self.layout {
            layout.merge_includes();
        }
        if let Some(matrix_dim) = &mut self.matrix_dim {
            matrix_dim.merge_includes();
        }
        if let Some(symbol_type_link) = &mut self.symbol_type_link {
            symbol_type_link.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for StructureComponent {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__component_name_location, component_name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__component_type_location, component_type) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__address_offset_location, address_offset) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let mut address_type: Option<AddressType> = None;
        let mut layout: Option<Layout> = None;
        let mut matrix_dim: Option<MatrixDim> = None;
        let mut symbol_type_link: Option<SymbolTypeLink> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 4usize] =
                ["ADDRESS_TYPE", "LAYOUT", "MATRIX_DIM", "SYMBOL_TYPE_LINK"];
            match tag {
                "ADDRESS_TYPE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "ADDRESS_TYPE",
                        A2lVersion::V1_7_1,
                    )?;
                    let newitem = AddressType::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, address_type.is_some())?;
                    address_type = Some(newitem);
                }
                "LAYOUT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Layout::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, layout.is_some())?;
                    layout = Some(newitem);
                }
                "MATRIX_DIM" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = MatrixDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, matrix_dim.is_some())?;
                    matrix_dim = Some(newitem);
                }
                "SYMBOL_TYPE_LINK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = SymbolTypeLink::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, symbol_type_link.is_some())?;
                    symbol_type_link = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __component_name_location,
                    __component_type_location,
                    __address_offset_location,
                ),
            },
            component_name,
            component_type,
            address_offset,
            address_type,
            layout,
            matrix_dim,
            symbol_type_link,
        })
    }
}

impl StructureComponent {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.component_name, self.__block_info.item_location.0);
        writer.add_str(&self.component_type, self.__block_info.item_location.1);
        writer.add_integer(
            self.address_offset,
            self.__block_info.item_location.2 .1,
            self.__block_info.item_location.2 .0,
        );
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(address_type) = &self.address_type {
            let address_type_out = address_type.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ADDRESS_TYPE",
                item_text: address_type_out,
                is_block: false,
                incfile: &address_type.__block_info.incfile,
                uid: address_type.__block_info.uid,
                line: address_type.__block_info.line,
                start_offset: address_type.__block_info.start_offset,
                end_offset: address_type.__block_info.end_offset,
                position_restriction: address_type.pos_restrict(),
            });
        }
        if let Some(layout) = &self.layout {
            let layout_out = layout.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "LAYOUT",
                item_text: layout_out,
                is_block: false,
                incfile: &layout.__block_info.incfile,
                uid: layout.__block_info.uid,
                line: layout.__block_info.line,
                start_offset: layout.__block_info.start_offset,
                end_offset: layout.__block_info.end_offset,
                position_restriction: layout.pos_restrict(),
            });
        }
        if let Some(matrix_dim) = &self.matrix_dim {
            let matrix_dim_out = matrix_dim.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MATRIX_DIM",
                item_text: matrix_dim_out,
                is_block: false,
                incfile: &matrix_dim.__block_info.incfile,
                uid: matrix_dim.__block_info.uid,
                line: matrix_dim.__block_info.line,
                start_offset: matrix_dim.__block_info.start_offset,
                end_offset: matrix_dim.__block_info.end_offset,
                position_restriction: matrix_dim.pos_restrict(),
            });
        }
        if let Some(symbol_type_link) = &self.symbol_type_link {
            let symbol_type_link_out = symbol_type_link.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SYMBOL_TYPE_LINK",
                item_text: symbol_type_link_out,
                is_block: false,
                incfile: &symbol_type_link.__block_info.incfile,
                uid: symbol_type_link.__block_info.uid,
                line: symbol_type_link.__block_info.line,
                start_offset: symbol_type_link.__block_info.start_offset,
                end_offset: symbol_type_link.__block_info.end_offset,
                position_restriction: symbol_type_link.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// a list of identifiers of functions which are sub-functions of the current function
#[derive(Clone)]
pub struct SubFunction {
    pub identifier_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for SubFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SubFunction")
            .field("identifier_list", &self.identifier_list)
            .finish()
    }
}

impl SubFunction {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            identifier_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for SubFunction {
    fn eq(&self, other: &Self) -> bool {
        self.identifier_list == other.identifier_list
    }
}

impl A2lObject<(Vec<u32>, ())> for SubFunction {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for SubFunction {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut identifier_list = Vec::new();
        let mut __identifier_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    identifier_list.push(value);
                    __identifier_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__identifier_list_location, __dummy),
            },
            identifier_list,
        })
    }
}

impl SubFunction {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.identifier_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// a list of identifiers of groups which are subgroups of the current group
#[derive(Clone)]
pub struct SubGroup {
    pub identifier_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for SubGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SubGroup")
            .field("identifier_list", &self.identifier_list)
            .finish()
    }
}

impl SubGroup {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            identifier_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for SubGroup {
    fn eq(&self, other: &Self) -> bool {
        self.identifier_list == other.identifier_list
    }
}

impl A2lObject<(Vec<u32>, ())> for SubGroup {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for SubGroup {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut identifier_list = Vec::new();
        let mut __identifier_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    identifier_list.push(value);
                    __identifier_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__identifier_list_location, __dummy),
            },
            identifier_list,
        })
    }
}

impl SubGroup {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.identifier_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// Name of the ECU manufacturer
#[derive(Clone)]
pub struct Supplier {
    pub manufacturer: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for Supplier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Supplier")
            .field("manufacturer", &self.manufacturer)
            .finish()
    }
}

impl Supplier {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(manufacturer: String) -> Self {
        Self {
            manufacturer,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for Supplier {
    fn eq(&self, other: &Self) -> bool {
        self.manufacturer == other.manufacturer
    }
}

impl A2lObject<(u32, ())> for Supplier {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Supplier {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__manufacturer_location, manufacturer) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__manufacturer_location, __dummy),
            },
            manufacturer,
        })
    }
}

impl Supplier {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.manufacturer, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// specifes the name of a symbol within a linker map file that corresponds to the a2l object
#[derive(Clone)]
pub struct SymbolLink {
    pub symbol_name: String,
    pub offset: i32,
    pub(crate) __block_info: BlockInfo<(u32, (u32, bool))>,
}

impl std::fmt::Debug for SymbolLink {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SymbolLink")
            .field("symbol_name", &self.symbol_name)
            .field("offset", &self.offset)
            .finish()
    }
}

impl SymbolLink {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(symbol_name: String, offset: i32) -> Self {
        Self {
            symbol_name,
            offset,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, (0u32, false)),
            },
        }
    }
}

impl PartialEq for SymbolLink {
    fn eq(&self, other: &Self) -> bool {
        (self.symbol_name == other.symbol_name) && (self.offset == other.offset)
    }
}

impl A2lObject<(u32, (u32, bool))> for SymbolLink {
    fn get_layout(&self) -> &BlockInfo<(u32, (u32, bool))> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, (u32, bool))> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for SymbolLink {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__symbol_name_location, symbol_name) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__offset_location, offset) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<i32>(context)?;
            ((line, is_hex), value)
        };
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__symbol_name_location, __offset_location),
            },
            symbol_name,
            offset,
        })
    }
}

impl SymbolLink {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.symbol_name, self.__block_info.item_location.0);
        writer.add_integer(
            self.offset,
            self.__block_info.item_location.1 .1,
            self.__block_info.item_location.1 .0,
        );
        writer.finish()
    }
}

/// Specifies the name of a symbol within a linker map file or debug file that describes a class, class member, structure or structure component
#[derive(Clone)]
pub struct SymbolTypeLink {
    pub symbol_type: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for SymbolTypeLink {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SymbolTypeLink")
            .field("symbol_type", &self.symbol_type)
            .finish()
    }
}

impl SymbolTypeLink {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(symbol_type: String) -> Self {
        Self {
            symbol_type,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for SymbolTypeLink {
    fn eq(&self, other: &Self) -> bool {
        self.symbol_type == other.symbol_type
    }
}

impl A2lObject<(u32, ())> for SymbolTypeLink {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for SymbolTypeLink {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__symbol_type_location, symbol_type) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__symbol_type_location, __dummy),
            },
            symbol_type,
        })
    }
}

impl SymbolTypeLink {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.symbol_type, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// defines a system constant that can be used in conversion formulas
#[derive(Clone)]
pub struct SystemConstant {
    pub name: String,
    pub value: String,
    pub(crate) __block_info: BlockInfo<(u32, u32)>,
}

impl std::fmt::Debug for SystemConstant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SystemConstant")
            .field("name", &self.name)
            .field("value", &self.value)
            .finish()
    }
}

impl SystemConstant {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String, value: String) -> Self {
        Self {
            name,
            value,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, 0u32),
            },
        }
    }
}

impl PartialEq for SystemConstant {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name) && (self.value == other.value)
    }
}

impl A2lObject<(u32, u32)> for SystemConstant {
    fn get_layout(&self) -> &BlockInfo<(u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for SystemConstant {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__value_location, value) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __value_location),
            },
            name,
            value,
        })
    }
}

impl SystemConstant {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.value, self.__block_info.item_location.1);
        writer.finish()
    }
}

///Auto generated for repeating sequence `tab_entry` in block `COMPU_TAB`
#[derive(Clone)]
pub struct TabEntryStruct {
    pub in_val: f64,
    pub out_val: f64,
    pub(crate) __block_info: BlockInfo<(u32, u32)>,
}

impl std::fmt::Debug for TabEntryStruct {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TabEntryStruct")
            .field("in_val", &self.in_val)
            .field("out_val", &self.out_val)
            .finish()
    }
}

impl TabEntryStruct {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(in_val: f64, out_val: f64) -> Self {
        Self {
            in_val,
            out_val,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (1u32, 0u32),
            },
        }
    }
}

impl PartialEq for TabEntryStruct {
    fn eq(&self, other: &Self) -> bool {
        (self.in_val == other.in_val) && (self.out_val == other.out_val)
    }
}

impl A2lObject<(u32, u32)> for TabEntryStruct {
    fn get_layout(&self) -> &BlockInfo<(u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for TabEntryStruct {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__in_val_location, in_val) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__out_val_location, out_val) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__in_val_location, __out_val_location),
            },
            in_val,
            out_val,
        })
    }
}

impl TabEntryStruct {
    pub(crate) fn stringify(&self, writer: &mut writer::Writer) {
        writer.add_float(self.in_val, self.__block_info.item_location.0);
        writer.add_float(self.out_val, self.__block_info.item_location.1);
    }
}

/// Definition of call to an external function (32-bit or 64-bit DLL) for converting calibration object values between their implementation format and physical format
#[derive(Clone)]
pub struct Transformer {
    pub name: String,
    pub version: String,
    pub dllname_32bit: String,
    pub dllname_64bit: String,
    pub timeout: u16,
    pub trigger: TransformerTrigger,
    pub inverse_transformer: String,
    pub transformer_in_objects: Option<TransformerInObjects>,
    pub transformer_out_objects: Option<TransformerOutObjects>,
    pub(crate) __block_info: BlockInfo<(u32, u32, u32, u32, (u32, bool), u32, u32)>,
}

impl std::fmt::Debug for Transformer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Transformer")
            .field("name", &self.name)
            .field("version", &self.version)
            .field("dllname_32bit", &self.dllname_32bit)
            .field("dllname_64bit", &self.dllname_64bit)
            .field("timeout", &self.timeout)
            .field("trigger", &self.trigger)
            .field("inverse_transformer", &self.inverse_transformer)
            .field("transformer_in_objects", &self.transformer_in_objects)
            .field("transformer_out_objects", &self.transformer_out_objects)
            .finish()
    }
}

impl Transformer {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        name: String,
        version: String,
        dllname_32bit: String,
        dllname_64bit: String,
        timeout: u16,
        trigger: TransformerTrigger,
        inverse_transformer: String,
    ) -> Self {
        Self {
            name,
            version,
            dllname_32bit,
            dllname_64bit,
            timeout,
            trigger,
            inverse_transformer,
            transformer_in_objects: None,
            transformer_out_objects: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32, 1u32, 0u32, (0u32, false), 0u32, 0u32),
            },
        }
    }
}

impl PartialEq for Transformer {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.version == other.version)
            && (self.dllname_32bit == other.dllname_32bit)
            && (self.dllname_64bit == other.dllname_64bit)
            && (self.timeout == other.timeout)
            && (self.trigger == other.trigger)
            && (self.inverse_transformer == other.inverse_transformer)
            && (self.transformer_in_objects == other.transformer_in_objects)
            && (self.transformer_out_objects == other.transformer_out_objects)
    }
}

impl A2lObject<(u32, u32, u32, u32, (u32, bool), u32, u32)> for Transformer {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, u32, u32, (u32, bool), u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, u32, u32, (u32, bool), u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(transformer_in_objects) = &mut self.transformer_in_objects {
            transformer_in_objects.merge_includes();
        }
        if let Some(transformer_out_objects) = &mut self.transformer_out_objects {
            transformer_out_objects.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for Transformer {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for Transformer {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__version_location, version) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__dllname_32bit_location, dllname_32bit) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__dllname_64bit_location, dllname_64bit) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__timeout_location, timeout) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__trigger_location, trigger) = (
            parser.get_current_line_offset(),
            TransformerTrigger::parse(parser, context, 0)?,
        );
        let (__inverse_transformer_location, inverse_transformer) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let mut transformer_in_objects: Option<TransformerInObjects> = None;
        let mut transformer_out_objects: Option<TransformerOutObjects> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 2usize] = ["TRANSFORMER_IN_OBJECTS", "TRANSFORMER_OUT_OBJECTS"];
            match tag {
                "TRANSFORMER_IN_OBJECTS" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = TransformerInObjects::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        transformer_in_objects.is_some(),
                    )?;
                    transformer_in_objects = Some(newitem);
                }
                "TRANSFORMER_OUT_OBJECTS" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = TransformerOutObjects::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        transformer_out_objects.is_some(),
                    )?;
                    transformer_out_objects = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __version_location,
                    __dllname_32bit_location,
                    __dllname_64bit_location,
                    __timeout_location,
                    __trigger_location,
                    __inverse_transformer_location,
                ),
            },
            name,
            version,
            dllname_32bit,
            dllname_64bit,
            timeout,
            trigger,
            inverse_transformer,
            transformer_in_objects,
            transformer_out_objects,
        })
    }
}

impl Transformer {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.version, self.__block_info.item_location.1);
        writer.add_quoted_string(&self.dllname_32bit, self.__block_info.item_location.2);
        writer.add_quoted_string(&self.dllname_64bit, self.__block_info.item_location.3);
        writer.add_integer(
            self.timeout,
            self.__block_info.item_location.4 .1,
            self.__block_info.item_location.4 .0,
        );
        writer.add_str(&self.trigger.to_string(), self.__block_info.item_location.5);
        writer.add_str(&self.inverse_transformer, self.__block_info.item_location.6);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(transformer_in_objects) = &self.transformer_in_objects {
            let transformer_in_objects_out = transformer_in_objects.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "TRANSFORMER_IN_OBJECTS",
                item_text: transformer_in_objects_out,
                is_block: true,
                incfile: &transformer_in_objects.__block_info.incfile,
                uid: transformer_in_objects.__block_info.uid,
                line: transformer_in_objects.__block_info.line,
                start_offset: transformer_in_objects.__block_info.start_offset,
                end_offset: transformer_in_objects.__block_info.end_offset,
                position_restriction: transformer_in_objects.pos_restrict(),
            });
        }
        if let Some(transformer_out_objects) = &self.transformer_out_objects {
            let transformer_out_objects_out = transformer_out_objects.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "TRANSFORMER_OUT_OBJECTS",
                item_text: transformer_out_objects_out,
                is_block: true,
                incfile: &transformer_out_objects.__block_info.incfile,
                uid: transformer_out_objects.__block_info.uid,
                line: transformer_out_objects.__block_info.line,
                start_offset: transformer_out_objects.__block_info.start_offset,
                end_offset: transformer_out_objects.__block_info.end_offset,
                position_restriction: transformer_out_objects.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// provides a list of inputs for a TRANSFORMER
#[derive(Clone)]
pub struct TransformerInObjects {
    pub identifier_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for TransformerInObjects {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TransformerInObjects")
            .field("identifier_list", &self.identifier_list)
            .finish()
    }
}

impl TransformerInObjects {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            identifier_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for TransformerInObjects {
    fn eq(&self, other: &Self) -> bool {
        self.identifier_list == other.identifier_list
    }
}

impl A2lObject<(Vec<u32>, ())> for TransformerInObjects {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for TransformerInObjects {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut identifier_list = Vec::new();
        let mut __identifier_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    identifier_list.push(value);
                    __identifier_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__identifier_list_location, __dummy),
            },
            identifier_list,
        })
    }
}

impl TransformerInObjects {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.identifier_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// provides a list of outputs for a TRANSFORMER
#[derive(Clone)]
pub struct TransformerOutObjects {
    pub identifier_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for TransformerOutObjects {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TransformerOutObjects")
            .field("identifier_list", &self.identifier_list)
            .finish()
    }
}

impl TransformerOutObjects {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            identifier_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for TransformerOutObjects {
    fn eq(&self, other: &Self) -> bool {
        self.identifier_list == other.identifier_list
    }
}

impl A2lObject<(Vec<u32>, ())> for TransformerOutObjects {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for TransformerOutObjects {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut identifier_list = Vec::new();
        let mut __identifier_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    identifier_list.push(value);
                    __identifier_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__identifier_list_location, __dummy),
            },
            identifier_list,
        })
    }
}

impl TransformerOutObjects {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.identifier_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// the trigger conditions of a TRANSFORMER
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TransformerTrigger {
    OnUserRequest,
    OnChange,
}

impl ParseableA2lObject for TransformerTrigger {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "ON_USER_REQUEST" => Ok(Self::OnUserRequest),
            "ON_CHANGE" => Ok(Self::OnChange),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for TransformerTrigger {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::OnUserRequest => "ON_USER_REQUEST",
            Self::OnChange => "ON_CHANGE",
        };
        f.write_str(tag)
    }
}

/// Type definition of an axis object
#[derive(Clone)]
pub struct TypedefAxis {
    pub name: String,
    pub long_identifier: String,
    pub input_quantity: String,
    pub record_layout: String,
    pub max_diff: f64,
    pub conversion: String,
    pub max_axis_points: u16,
    pub lower_limit: f64,
    pub upper_limit: f64,
    pub byte_order: Option<ByteOrder>,
    pub deposit: Option<Deposit>,
    pub extended_limits: Option<ExtendedLimits>,
    pub format: Option<Format>,
    pub monotony: Option<Monotony>,
    pub phys_unit: Option<PhysUnit>,
    pub step_size: Option<StepSize>,
    pub(crate) __block_info: BlockInfo<(u32, u32, u32, u32, u32, u32, (u32, bool), u32, u32)>,
}

impl std::fmt::Debug for TypedefAxis {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TypedefAxis")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("input_quantity", &self.input_quantity)
            .field("record_layout", &self.record_layout)
            .field("max_diff", &self.max_diff)
            .field("conversion", &self.conversion)
            .field("max_axis_points", &self.max_axis_points)
            .field("lower_limit", &self.lower_limit)
            .field("upper_limit", &self.upper_limit)
            .field("byte_order", &self.byte_order)
            .field("deposit", &self.deposit)
            .field("extended_limits", &self.extended_limits)
            .field("format", &self.format)
            .field("monotony", &self.monotony)
            .field("phys_unit", &self.phys_unit)
            .field("step_size", &self.step_size)
            .finish()
    }
}

impl TypedefAxis {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        name: String,
        long_identifier: String,
        input_quantity: String,
        record_layout: String,
        max_diff: f64,
        conversion: String,
        max_axis_points: u16,
        lower_limit: f64,
        upper_limit: f64,
    ) -> Self {
        Self {
            name,
            long_identifier,
            input_quantity,
            record_layout,
            max_diff,
            conversion,
            max_axis_points,
            lower_limit,
            upper_limit,
            byte_order: None,
            deposit: None,
            extended_limits: None,
            format: None,
            monotony: None,
            phys_unit: None,
            step_size: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (
                    0u32,
                    0u32,
                    1u32,
                    0u32,
                    0u32,
                    0u32,
                    (0u32, false),
                    0u32,
                    0u32,
                ),
            },
        }
    }
}

impl PartialEq for TypedefAxis {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.input_quantity == other.input_quantity)
            && (self.record_layout == other.record_layout)
            && (self.max_diff == other.max_diff)
            && (self.conversion == other.conversion)
            && (self.max_axis_points == other.max_axis_points)
            && (self.lower_limit == other.lower_limit)
            && (self.upper_limit == other.upper_limit)
            && (self.byte_order == other.byte_order)
            && (self.deposit == other.deposit)
            && (self.extended_limits == other.extended_limits)
            && (self.format == other.format)
            && (self.monotony == other.monotony)
            && (self.phys_unit == other.phys_unit)
            && (self.step_size == other.step_size)
    }
}

impl A2lObject<(u32, u32, u32, u32, u32, u32, (u32, bool), u32, u32)> for TypedefAxis {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, u32, u32, u32, u32, (u32, bool), u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(
        &mut self,
    ) -> &mut BlockInfo<(u32, u32, u32, u32, u32, u32, (u32, bool), u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(byte_order) = &mut self.byte_order {
            byte_order.merge_includes();
        }
        if let Some(deposit) = &mut self.deposit {
            deposit.merge_includes();
        }
        if let Some(extended_limits) = &mut self.extended_limits {
            extended_limits.merge_includes();
        }
        if let Some(format) = &mut self.format {
            format.merge_includes();
        }
        if let Some(monotony) = &mut self.monotony {
            monotony.merge_includes();
        }
        if let Some(phys_unit) = &mut self.phys_unit {
            phys_unit.merge_includes();
        }
        if let Some(step_size) = &mut self.step_size {
            step_size.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for TypedefAxis {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for TypedefAxis {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__input_quantity_location, input_quantity) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__record_layout_location, record_layout) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__max_diff_location, max_diff) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__conversion_location, conversion) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__max_axis_points_location, max_axis_points) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__lower_limit_location, lower_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__upper_limit_location, upper_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let mut byte_order: Option<ByteOrder> = None;
        let mut deposit: Option<Deposit> = None;
        let mut extended_limits: Option<ExtendedLimits> = None;
        let mut format: Option<Format> = None;
        let mut monotony: Option<Monotony> = None;
        let mut phys_unit: Option<PhysUnit> = None;
        let mut step_size: Option<StepSize> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 7usize] = [
                "BYTE_ORDER",
                "DEPOSIT",
                "EXTENDED_LIMITS",
                "FORMAT",
                "MONOTONY",
                "PHYS_UNIT",
                "STEP_SIZE",
            ];
            match tag {
                "BYTE_ORDER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ByteOrder::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, byte_order.is_some())?;
                    byte_order = Some(newitem);
                }
                "DEPOSIT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Deposit::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, deposit.is_some())?;
                    deposit = Some(newitem);
                }
                "EXTENDED_LIMITS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ExtendedLimits::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, extended_limits.is_some())?;
                    extended_limits = Some(newitem);
                }
                "FORMAT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Format::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, format.is_some())?;
                    format = Some(newitem);
                }
                "MONOTONY" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Monotony::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, monotony.is_some())?;
                    monotony = Some(newitem);
                }
                "PHYS_UNIT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = PhysUnit::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, phys_unit.is_some())?;
                    phys_unit = Some(newitem);
                }
                "STEP_SIZE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = StepSize::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, step_size.is_some())?;
                    step_size = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __input_quantity_location,
                    __record_layout_location,
                    __max_diff_location,
                    __conversion_location,
                    __max_axis_points_location,
                    __lower_limit_location,
                    __upper_limit_location,
                ),
            },
            name,
            long_identifier,
            input_quantity,
            record_layout,
            max_diff,
            conversion,
            max_axis_points,
            lower_limit,
            upper_limit,
            byte_order,
            deposit,
            extended_limits,
            format,
            monotony,
            phys_unit,
            step_size,
        })
    }
}

impl TypedefAxis {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_str(&self.input_quantity, self.__block_info.item_location.2);
        writer.add_str(&self.record_layout, self.__block_info.item_location.3);
        writer.add_float(self.max_diff, self.__block_info.item_location.4);
        writer.add_str(&self.conversion, self.__block_info.item_location.5);
        writer.add_integer(
            self.max_axis_points,
            self.__block_info.item_location.6 .1,
            self.__block_info.item_location.6 .0,
        );
        writer.add_float(self.lower_limit, self.__block_info.item_location.7);
        writer.add_float(self.upper_limit, self.__block_info.item_location.8);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(byte_order) = &self.byte_order {
            let byte_order_out = byte_order.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "BYTE_ORDER",
                item_text: byte_order_out,
                is_block: false,
                incfile: &byte_order.__block_info.incfile,
                uid: byte_order.__block_info.uid,
                line: byte_order.__block_info.line,
                start_offset: byte_order.__block_info.start_offset,
                end_offset: byte_order.__block_info.end_offset,
                position_restriction: byte_order.pos_restrict(),
            });
        }
        if let Some(deposit) = &self.deposit {
            let deposit_out = deposit.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DEPOSIT",
                item_text: deposit_out,
                is_block: false,
                incfile: &deposit.__block_info.incfile,
                uid: deposit.__block_info.uid,
                line: deposit.__block_info.line,
                start_offset: deposit.__block_info.start_offset,
                end_offset: deposit.__block_info.end_offset,
                position_restriction: deposit.pos_restrict(),
            });
        }
        if let Some(extended_limits) = &self.extended_limits {
            let extended_limits_out = extended_limits.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "EXTENDED_LIMITS",
                item_text: extended_limits_out,
                is_block: false,
                incfile: &extended_limits.__block_info.incfile,
                uid: extended_limits.__block_info.uid,
                line: extended_limits.__block_info.line,
                start_offset: extended_limits.__block_info.start_offset,
                end_offset: extended_limits.__block_info.end_offset,
                position_restriction: extended_limits.pos_restrict(),
            });
        }
        if let Some(format) = &self.format {
            let format_out = format.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FORMAT",
                item_text: format_out,
                is_block: false,
                incfile: &format.__block_info.incfile,
                uid: format.__block_info.uid,
                line: format.__block_info.line,
                start_offset: format.__block_info.start_offset,
                end_offset: format.__block_info.end_offset,
                position_restriction: format.pos_restrict(),
            });
        }
        if let Some(monotony) = &self.monotony {
            let monotony_out = monotony.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MONOTONY",
                item_text: monotony_out,
                is_block: false,
                incfile: &monotony.__block_info.incfile,
                uid: monotony.__block_info.uid,
                line: monotony.__block_info.line,
                start_offset: monotony.__block_info.start_offset,
                end_offset: monotony.__block_info.end_offset,
                position_restriction: monotony.pos_restrict(),
            });
        }
        if let Some(phys_unit) = &self.phys_unit {
            let phys_unit_out = phys_unit.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "PHYS_UNIT",
                item_text: phys_unit_out,
                is_block: false,
                incfile: &phys_unit.__block_info.incfile,
                uid: phys_unit.__block_info.uid,
                line: phys_unit.__block_info.line,
                start_offset: phys_unit.__block_info.start_offset,
                end_offset: phys_unit.__block_info.end_offset,
                position_restriction: phys_unit.pos_restrict(),
            });
        }
        if let Some(step_size) = &self.step_size {
            let step_size_out = step_size.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "STEP_SIZE",
                item_text: step_size_out,
                is_block: false,
                incfile: &step_size.__block_info.incfile,
                uid: step_size.__block_info.uid,
                line: step_size.__block_info.line,
                start_offset: step_size.__block_info.start_offset,
                end_offset: step_size.__block_info.end_offset,
                position_restriction: step_size.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Type definition of a BLOB
#[derive(Clone)]
pub struct TypedefBlob {
    pub name: String,
    pub long_identifier: String,
    pub size: u32,
    pub address_type: Option<AddressType>,
    pub(crate) __block_info: BlockInfo<(u32, u32, (u32, bool))>,
}

impl std::fmt::Debug for TypedefBlob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TypedefBlob")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("size", &self.size)
            .field("address_type", &self.address_type)
            .finish()
    }
}

impl TypedefBlob {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String, long_identifier: String, size: u32) -> Self {
        Self {
            name,
            long_identifier,
            size,
            address_type: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32, (1u32, false)),
            },
        }
    }
}

impl PartialEq for TypedefBlob {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.size == other.size)
            && (self.address_type == other.address_type)
    }
}

impl A2lObject<(u32, u32, (u32, bool))> for TypedefBlob {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, (u32, bool))> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, (u32, bool))> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(address_type) = &mut self.address_type {
            address_type.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for TypedefBlob {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for TypedefBlob {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__size_location, size) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let mut address_type: Option<AddressType> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 1usize] = ["ADDRESS_TYPE"];
            match tag {
                "ADDRESS_TYPE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    parser.check_block_version_lower(
                        context,
                        "ADDRESS_TYPE",
                        A2lVersion::V1_7_1,
                    )?;
                    let newitem = AddressType::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, address_type.is_some())?;
                    address_type = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __long_identifier_location, __size_location),
            },
            name,
            long_identifier,
            size,
            address_type,
        })
    }
}

impl TypedefBlob {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_integer(
            self.size,
            self.__block_info.item_location.2 .1,
            self.__block_info.item_location.2 .0,
        );
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(address_type) = &self.address_type {
            let address_type_out = address_type.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ADDRESS_TYPE",
                item_text: address_type_out,
                is_block: false,
                incfile: &address_type.__block_info.incfile,
                uid: address_type.__block_info.uid,
                line: address_type.__block_info.line,
                start_offset: address_type.__block_info.start_offset,
                end_offset: address_type.__block_info.end_offset,
                position_restriction: address_type.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Type definition of a calibration object
#[derive(Clone)]
pub struct TypedefCharacteristic {
    pub name: String,
    pub long_identifier: String,
    pub characteristic_type: CharacteristicType,
    pub record_layout: String,
    pub max_diff: f64,
    pub conversion: String,
    pub lower_limit: f64,
    pub upper_limit: f64,
    pub axis_descr: Vec<AxisDescr>,
    pub bit_mask: Option<BitMask>,
    pub byte_order: Option<ByteOrder>,
    pub discrete: Option<Discrete>,
    pub encoding: Option<Encoding>,
    pub extended_limits: Option<ExtendedLimits>,
    pub format: Option<Format>,
    pub matrix_dim: Option<MatrixDim>,
    pub number: Option<Number>,
    pub phys_unit: Option<PhysUnit>,
    pub step_size: Option<StepSize>,
    pub(crate) __block_info: BlockInfo<(u32, u32, u32, u32, u32, u32, u32, u32)>,
}

impl std::fmt::Debug for TypedefCharacteristic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TypedefCharacteristic")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("characteristic_type", &self.characteristic_type)
            .field("record_layout", &self.record_layout)
            .field("max_diff", &self.max_diff)
            .field("conversion", &self.conversion)
            .field("lower_limit", &self.lower_limit)
            .field("upper_limit", &self.upper_limit)
            .field("axis_descr", &self.axis_descr)
            .field("bit_mask", &self.bit_mask)
            .field("byte_order", &self.byte_order)
            .field("discrete", &self.discrete)
            .field("encoding", &self.encoding)
            .field("extended_limits", &self.extended_limits)
            .field("format", &self.format)
            .field("matrix_dim", &self.matrix_dim)
            .field("number", &self.number)
            .field("phys_unit", &self.phys_unit)
            .field("step_size", &self.step_size)
            .finish()
    }
}

impl TypedefCharacteristic {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        name: String,
        long_identifier: String,
        characteristic_type: CharacteristicType,
        record_layout: String,
        max_diff: f64,
        conversion: String,
        lower_limit: f64,
        upper_limit: f64,
    ) -> Self {
        Self {
            name,
            long_identifier,
            characteristic_type,
            record_layout,
            max_diff,
            conversion,
            lower_limit,
            upper_limit,
            axis_descr: Vec::new(),
            bit_mask: None,
            byte_order: None,
            discrete: None,
            encoding: None,
            extended_limits: None,
            format: None,
            matrix_dim: None,
            number: None,
            phys_unit: None,
            step_size: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32, 1u32, 0u32, 0u32, 0u32, 0u32, 0u32),
            },
        }
    }
}

impl PartialEq for TypedefCharacteristic {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.characteristic_type == other.characteristic_type)
            && (self.record_layout == other.record_layout)
            && (self.max_diff == other.max_diff)
            && (self.conversion == other.conversion)
            && (self.lower_limit == other.lower_limit)
            && (self.upper_limit == other.upper_limit)
            && (self.axis_descr == other.axis_descr)
            && (self.bit_mask == other.bit_mask)
            && (self.byte_order == other.byte_order)
            && (self.discrete == other.discrete)
            && (self.encoding == other.encoding)
            && (self.extended_limits == other.extended_limits)
            && (self.format == other.format)
            && (self.matrix_dim == other.matrix_dim)
            && (self.number == other.number)
            && (self.phys_unit == other.phys_unit)
            && (self.step_size == other.step_size)
    }
}

impl A2lObject<(u32, u32, u32, u32, u32, u32, u32, u32)> for TypedefCharacteristic {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, u32, u32, u32, u32, u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, u32, u32, u32, u32, u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        for axis_descr in &mut self.axis_descr {
            axis_descr.merge_includes();
        }
        if let Some(bit_mask) = &mut self.bit_mask {
            bit_mask.merge_includes();
        }
        if let Some(byte_order) = &mut self.byte_order {
            byte_order.merge_includes();
        }
        if let Some(discrete) = &mut self.discrete {
            discrete.merge_includes();
        }
        if let Some(encoding) = &mut self.encoding {
            encoding.merge_includes();
        }
        if let Some(extended_limits) = &mut self.extended_limits {
            extended_limits.merge_includes();
        }
        if let Some(format) = &mut self.format {
            format.merge_includes();
        }
        if let Some(matrix_dim) = &mut self.matrix_dim {
            matrix_dim.merge_includes();
        }
        if let Some(number) = &mut self.number {
            number.merge_includes();
        }
        if let Some(phys_unit) = &mut self.phys_unit {
            phys_unit.merge_includes();
        }
        if let Some(step_size) = &mut self.step_size {
            step_size.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for TypedefCharacteristic {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for TypedefCharacteristic {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__characteristic_type_location, characteristic_type) = (
            parser.get_current_line_offset(),
            CharacteristicType::parse(parser, context, 0)?,
        );
        let (__record_layout_location, record_layout) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__max_diff_location, max_diff) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__conversion_location, conversion) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__lower_limit_location, lower_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__upper_limit_location, upper_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let mut axis_descr: Vec<AxisDescr> = Vec::new();
        let mut bit_mask: Option<BitMask> = None;
        let mut byte_order: Option<ByteOrder> = None;
        let mut discrete: Option<Discrete> = None;
        let mut encoding: Option<Encoding> = None;
        let mut extended_limits: Option<ExtendedLimits> = None;
        let mut format: Option<Format> = None;
        let mut matrix_dim: Option<MatrixDim> = None;
        let mut number: Option<Number> = None;
        let mut phys_unit: Option<PhysUnit> = None;
        let mut step_size: Option<StepSize> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 11usize] = [
                "AXIS_DESCR",
                "BIT_MASK",
                "BYTE_ORDER",
                "DISCRETE",
                "ENCODING",
                "EXTENDED_LIMITS",
                "FORMAT",
                "MATRIX_DIM",
                "NUMBER",
                "PHYS_UNIT",
                "STEP_SIZE",
            ];
            match tag {
                "AXIS_DESCR" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = AxisDescr::parse(parser, &newcontext, line_offset)?;
                    axis_descr.push(newitem);
                }
                "BIT_MASK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = BitMask::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, bit_mask.is_some())?;
                    bit_mask = Some(newitem);
                }
                "BYTE_ORDER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ByteOrder::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, byte_order.is_some())?;
                    byte_order = Some(newitem);
                }
                "DISCRETE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Discrete::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, discrete.is_some())?;
                    discrete = Some(newitem);
                }
                "ENCODING" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Encoding::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, encoding.is_some())?;
                    encoding = Some(newitem);
                }
                "EXTENDED_LIMITS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ExtendedLimits::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, extended_limits.is_some())?;
                    extended_limits = Some(newitem);
                }
                "FORMAT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Format::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, format.is_some())?;
                    format = Some(newitem);
                }
                "MATRIX_DIM" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = MatrixDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, matrix_dim.is_some())?;
                    matrix_dim = Some(newitem);
                }
                "NUMBER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Number::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, number.is_some())?;
                    number = Some(newitem);
                }
                "PHYS_UNIT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = PhysUnit::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, phys_unit.is_some())?;
                    phys_unit = Some(newitem);
                }
                "STEP_SIZE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = StepSize::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, step_size.is_some())?;
                    step_size = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __characteristic_type_location,
                    __record_layout_location,
                    __max_diff_location,
                    __conversion_location,
                    __lower_limit_location,
                    __upper_limit_location,
                ),
            },
            name,
            long_identifier,
            characteristic_type,
            record_layout,
            max_diff,
            conversion,
            lower_limit,
            upper_limit,
            axis_descr,
            bit_mask,
            byte_order,
            discrete,
            encoding,
            extended_limits,
            format,
            matrix_dim,
            number,
            phys_unit,
            step_size,
        })
    }
}

impl TypedefCharacteristic {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_str(
            &self.characteristic_type.to_string(),
            self.__block_info.item_location.2,
        );
        writer.add_str(&self.record_layout, self.__block_info.item_location.3);
        writer.add_float(self.max_diff, self.__block_info.item_location.4);
        writer.add_str(&self.conversion, self.__block_info.item_location.5);
        writer.add_float(self.lower_limit, self.__block_info.item_location.6);
        writer.add_float(self.upper_limit, self.__block_info.item_location.7);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        for axis_descr in &self.axis_descr {
            let axis_descr_out = axis_descr.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "AXIS_DESCR",
                item_text: axis_descr_out,
                is_block: true,
                incfile: &axis_descr.__block_info.incfile,
                uid: axis_descr.__block_info.uid,
                line: axis_descr.__block_info.line,
                start_offset: axis_descr.__block_info.start_offset,
                end_offset: axis_descr.__block_info.end_offset,
                position_restriction: axis_descr.pos_restrict(),
            });
        }
        if let Some(bit_mask) = &self.bit_mask {
            let bit_mask_out = bit_mask.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "BIT_MASK",
                item_text: bit_mask_out,
                is_block: false,
                incfile: &bit_mask.__block_info.incfile,
                uid: bit_mask.__block_info.uid,
                line: bit_mask.__block_info.line,
                start_offset: bit_mask.__block_info.start_offset,
                end_offset: bit_mask.__block_info.end_offset,
                position_restriction: bit_mask.pos_restrict(),
            });
        }
        if let Some(byte_order) = &self.byte_order {
            let byte_order_out = byte_order.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "BYTE_ORDER",
                item_text: byte_order_out,
                is_block: false,
                incfile: &byte_order.__block_info.incfile,
                uid: byte_order.__block_info.uid,
                line: byte_order.__block_info.line,
                start_offset: byte_order.__block_info.start_offset,
                end_offset: byte_order.__block_info.end_offset,
                position_restriction: byte_order.pos_restrict(),
            });
        }
        if let Some(discrete) = &self.discrete {
            let discrete_out = discrete.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DISCRETE",
                item_text: discrete_out,
                is_block: false,
                incfile: &discrete.__block_info.incfile,
                uid: discrete.__block_info.uid,
                line: discrete.__block_info.line,
                start_offset: discrete.__block_info.start_offset,
                end_offset: discrete.__block_info.end_offset,
                position_restriction: discrete.pos_restrict(),
            });
        }
        if let Some(encoding) = &self.encoding {
            let encoding_out = encoding.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ENCODING",
                item_text: encoding_out,
                is_block: false,
                incfile: &encoding.__block_info.incfile,
                uid: encoding.__block_info.uid,
                line: encoding.__block_info.line,
                start_offset: encoding.__block_info.start_offset,
                end_offset: encoding.__block_info.end_offset,
                position_restriction: encoding.pos_restrict(),
            });
        }
        if let Some(extended_limits) = &self.extended_limits {
            let extended_limits_out = extended_limits.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "EXTENDED_LIMITS",
                item_text: extended_limits_out,
                is_block: false,
                incfile: &extended_limits.__block_info.incfile,
                uid: extended_limits.__block_info.uid,
                line: extended_limits.__block_info.line,
                start_offset: extended_limits.__block_info.start_offset,
                end_offset: extended_limits.__block_info.end_offset,
                position_restriction: extended_limits.pos_restrict(),
            });
        }
        if let Some(format) = &self.format {
            let format_out = format.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FORMAT",
                item_text: format_out,
                is_block: false,
                incfile: &format.__block_info.incfile,
                uid: format.__block_info.uid,
                line: format.__block_info.line,
                start_offset: format.__block_info.start_offset,
                end_offset: format.__block_info.end_offset,
                position_restriction: format.pos_restrict(),
            });
        }
        if let Some(matrix_dim) = &self.matrix_dim {
            let matrix_dim_out = matrix_dim.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MATRIX_DIM",
                item_text: matrix_dim_out,
                is_block: false,
                incfile: &matrix_dim.__block_info.incfile,
                uid: matrix_dim.__block_info.uid,
                line: matrix_dim.__block_info.line,
                start_offset: matrix_dim.__block_info.start_offset,
                end_offset: matrix_dim.__block_info.end_offset,
                position_restriction: matrix_dim.pos_restrict(),
            });
        }
        if let Some(number) = &self.number {
            let number_out = number.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "NUMBER",
                item_text: number_out,
                is_block: false,
                incfile: &number.__block_info.incfile,
                uid: number.__block_info.uid,
                line: number.__block_info.line,
                start_offset: number.__block_info.start_offset,
                end_offset: number.__block_info.end_offset,
                position_restriction: number.pos_restrict(),
            });
        }
        if let Some(phys_unit) = &self.phys_unit {
            let phys_unit_out = phys_unit.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "PHYS_UNIT",
                item_text: phys_unit_out,
                is_block: false,
                incfile: &phys_unit.__block_info.incfile,
                uid: phys_unit.__block_info.uid,
                line: phys_unit.__block_info.line,
                start_offset: phys_unit.__block_info.start_offset,
                end_offset: phys_unit.__block_info.end_offset,
                position_restriction: phys_unit.pos_restrict(),
            });
        }
        if let Some(step_size) = &self.step_size {
            let step_size_out = step_size.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "STEP_SIZE",
                item_text: step_size_out,
                is_block: false,
                incfile: &step_size.__block_info.incfile,
                uid: step_size.__block_info.uid,
                line: step_size.__block_info.line,
                start_offset: step_size.__block_info.start_offset,
                end_offset: step_size.__block_info.end_offset,
                position_restriction: step_size.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Type definition of a measurement object
#[derive(Clone)]
pub struct TypedefMeasurement {
    pub name: String,
    pub long_identifier: String,
    pub datatype: DataType,
    pub conversion: String,
    pub resolution: u16,
    pub accuracy: f64,
    pub lower_limit: f64,
    pub upper_limit: f64,
    pub address_type: Option<AddressType>,
    pub bit_mask: Option<BitMask>,
    pub bit_operation: Option<BitOperation>,
    pub byte_order: Option<ByteOrder>,
    pub discrete: Option<Discrete>,
    pub error_mask: Option<ErrorMask>,
    pub format: Option<Format>,
    pub layout: Option<Layout>,
    pub matrix_dim: Option<MatrixDim>,
    pub phys_unit: Option<PhysUnit>,
    pub(crate) __block_info: BlockInfo<(u32, u32, u32, u32, (u32, bool), u32, u32, u32)>,
}

impl std::fmt::Debug for TypedefMeasurement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TypedefMeasurement")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("datatype", &self.datatype)
            .field("conversion", &self.conversion)
            .field("resolution", &self.resolution)
            .field("accuracy", &self.accuracy)
            .field("lower_limit", &self.lower_limit)
            .field("upper_limit", &self.upper_limit)
            .field("address_type", &self.address_type)
            .field("bit_mask", &self.bit_mask)
            .field("bit_operation", &self.bit_operation)
            .field("byte_order", &self.byte_order)
            .field("discrete", &self.discrete)
            .field("error_mask", &self.error_mask)
            .field("format", &self.format)
            .field("layout", &self.layout)
            .field("matrix_dim", &self.matrix_dim)
            .field("phys_unit", &self.phys_unit)
            .finish()
    }
}

impl TypedefMeasurement {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        name: String,
        long_identifier: String,
        datatype: DataType,
        conversion: String,
        resolution: u16,
        accuracy: f64,
        lower_limit: f64,
        upper_limit: f64,
    ) -> Self {
        Self {
            name,
            long_identifier,
            datatype,
            conversion,
            resolution,
            accuracy,
            lower_limit,
            upper_limit,
            address_type: None,
            bit_mask: None,
            bit_operation: None,
            byte_order: None,
            discrete: None,
            error_mask: None,
            format: None,
            layout: None,
            matrix_dim: None,
            phys_unit: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32, 1u32, 0u32, (0u32, false), 0u32, 0u32, 0u32),
            },
        }
    }
}

impl PartialEq for TypedefMeasurement {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.datatype == other.datatype)
            && (self.conversion == other.conversion)
            && (self.resolution == other.resolution)
            && (self.accuracy == other.accuracy)
            && (self.lower_limit == other.lower_limit)
            && (self.upper_limit == other.upper_limit)
            && (self.address_type == other.address_type)
            && (self.bit_mask == other.bit_mask)
            && (self.bit_operation == other.bit_operation)
            && (self.byte_order == other.byte_order)
            && (self.discrete == other.discrete)
            && (self.error_mask == other.error_mask)
            && (self.format == other.format)
            && (self.layout == other.layout)
            && (self.matrix_dim == other.matrix_dim)
            && (self.phys_unit == other.phys_unit)
    }
}

impl A2lObject<(u32, u32, u32, u32, (u32, bool), u32, u32, u32)> for TypedefMeasurement {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, u32, u32, (u32, bool), u32, u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(
        &mut self,
    ) -> &mut BlockInfo<(u32, u32, u32, u32, (u32, bool), u32, u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(address_type) = &mut self.address_type {
            address_type.merge_includes();
        }
        if let Some(bit_mask) = &mut self.bit_mask {
            bit_mask.merge_includes();
        }
        if let Some(bit_operation) = &mut self.bit_operation {
            bit_operation.merge_includes();
        }
        if let Some(byte_order) = &mut self.byte_order {
            byte_order.merge_includes();
        }
        if let Some(discrete) = &mut self.discrete {
            discrete.merge_includes();
        }
        if let Some(error_mask) = &mut self.error_mask {
            error_mask.merge_includes();
        }
        if let Some(format) = &mut self.format {
            format.merge_includes();
        }
        if let Some(layout) = &mut self.layout {
            layout.merge_includes();
        }
        if let Some(matrix_dim) = &mut self.matrix_dim {
            matrix_dim.merge_includes();
        }
        if let Some(phys_unit) = &mut self.phys_unit {
            phys_unit.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for TypedefMeasurement {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for TypedefMeasurement {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__datatype_location, datatype) = (
            parser.get_current_line_offset(),
            DataType::parse(parser, context, 0)?,
        );
        let (__conversion_location, conversion) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__resolution_location, resolution) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u16>(context)?;
            ((line, is_hex), value)
        };
        let (__accuracy_location, accuracy) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__lower_limit_location, lower_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__upper_limit_location, upper_limit) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let mut address_type: Option<AddressType> = None;
        let mut bit_mask: Option<BitMask> = None;
        let mut bit_operation: Option<BitOperation> = None;
        let mut byte_order: Option<ByteOrder> = None;
        let mut discrete: Option<Discrete> = None;
        let mut error_mask: Option<ErrorMask> = None;
        let mut format: Option<Format> = None;
        let mut layout: Option<Layout> = None;
        let mut matrix_dim: Option<MatrixDim> = None;
        let mut phys_unit: Option<PhysUnit> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 10usize] = [
                "ADDRESS_TYPE",
                "BIT_MASK",
                "BIT_OPERATION",
                "BYTE_ORDER",
                "DISCRETE",
                "ERROR_MASK",
                "FORMAT",
                "LAYOUT",
                "MATRIX_DIM",
                "PHYS_UNIT",
            ];
            match tag {
                "ADDRESS_TYPE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AddressType::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, address_type.is_some())?;
                    address_type = Some(newitem);
                }
                "BIT_MASK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = BitMask::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, bit_mask.is_some())?;
                    bit_mask = Some(newitem);
                }
                "BIT_OPERATION" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = BitOperation::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, bit_operation.is_some())?;
                    bit_operation = Some(newitem);
                }
                "BYTE_ORDER" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ByteOrder::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, byte_order.is_some())?;
                    byte_order = Some(newitem);
                }
                "DISCRETE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Discrete::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, discrete.is_some())?;
                    discrete = Some(newitem);
                }
                "ERROR_MASK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ErrorMask::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, error_mask.is_some())?;
                    error_mask = Some(newitem);
                }
                "FORMAT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Format::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, format.is_some())?;
                    format = Some(newitem);
                }
                "LAYOUT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = Layout::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, layout.is_some())?;
                    layout = Some(newitem);
                }
                "MATRIX_DIM" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = MatrixDim::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, matrix_dim.is_some())?;
                    matrix_dim = Some(newitem);
                }
                "PHYS_UNIT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = PhysUnit::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, phys_unit.is_some())?;
                    phys_unit = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __datatype_location,
                    __conversion_location,
                    __resolution_location,
                    __accuracy_location,
                    __lower_limit_location,
                    __upper_limit_location,
                ),
            },
            name,
            long_identifier,
            datatype,
            conversion,
            resolution,
            accuracy,
            lower_limit,
            upper_limit,
            address_type,
            bit_mask,
            bit_operation,
            byte_order,
            discrete,
            error_mask,
            format,
            layout,
            matrix_dim,
            phys_unit,
        })
    }
}

impl TypedefMeasurement {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_str(
            &self.datatype.to_string(),
            self.__block_info.item_location.2,
        );
        writer.add_str(&self.conversion, self.__block_info.item_location.3);
        writer.add_integer(
            self.resolution,
            self.__block_info.item_location.4 .1,
            self.__block_info.item_location.4 .0,
        );
        writer.add_float(self.accuracy, self.__block_info.item_location.5);
        writer.add_float(self.lower_limit, self.__block_info.item_location.6);
        writer.add_float(self.upper_limit, self.__block_info.item_location.7);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(address_type) = &self.address_type {
            let address_type_out = address_type.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ADDRESS_TYPE",
                item_text: address_type_out,
                is_block: false,
                incfile: &address_type.__block_info.incfile,
                uid: address_type.__block_info.uid,
                line: address_type.__block_info.line,
                start_offset: address_type.__block_info.start_offset,
                end_offset: address_type.__block_info.end_offset,
                position_restriction: address_type.pos_restrict(),
            });
        }
        if let Some(bit_mask) = &self.bit_mask {
            let bit_mask_out = bit_mask.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "BIT_MASK",
                item_text: bit_mask_out,
                is_block: false,
                incfile: &bit_mask.__block_info.incfile,
                uid: bit_mask.__block_info.uid,
                line: bit_mask.__block_info.line,
                start_offset: bit_mask.__block_info.start_offset,
                end_offset: bit_mask.__block_info.end_offset,
                position_restriction: bit_mask.pos_restrict(),
            });
        }
        if let Some(bit_operation) = &self.bit_operation {
            let bit_operation_out = bit_operation.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "BIT_OPERATION",
                item_text: bit_operation_out,
                is_block: true,
                incfile: &bit_operation.__block_info.incfile,
                uid: bit_operation.__block_info.uid,
                line: bit_operation.__block_info.line,
                start_offset: bit_operation.__block_info.start_offset,
                end_offset: bit_operation.__block_info.end_offset,
                position_restriction: bit_operation.pos_restrict(),
            });
        }
        if let Some(byte_order) = &self.byte_order {
            let byte_order_out = byte_order.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "BYTE_ORDER",
                item_text: byte_order_out,
                is_block: false,
                incfile: &byte_order.__block_info.incfile,
                uid: byte_order.__block_info.uid,
                line: byte_order.__block_info.line,
                start_offset: byte_order.__block_info.start_offset,
                end_offset: byte_order.__block_info.end_offset,
                position_restriction: byte_order.pos_restrict(),
            });
        }
        if let Some(discrete) = &self.discrete {
            let discrete_out = discrete.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "DISCRETE",
                item_text: discrete_out,
                is_block: false,
                incfile: &discrete.__block_info.incfile,
                uid: discrete.__block_info.uid,
                line: discrete.__block_info.line,
                start_offset: discrete.__block_info.start_offset,
                end_offset: discrete.__block_info.end_offset,
                position_restriction: discrete.pos_restrict(),
            });
        }
        if let Some(error_mask) = &self.error_mask {
            let error_mask_out = error_mask.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ERROR_MASK",
                item_text: error_mask_out,
                is_block: false,
                incfile: &error_mask.__block_info.incfile,
                uid: error_mask.__block_info.uid,
                line: error_mask.__block_info.line,
                start_offset: error_mask.__block_info.start_offset,
                end_offset: error_mask.__block_info.end_offset,
                position_restriction: error_mask.pos_restrict(),
            });
        }
        if let Some(format) = &self.format {
            let format_out = format.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "FORMAT",
                item_text: format_out,
                is_block: false,
                incfile: &format.__block_info.incfile,
                uid: format.__block_info.uid,
                line: format.__block_info.line,
                start_offset: format.__block_info.start_offset,
                end_offset: format.__block_info.end_offset,
                position_restriction: format.pos_restrict(),
            });
        }
        if let Some(layout) = &self.layout {
            let layout_out = layout.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "LAYOUT",
                item_text: layout_out,
                is_block: false,
                incfile: &layout.__block_info.incfile,
                uid: layout.__block_info.uid,
                line: layout.__block_info.line,
                start_offset: layout.__block_info.start_offset,
                end_offset: layout.__block_info.end_offset,
                position_restriction: layout.pos_restrict(),
            });
        }
        if let Some(matrix_dim) = &self.matrix_dim {
            let matrix_dim_out = matrix_dim.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "MATRIX_DIM",
                item_text: matrix_dim_out,
                is_block: false,
                incfile: &matrix_dim.__block_info.incfile,
                uid: matrix_dim.__block_info.uid,
                line: matrix_dim.__block_info.line,
                start_offset: matrix_dim.__block_info.start_offset,
                end_offset: matrix_dim.__block_info.end_offset,
                position_restriction: matrix_dim.pos_restrict(),
            });
        }
        if let Some(phys_unit) = &self.phys_unit {
            let phys_unit_out = phys_unit.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "PHYS_UNIT",
                item_text: phys_unit_out,
                is_block: false,
                incfile: &phys_unit.__block_info.incfile,
                uid: phys_unit.__block_info.uid,
                line: phys_unit.__block_info.line,
                start_offset: phys_unit.__block_info.start_offset,
                end_offset: phys_unit.__block_info.end_offset,
                position_restriction: phys_unit.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Definition of structured data types similar to the \"typedef\" command in C
#[derive(Clone)]
pub struct TypedefStructure {
    pub name: String,
    pub long_identifier: String,
    pub total_size: u32,
    pub address_type: Option<AddressType>,
    pub consistent_exchange: Option<ConsistentExchange>,
    pub structure_component: Vec<StructureComponent>,
    pub symbol_type_link: Option<SymbolTypeLink>,
    pub(crate) __block_info: BlockInfo<(u32, u32, (u32, bool))>,
}

impl std::fmt::Debug for TypedefStructure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TypedefStructure")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("total_size", &self.total_size)
            .field("address_type", &self.address_type)
            .field("consistent_exchange", &self.consistent_exchange)
            .field("structure_component", &self.structure_component)
            .field("symbol_type_link", &self.symbol_type_link)
            .finish()
    }
}

impl TypedefStructure {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String, long_identifier: String, total_size: u32) -> Self {
        Self {
            name,
            long_identifier,
            total_size,
            address_type: None,
            consistent_exchange: None,
            structure_component: Vec::new(),
            symbol_type_link: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32, (1u32, false)),
            },
        }
    }
}

impl PartialEq for TypedefStructure {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.total_size == other.total_size)
            && (self.address_type == other.address_type)
            && (self.consistent_exchange == other.consistent_exchange)
            && (self.structure_component == other.structure_component)
            && (self.symbol_type_link == other.symbol_type_link)
    }
}

impl A2lObject<(u32, u32, (u32, bool))> for TypedefStructure {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, (u32, bool))> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, (u32, bool))> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(address_type) = &mut self.address_type {
            address_type.merge_includes();
        }
        if let Some(consistent_exchange) = &mut self.consistent_exchange {
            consistent_exchange.merge_includes();
        }
        for structure_component in &mut self.structure_component {
            structure_component.merge_includes();
        }
        if let Some(symbol_type_link) = &mut self.symbol_type_link {
            symbol_type_link.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for TypedefStructure {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for TypedefStructure {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__total_size_location, total_size) = {
            let line = parser.get_current_line_offset();
            let (value, is_hex) = parser.get_integer::<u32>(context)?;
            ((line, is_hex), value)
        };
        let mut address_type: Option<AddressType> = None;
        let mut consistent_exchange: Option<ConsistentExchange> = None;
        let mut structure_component: Vec<StructureComponent> = Vec::new();
        let mut symbol_type_link: Option<SymbolTypeLink> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 4usize] = [
                "ADDRESS_TYPE",
                "CONSISTENT_EXCHANGE",
                "STRUCTURE_COMPONENT",
                "SYMBOL_TYPE_LINK",
            ];
            match tag {
                "ADDRESS_TYPE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = AddressType::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, address_type.is_some())?;
                    address_type = Some(newitem);
                }
                "CONSISTENT_EXCHANGE" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ConsistentExchange::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        consistent_exchange.is_some(),
                    )?;
                    consistent_exchange = Some(newitem);
                }
                "STRUCTURE_COMPONENT" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = StructureComponent::parse(parser, &newcontext, line_offset)?;
                    structure_component.push(newitem);
                }
                "SYMBOL_TYPE_LINK" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = SymbolTypeLink::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, symbol_type_link.is_some())?;
                    symbol_type_link = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __total_size_location,
                ),
            },
            name,
            long_identifier,
            total_size,
            address_type,
            consistent_exchange,
            structure_component,
            symbol_type_link,
        })
    }
}

impl TypedefStructure {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_integer(
            self.total_size,
            self.__block_info.item_location.2 .1,
            self.__block_info.item_location.2 .0,
        );
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(address_type) = &self.address_type {
            let address_type_out = address_type.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "ADDRESS_TYPE",
                item_text: address_type_out,
                is_block: false,
                incfile: &address_type.__block_info.incfile,
                uid: address_type.__block_info.uid,
                line: address_type.__block_info.line,
                start_offset: address_type.__block_info.start_offset,
                end_offset: address_type.__block_info.end_offset,
                position_restriction: address_type.pos_restrict(),
            });
        }
        if let Some(consistent_exchange) = &self.consistent_exchange {
            let consistent_exchange_out = consistent_exchange.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "CONSISTENT_EXCHANGE",
                item_text: consistent_exchange_out,
                is_block: false,
                incfile: &consistent_exchange.__block_info.incfile,
                uid: consistent_exchange.__block_info.uid,
                line: consistent_exchange.__block_info.line,
                start_offset: consistent_exchange.__block_info.start_offset,
                end_offset: consistent_exchange.__block_info.end_offset,
                position_restriction: consistent_exchange.pos_restrict(),
            });
        }
        for structure_component in &self.structure_component {
            let structure_component_out = structure_component.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "STRUCTURE_COMPONENT",
                item_text: structure_component_out,
                is_block: true,
                incfile: &structure_component.__block_info.incfile,
                uid: structure_component.__block_info.uid,
                line: structure_component.__block_info.line,
                start_offset: structure_component.__block_info.start_offset,
                end_offset: structure_component.__block_info.end_offset,
                position_restriction: structure_component.pos_restrict(),
            });
        }
        if let Some(symbol_type_link) = &self.symbol_type_link {
            let symbol_type_link_out = symbol_type_link.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SYMBOL_TYPE_LINK",
                item_text: symbol_type_link_out,
                is_block: false,
                incfile: &symbol_type_link.__block_info.incfile,
                uid: symbol_type_link.__block_info.uid,
                line: symbol_type_link.__block_info.line,
                start_offset: symbol_type_link.__block_info.start_offset,
                end_offset: symbol_type_link.__block_info.end_offset,
                position_restriction: symbol_type_link.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Specification of a measurement unit
#[derive(Clone)]
pub struct Unit {
    pub name: String,
    pub long_identifier: String,
    pub display: String,
    pub unit_type: UnitType,
    pub ref_unit: Option<RefUnit>,
    pub si_exponents: Option<SiExponents>,
    pub unit_conversion: Option<UnitConversion>,
    pub(crate) __block_info: BlockInfo<(u32, u32, u32, u32)>,
}

impl std::fmt::Debug for Unit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Unit")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("display", &self.display)
            .field("unit_type", &self.unit_type)
            .field("ref_unit", &self.ref_unit)
            .field("si_exponents", &self.si_exponents)
            .field("unit_conversion", &self.unit_conversion)
            .finish()
    }
}

impl Unit {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(
        name: String,
        long_identifier: String,
        display: String,
        unit_type: UnitType,
    ) -> Self {
        Self {
            name,
            long_identifier,
            display,
            unit_type,
            ref_unit: None,
            si_exponents: None,
            unit_conversion: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32, 1u32, 0u32),
            },
        }
    }
}

impl PartialEq for Unit {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.display == other.display)
            && (self.unit_type == other.unit_type)
            && (self.ref_unit == other.ref_unit)
            && (self.si_exponents == other.si_exponents)
            && (self.unit_conversion == other.unit_conversion)
    }
}

impl A2lObject<(u32, u32, u32, u32)> for Unit {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(ref_unit) = &mut self.ref_unit {
            ref_unit.merge_includes();
        }
        if let Some(si_exponents) = &mut self.si_exponents {
            si_exponents.merge_includes();
        }
        if let Some(unit_conversion) = &mut self.unit_conversion {
            unit_conversion.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for Unit {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for Unit {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__display_location, display) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let (__unit_type_location, unit_type) = (
            parser.get_current_line_offset(),
            UnitType::parse(parser, context, 0)?,
        );
        let mut ref_unit: Option<RefUnit> = None;
        let mut si_exponents: Option<SiExponents> = None;
        let mut unit_conversion: Option<UnitConversion> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 3usize] = ["REF_UNIT", "SI_EXPONENTS", "UNIT_CONVERSION"];
            match tag {
                "REF_UNIT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = RefUnit::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, ref_unit.is_some())?;
                    ref_unit = Some(newitem);
                }
                "SI_EXPONENTS" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = SiExponents::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, si_exponents.is_some())?;
                    si_exponents = Some(newitem);
                }
                "UNIT_CONVERSION" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = UnitConversion::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, unit_conversion.is_some())?;
                    unit_conversion = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __display_location,
                    __unit_type_location,
                ),
            },
            name,
            long_identifier,
            display,
            unit_type,
            ref_unit,
            si_exponents,
            unit_conversion,
        })
    }
}

impl Unit {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        writer.add_quoted_string(&self.display, self.__block_info.item_location.2);
        writer.add_str(
            &self.unit_type.to_string(),
            self.__block_info.item_location.3,
        );
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(ref_unit) = &self.ref_unit {
            let ref_unit_out = ref_unit.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "REF_UNIT",
                item_text: ref_unit_out,
                is_block: false,
                incfile: &ref_unit.__block_info.incfile,
                uid: ref_unit.__block_info.uid,
                line: ref_unit.__block_info.line,
                start_offset: ref_unit.__block_info.start_offset,
                end_offset: ref_unit.__block_info.end_offset,
                position_restriction: ref_unit.pos_restrict(),
            });
        }
        if let Some(si_exponents) = &self.si_exponents {
            let si_exponents_out = si_exponents.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "SI_EXPONENTS",
                item_text: si_exponents_out,
                is_block: false,
                incfile: &si_exponents.__block_info.incfile,
                uid: si_exponents.__block_info.uid,
                line: si_exponents.__block_info.line,
                start_offset: si_exponents.__block_info.start_offset,
                end_offset: si_exponents.__block_info.end_offset,
                position_restriction: si_exponents.pos_restrict(),
            });
        }
        if let Some(unit_conversion) = &self.unit_conversion {
            let unit_conversion_out = unit_conversion.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "UNIT_CONVERSION",
                item_text: unit_conversion_out,
                is_block: false,
                incfile: &unit_conversion.__block_info.incfile,
                uid: unit_conversion.__block_info.uid,
                line: unit_conversion.__block_info.line,
                start_offset: unit_conversion.__block_info.start_offset,
                end_offset: unit_conversion.__block_info.end_offset,
                position_restriction: unit_conversion.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// Specification of the linear relationship between two measurement units
#[derive(Clone)]
pub struct UnitConversion {
    pub gradient: f64,
    pub offset: f64,
    pub(crate) __block_info: BlockInfo<(u32, u32)>,
}

impl std::fmt::Debug for UnitConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("UnitConversion")
            .field("gradient", &self.gradient)
            .field("offset", &self.offset)
            .finish()
    }
}

impl UnitConversion {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(gradient: f64, offset: f64) -> Self {
        Self {
            gradient,
            offset,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, 0u32),
            },
        }
    }
}

impl PartialEq for UnitConversion {
    fn eq(&self, other: &Self) -> bool {
        (self.gradient == other.gradient) && (self.offset == other.offset)
    }
}

impl A2lObject<(u32, u32)> for UnitConversion {
    fn get_layout(&self) -> &BlockInfo<(u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for UnitConversion {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__gradient_location, gradient) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__offset_location, offset) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__gradient_location, __offset_location),
            },
            gradient,
            offset,
        })
    }
}

impl UnitConversion {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_float(self.gradient, self.__block_info.item_location.0);
        writer.add_float(self.offset, self.__block_info.item_location.1);
        writer.finish()
    }
}

/// Type of the UNIT
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum UnitType {
    Derived,
    ExtendedSi,
}

impl ParseableA2lObject for UnitType {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "DERIVED" => Ok(Self::Derived),
            "EXTENDED_SI" => Ok(Self::ExtendedSi),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for UnitType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::Derived => "DERIVED",
            Self::ExtendedSi => "EXTENDED_SI",
        };
        f.write_str(tag)
    }
}

/// Name of the user
#[derive(Clone)]
pub struct User {
    pub user_name: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for User {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("User")
            .field("user_name", &self.user_name)
            .finish()
    }
}

impl User {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(user_name: String) -> Self {
        Self {
            user_name,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for User {
    fn eq(&self, other: &Self) -> bool {
        self.user_name == other.user_name
    }
}

impl A2lObject<(u32, ())> for User {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for User {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__user_name_location, user_name) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__user_name_location, __dummy),
            },
            user_name,
        })
    }
}

impl User {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.user_name, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// used to define groups accessible only for certain users
#[derive(Clone)]
pub struct UserRights {
    pub user_level_id: String,
    pub read_only: Option<ReadOnly>,
    pub ref_group: Vec<RefGroup>,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for UserRights {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("UserRights")
            .field("user_level_id", &self.user_level_id)
            .field("read_only", &self.read_only)
            .field("ref_group", &self.ref_group)
            .finish()
    }
}

impl UserRights {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(user_level_id: String) -> Self {
        Self {
            user_level_id,
            read_only: None,
            ref_group: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (1u32, ()),
            },
        }
    }
}

impl PartialEq for UserRights {
    fn eq(&self, other: &Self) -> bool {
        (self.user_level_id == other.user_level_id)
            && (self.read_only == other.read_only)
            && (self.ref_group == other.ref_group)
    }
}

impl A2lObject<(u32, ())> for UserRights {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(read_only) = &mut self.read_only {
            read_only.merge_includes();
        }
        for ref_group in &mut self.ref_group {
            ref_group.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for UserRights {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__user_level_id_location, user_level_id) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let mut read_only: Option<ReadOnly> = None;
        let mut ref_group: Vec<RefGroup> = Vec::new();
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 2usize] = ["READ_ONLY", "REF_GROUP"];
            match tag {
                "READ_ONLY" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = ReadOnly::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, read_only.is_some())?;
                    read_only = Some(newitem);
                }
                "REF_GROUP" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = RefGroup::parse(parser, &newcontext, line_offset)?;
                    ref_group.push(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__user_level_id_location, __dummy),
            },
            user_level_id,
            read_only,
            ref_group,
        })
    }
}

impl UserRights {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.user_level_id, self.__block_info.item_location.0);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(read_only) = &self.read_only {
            let read_only_out = read_only.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "READ_ONLY",
                item_text: read_only_out,
                is_block: false,
                incfile: &read_only.__block_info.incfile,
                uid: read_only.__block_info.uid,
                line: read_only.__block_info.line,
                start_offset: read_only.__block_info.start_offset,
                end_offset: read_only.__block_info.end_offset,
                position_restriction: read_only.pos_restrict(),
            });
        }
        for ref_group in &self.ref_group {
            let ref_group_out = ref_group.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "REF_GROUP",
                item_text: ref_group_out,
                is_block: true,
                incfile: &ref_group.__block_info.incfile,
                uid: ref_group.__block_info.uid,
                line: ref_group.__block_info.line,
                start_offset: ref_group.__block_info.start_offset,
                end_offset: ref_group.__block_info.end_offset,
                position_restriction: ref_group.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

///Auto generated for repeating sequence `value_pairs` in block `COMPU_VTAB`
#[derive(Clone)]
pub struct ValuePairsStruct {
    pub in_val: f64,
    pub out_val: String,
    pub(crate) __block_info: BlockInfo<(u32, u32)>,
}

impl std::fmt::Debug for ValuePairsStruct {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ValuePairsStruct")
            .field("in_val", &self.in_val)
            .field("out_val", &self.out_val)
            .finish()
    }
}

impl ValuePairsStruct {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(in_val: f64, out_val: String) -> Self {
        Self {
            in_val,
            out_val,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (1u32, 0u32),
            },
        }
    }
}

impl PartialEq for ValuePairsStruct {
    fn eq(&self, other: &Self) -> bool {
        (self.in_val == other.in_val) && (self.out_val == other.out_val)
    }
}

impl A2lObject<(u32, u32)> for ValuePairsStruct {
    fn get_layout(&self) -> &BlockInfo<(u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for ValuePairsStruct {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__in_val_location, in_val) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__out_val_location, out_val) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__in_val_location, __out_val_location),
            },
            in_val,
            out_val,
        })
    }
}

impl ValuePairsStruct {
    pub(crate) fn stringify(&self, writer: &mut writer::Writer) {
        writer.add_float(self.in_val, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.out_val, self.__block_info.item_location.1);
    }
}

///Auto generated for repeating sequence `value_triples` in block `COMPU_VTAB_RANGE`
#[derive(Clone)]
pub struct ValueTriplesStruct {
    pub in_val_min: f64,
    pub in_val_max: f64,
    pub out_val: String,
    pub(crate) __block_info: BlockInfo<(u32, u32, u32)>,
}

impl std::fmt::Debug for ValueTriplesStruct {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ValueTriplesStruct")
            .field("in_val_min", &self.in_val_min)
            .field("in_val_max", &self.in_val_max)
            .field("out_val", &self.out_val)
            .finish()
    }
}

impl ValueTriplesStruct {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(in_val_min: f64, in_val_max: f64, out_val: String) -> Self {
        Self {
            in_val_min,
            in_val_max,
            out_val,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (1u32, 0u32, 0u32),
            },
        }
    }
}

impl PartialEq for ValueTriplesStruct {
    fn eq(&self, other: &Self) -> bool {
        (self.in_val_min == other.in_val_min)
            && (self.in_val_max == other.in_val_max)
            && (self.out_val == other.out_val)
    }
}

impl A2lObject<(u32, u32, u32)> for ValueTriplesStruct {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, u32)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, u32)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for ValueTriplesStruct {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__in_val_min_location, in_val_min) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__in_val_max_location, in_val_max) = (
            parser.get_current_line_offset(),
            parser.get_double(context)?,
        );
        let (__out_val_location, out_val) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __in_val_min_location,
                    __in_val_max_location,
                    __out_val_location,
                ),
            },
            in_val_min,
            in_val_max,
            out_val,
        })
    }
}

impl ValueTriplesStruct {
    pub(crate) fn stringify(&self, writer: &mut writer::Writer) {
        writer.add_float(self.in_val_min, self.__block_info.item_location.0);
        writer.add_float(self.in_val_max, self.__block_info.item_location.1);
        writer.add_quoted_string(&self.out_val, self.__block_info.item_location.2);
    }
}

/// define a list of start addresses of variant coded adjustable objects
#[derive(Clone)]
pub struct VarAddress {
    pub address_list: Vec<u32>,
    pub(crate) __block_info: BlockInfo<(Vec<(u32, bool)>, ())>,
}

impl std::fmt::Debug for VarAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("VarAddress")
            .field("address_list", &self.address_list)
            .finish()
    }
}

impl VarAddress {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            address_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<(u32, bool)>::new(), ()),
            },
        }
    }
}

impl PartialEq for VarAddress {
    fn eq(&self, other: &Self) -> bool {
        self.address_list == other.address_list
    }
}

impl A2lObject<(Vec<(u32, bool)>, ())> for VarAddress {
    fn get_layout(&self) -> &BlockInfo<(Vec<(u32, bool)>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<(u32, bool)>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for VarAddress {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut address_list = Vec::new();
        let mut __address_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok({
                        let line = parser.get_current_line_offset();
                        let (value, is_hex) = parser.get_integer::<u32>(context)?;
                        ((line, is_hex), value)
                    })
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    address_list.push(value);
                    __address_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__address_list_location, __dummy),
            },
            address_list,
        })
    }
}

impl VarAddress {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.address_list.iter().enumerate() {
            writer.add_integer(
                *seqitem0,
                self.__block_info
                    .item_location
                    .0
                    .get(seqidx0)
                    .unwrap_or(&(0, false))
                    .1,
                self.__block_info
                    .item_location
                    .0
                    .get(seqidx0)
                    .unwrap_or(&(0, false))
                    .0,
            );
        }
        writer.finish()
    }
}

/// defines one adjustable object to be variant coded
#[derive(Clone)]
pub struct VarCharacteristic {
    pub name: String,
    pub criterion_name_list: Vec<String>,
    pub var_address: Option<VarAddress>,
    pub(crate) __block_info: BlockInfo<(u32, Vec<u32>)>,
}

impl std::fmt::Debug for VarCharacteristic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("VarCharacteristic")
            .field("name", &self.name)
            .field("criterion_name_list", &self.criterion_name_list)
            .field("var_address", &self.var_address)
            .finish()
    }
}

impl VarCharacteristic {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String) -> Self {
        Self {
            name,
            criterion_name_list: Vec::new(),
            var_address: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (1u32, Vec::<u32>::new()),
            },
        }
    }
}

impl PartialEq for VarCharacteristic {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.criterion_name_list == other.criterion_name_list)
            && (self.var_address == other.var_address)
    }
}

impl A2lObject<(u32, Vec<u32>)> for VarCharacteristic {
    fn get_layout(&self) -> &BlockInfo<(u32, Vec<u32>)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, Vec<u32>)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(var_address) = &mut self.var_address {
            var_address.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for VarCharacteristic {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for VarCharacteristic {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let mut criterion_name_list = Vec::new();
        let mut __criterion_name_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    criterion_name_list.push(value);
                    __criterion_name_list_location.push(location);
                }
            }
        }
        let mut var_address: Option<VarAddress> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 1usize] = ["VAR_ADDRESS"];
            match tag {
                "VAR_ADDRESS" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = VarAddress::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, var_address.is_some())?;
                    var_address = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __criterion_name_list_location),
            },
            name,
            criterion_name_list,
            var_address,
        })
    }
}

impl VarCharacteristic {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        for (seqidx0, seqitem0) in self.criterion_name_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.1.get(seqidx0).unwrap_or(&0),
            );
        }
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(var_address) = &self.var_address {
            let var_address_out = var_address.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "VAR_ADDRESS",
                item_text: var_address_out,
                is_block: true,
                incfile: &var_address.__block_info.incfile,
                uid: var_address.__block_info.uid,
                line: var_address.__block_info.line,
                start_offset: var_address.__block_info.start_offset,
                end_offset: var_address.__block_info.end_offset,
                position_restriction: var_address.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// describes a variant criterion
#[derive(Clone)]
pub struct VarCriterion {
    pub name: String,
    pub long_identifier: String,
    pub value_list: Vec<String>,
    pub var_measurement: Option<VarMeasurement>,
    pub var_selection_characteristic: Option<VarSelectionCharacteristic>,
    pub(crate) __block_info: BlockInfo<(u32, u32, Vec<u32>)>,
}

impl std::fmt::Debug for VarCriterion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("VarCriterion")
            .field("name", &self.name)
            .field("long_identifier", &self.long_identifier)
            .field("value_list", &self.value_list)
            .field("var_measurement", &self.var_measurement)
            .field(
                "var_selection_characteristic",
                &self.var_selection_characteristic,
            )
            .finish()
    }
}

impl VarCriterion {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String, long_identifier: String) -> Self {
        Self {
            name,
            long_identifier,
            value_list: Vec::new(),
            var_measurement: None,
            var_selection_characteristic: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (0u32, 0u32, Vec::<u32>::new()),
            },
        }
    }
}

impl PartialEq for VarCriterion {
    fn eq(&self, other: &Self) -> bool {
        (self.name == other.name)
            && (self.long_identifier == other.long_identifier)
            && (self.value_list == other.value_list)
            && (self.var_measurement == other.var_measurement)
            && (self.var_selection_characteristic == other.var_selection_characteristic)
    }
}

impl A2lObject<(u32, u32, Vec<u32>)> for VarCriterion {
    fn get_layout(&self) -> &BlockInfo<(u32, u32, Vec<u32>)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, u32, Vec<u32>)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(var_measurement) = &mut self.var_measurement {
            var_measurement.merge_includes();
        }
        if let Some(var_selection_characteristic) = &mut self.var_selection_characteristic {
            var_selection_characteristic.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for VarCriterion {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for VarCriterion {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let (__long_identifier_location, long_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let mut value_list = Vec::new();
        let mut __value_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                let stopwords: [&str; 2usize] = ["VAR_MEASUREMENT", "VAR_SELECTION_CHARACTERISTIC"];
                if stopwords.contains(&value.as_str()) {
                    parser.set_tokenpos(current_token);
                    done = true;
                } else {
                    value_list.push(value);
                    __value_list_location.push(location);
                }
            }
        }
        let mut var_measurement: Option<VarMeasurement> = None;
        let mut var_selection_characteristic: Option<VarSelectionCharacteristic> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 2usize] = ["VAR_MEASUREMENT", "VAR_SELECTION_CHARACTERISTIC"];
            match tag {
                "VAR_MEASUREMENT" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = VarMeasurement::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, var_measurement.is_some())?;
                    var_measurement = Some(newitem);
                }
                "VAR_SELECTION_CHARACTERISTIC" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem =
                        VarSelectionCharacteristic::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(
                        context,
                        tag,
                        var_selection_characteristic.is_some(),
                    )?;
                    var_selection_characteristic = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (
                    __name_location,
                    __long_identifier_location,
                    __value_list_location,
                ),
            },
            name,
            long_identifier,
            value_list,
            var_measurement,
            var_selection_characteristic,
        })
    }
}

impl VarCriterion {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.add_quoted_string(&self.long_identifier, self.__block_info.item_location.1);
        for (seqidx0, seqitem0) in self.value_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.2.get(seqidx0).unwrap_or(&0),
            );
        }
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        if let Some(var_measurement) = &self.var_measurement {
            let var_measurement_out = var_measurement.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "VAR_MEASUREMENT",
                item_text: var_measurement_out,
                is_block: false,
                incfile: &var_measurement.__block_info.incfile,
                uid: var_measurement.__block_info.uid,
                line: var_measurement.__block_info.line,
                start_offset: var_measurement.__block_info.start_offset,
                end_offset: var_measurement.__block_info.end_offset,
                position_restriction: var_measurement.pos_restrict(),
            });
        }
        if let Some(var_selection_characteristic) = &self.var_selection_characteristic {
            let var_selection_characteristic_out =
                var_selection_characteristic.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "VAR_SELECTION_CHARACTERISTIC",
                item_text: var_selection_characteristic_out,
                is_block: false,
                incfile: &var_selection_characteristic.__block_info.incfile,
                uid: var_selection_characteristic.__block_info.uid,
                line: var_selection_characteristic.__block_info.line,
                start_offset: var_selection_characteristic.__block_info.start_offset,
                end_offset: var_selection_characteristic.__block_info.end_offset,
                position_restriction: var_selection_characteristic.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// describes a forbidden combination of values of different variant criteria
#[derive(Clone)]
pub struct VarForbiddenComb {
    pub combination: Vec<CombinationStruct>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for VarForbiddenComb {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("VarForbiddenComb")
            .field("combination", &self.combination)
            .finish()
    }
}

impl VarForbiddenComb {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            combination: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for VarForbiddenComb {
    fn eq(&self, other: &Self) -> bool {
        self.combination == other.combination
    }
}

impl A2lObject<(Vec<u32>, ())> for VarForbiddenComb {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for VarForbiddenComb {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut combination = Vec::new();
        let mut __combination_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        CombinationStruct::parse(parser, context, 0)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    combination.push(value);
                    __combination_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__combination_location, __dummy),
            },
            combination,
        })
    }
}

impl VarForbiddenComb {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for seqitem0 in &self.combination {
            seqitem0.stringify(&mut writer);
        }
        writer.finish()
    }
}

/// specify a special measurement object which indicates the currently active variant
#[derive(Clone)]
pub struct VarMeasurement {
    pub name: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for VarMeasurement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("VarMeasurement")
            .field("name", &self.name)
            .finish()
    }
}

impl VarMeasurement {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String) -> Self {
        Self {
            name,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for VarMeasurement {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name
    }
}

impl A2lObject<(u32, ())> for VarMeasurement {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for VarMeasurement {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for VarMeasurement {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __dummy),
            },
            name,
        })
    }
}

impl VarMeasurement {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// defines the format of the variant extension (index) of adjustable object names
#[derive(Clone)]
pub struct VarNaming {
    pub tag: VarNamingTag,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for VarNaming {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("VarNaming").field("tag", &self.tag).finish()
    }
}

impl VarNaming {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(tag: VarNamingTag) -> Self {
        Self {
            tag,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for VarNaming {
    fn eq(&self, other: &Self) -> bool {
        self.tag == other.tag
    }
}

impl A2lObject<(u32, ())> for VarNaming {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for VarNaming {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__tag_location, tag) = (
            parser.get_current_line_offset(),
            VarNamingTag::parse(parser, context, 0)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__tag_location, __dummy),
            },
            tag,
        })
    }
}

impl VarNaming {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.tag.to_string(), self.__block_info.item_location.0);
        writer.finish()
    }
}

/// intended to define the format of the variant extension. Currently only one format is supported
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum VarNamingTag {
    Numeric,
}

impl ParseableA2lObject for VarNamingTag {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let enumname = parser.get_identifier(context)?;
        match &*enumname {
            "NUMERIC" => Ok(Self::Numeric),
            _ => Err(ParserError::InvalidEnumValue {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                enumtxt: enumname,
                block: context.element.to_owned(),
                block_line: context.line,
            }),
        }
    }
}

impl std::fmt::Display for VarNamingTag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tag = match &self {
            Self::Numeric => "NUMERIC",
        };
        f.write_str(tag)
    }
}

/// used to specify a special characteristic object which can change the currently active variant
#[derive(Clone)]
pub struct VarSelectionCharacteristic {
    pub name: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for VarSelectionCharacteristic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("VarSelectionCharacteristic")
            .field("name", &self.name)
            .finish()
    }
}

impl VarSelectionCharacteristic {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(name: String) -> Self {
        Self {
            name,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for VarSelectionCharacteristic {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name
    }
}

impl A2lObject<(u32, ())> for VarSelectionCharacteristic {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl A2lObjectName for VarSelectionCharacteristic {
    fn get_name(&self) -> &str {
        &self.name
    }
}

impl ParseableA2lObject for VarSelectionCharacteristic {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__name_location, name) = (
            parser.get_current_line_offset(),
            parser.get_identifier(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__name_location, __dummy),
            },
            name,
        })
    }
}

impl VarSelectionCharacteristic {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_str(&self.name, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// defines the separating symbol between the two parts of an adjustable object name
#[derive(Clone)]
pub struct VarSeparator {
    pub separator: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for VarSeparator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("VarSeparator")
            .field("separator", &self.separator)
            .finish()
    }
}

impl VarSeparator {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(separator: String) -> Self {
        Self {
            separator,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for VarSeparator {
    fn eq(&self, other: &Self) -> bool {
        self.separator == other.separator
    }
}

impl A2lObject<(u32, ())> for VarSeparator {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for VarSeparator {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__separator_location, separator) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__separator_location, __dummy),
            },
            separator,
        })
    }
}

impl VarSeparator {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.separator, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// All information related to variant coding is grouped in this structure
#[derive(Clone)]
pub struct VariantCoding {
    pub var_characteristic: Vec<VarCharacteristic>,
    pub var_criterion: Vec<VarCriterion>,
    pub var_forbidden_comb: Vec<VarForbiddenComb>,
    pub var_naming: Option<VarNaming>,
    pub var_separator: Option<VarSeparator>,
    pub(crate) __block_info: BlockInfo<()>,
}

impl std::fmt::Debug for VariantCoding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("VariantCoding")
            .field("var_characteristic", &self.var_characteristic)
            .field("var_criterion", &self.var_criterion)
            .field("var_forbidden_comb", &self.var_forbidden_comb)
            .field("var_naming", &self.var_naming)
            .field("var_separator", &self.var_separator)
            .finish()
    }
}

impl VariantCoding {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            var_characteristic: Vec::new(),
            var_criterion: Vec::new(),
            var_forbidden_comb: Vec::new(),
            var_naming: None,
            var_separator: None,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (),
            },
        }
    }
}

impl PartialEq for VariantCoding {
    fn eq(&self, other: &Self) -> bool {
        (self.var_characteristic == other.var_characteristic)
            && (self.var_criterion == other.var_criterion)
            && (self.var_forbidden_comb == other.var_forbidden_comb)
            && (self.var_naming == other.var_naming)
            && (self.var_separator == other.var_separator)
    }
}

impl A2lObject<()> for VariantCoding {
    fn get_layout(&self) -> &BlockInfo<()> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<()> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        for var_characteristic in &mut self.var_characteristic {
            var_characteristic.merge_includes();
        }
        for var_criterion in &mut self.var_criterion {
            var_criterion.merge_includes();
        }
        for var_forbidden_comb in &mut self.var_forbidden_comb {
            var_forbidden_comb.merge_includes();
        }
        if let Some(var_naming) = &mut self.var_naming {
            var_naming.merge_includes();
        }
        if let Some(var_separator) = &mut self.var_separator {
            var_separator.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for VariantCoding {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut var_characteristic: Vec<VarCharacteristic> = Vec::new();
        let mut var_criterion: Vec<VarCriterion> = Vec::new();
        let mut var_forbidden_comb: Vec<VarForbiddenComb> = Vec::new();
        let mut var_naming: Option<VarNaming> = None;
        let mut var_separator: Option<VarSeparator> = None;
        let mut next_tag = parser.get_next_tag(context)?;
        while next_tag.is_some() {
            let (token, is_block, line_offset) = next_tag.unwrap();
            let tag = parser.get_token_text(token);
            let newcontext = ParseContext::from_token(tag, token);
            const TAG_LIST: [&str; 5usize] = [
                "VAR_CHARACTERISTIC",
                "VAR_CRITERION",
                "VAR_FORBIDDEN_COMB",
                "VAR_NAMING",
                "VAR_SEPARATOR",
            ];
            match tag {
                "VAR_CHARACTERISTIC" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = VarCharacteristic::parse(parser, &newcontext, line_offset)?;
                    var_characteristic.push(newitem);
                }
                "VAR_CRITERION" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = VarCriterion::parse(parser, &newcontext, line_offset)?;
                    var_criterion.push(newitem);
                }
                "VAR_FORBIDDEN_COMB" => {
                    parser.require_block(tag, is_block, context)?;
                    let newitem = VarForbiddenComb::parse(parser, &newcontext, line_offset)?;
                    var_forbidden_comb.push(newitem);
                }
                "VAR_NAMING" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = VarNaming::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, var_naming.is_some())?;
                    var_naming = Some(newitem);
                }
                "VAR_SEPARATOR" => {
                    parser.require_keyword(tag, is_block, context)?;
                    let newitem = VarSeparator::parse(parser, &newcontext, line_offset)?;
                    parser.handle_multiplicity_error(context, tag, var_separator.is_some())?;
                    var_separator = Some(newitem);
                }
                _ => {
                    parser.handle_unknown_taggedstruct_tag(context, tag, is_block, &TAG_LIST)?;
                }
            }
            next_tag = parser.get_next_tag(context)?;
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (),
            },
            var_characteristic,
            var_criterion,
            var_forbidden_comb,
            var_naming,
            var_separator,
        })
    }
}

impl VariantCoding {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        let mut tgroup = Vec::<writer::TaggedItemInfo>::new();
        for var_characteristic in &self.var_characteristic {
            let var_characteristic_out = var_characteristic.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "VAR_CHARACTERISTIC",
                item_text: var_characteristic_out,
                is_block: true,
                incfile: &var_characteristic.__block_info.incfile,
                uid: var_characteristic.__block_info.uid,
                line: var_characteristic.__block_info.line,
                start_offset: var_characteristic.__block_info.start_offset,
                end_offset: var_characteristic.__block_info.end_offset,
                position_restriction: var_characteristic.pos_restrict(),
            });
        }
        for var_criterion in &self.var_criterion {
            let var_criterion_out = var_criterion.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "VAR_CRITERION",
                item_text: var_criterion_out,
                is_block: true,
                incfile: &var_criterion.__block_info.incfile,
                uid: var_criterion.__block_info.uid,
                line: var_criterion.__block_info.line,
                start_offset: var_criterion.__block_info.start_offset,
                end_offset: var_criterion.__block_info.end_offset,
                position_restriction: var_criterion.pos_restrict(),
            });
        }
        for var_forbidden_comb in &self.var_forbidden_comb {
            let var_forbidden_comb_out = var_forbidden_comb.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "VAR_FORBIDDEN_COMB",
                item_text: var_forbidden_comb_out,
                is_block: true,
                incfile: &var_forbidden_comb.__block_info.incfile,
                uid: var_forbidden_comb.__block_info.uid,
                line: var_forbidden_comb.__block_info.line,
                start_offset: var_forbidden_comb.__block_info.start_offset,
                end_offset: var_forbidden_comb.__block_info.end_offset,
                position_restriction: var_forbidden_comb.pos_restrict(),
            });
        }
        if let Some(var_naming) = &self.var_naming {
            let var_naming_out = var_naming.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "VAR_NAMING",
                item_text: var_naming_out,
                is_block: false,
                incfile: &var_naming.__block_info.incfile,
                uid: var_naming.__block_info.uid,
                line: var_naming.__block_info.line,
                start_offset: var_naming.__block_info.start_offset,
                end_offset: var_naming.__block_info.end_offset,
                position_restriction: var_naming.pos_restrict(),
            });
        }
        if let Some(var_separator) = &self.var_separator {
            let var_separator_out = var_separator.stringify(indent + 1);
            tgroup.push(writer::TaggedItemInfo {
                tag: "VAR_SEPARATOR",
                item_text: var_separator_out,
                is_block: false,
                incfile: &var_separator.__block_info.incfile,
                uid: var_separator.__block_info.uid,
                line: var_separator.__block_info.line,
                start_offset: var_separator.__block_info.start_offset,
                end_offset: var_separator.__block_info.end_offset,
                position_restriction: var_separator.pos_restrict(),
            });
        }
        writer.add_group(tgroup);
        writer.finish()
    }
}

/// version identifier
#[derive(Clone)]
pub struct Version {
    pub version_identifier: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for Version {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Version")
            .field("version_identifier", &self.version_identifier)
            .finish()
    }
}

impl Version {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(version_identifier: String) -> Self {
        Self {
            version_identifier,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1u32,
                end_offset: 1,
                item_location: (0u32, ()),
            },
        }
    }
}

impl PartialEq for Version {
    fn eq(&self, other: &Self) -> bool {
        self.version_identifier == other.version_identifier
    }
}

impl A2lObject<(u32, ())> for Version {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Version {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__version_identifier_location, version_identifier) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let __dummy = ();
        let __end_offset: u32 = 0;
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__version_identifier_location, __dummy),
            },
            version_identifier,
        })
    }
}

impl Version {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.version_identifier, self.__block_info.item_location.0);
        writer.finish()
    }
}

/// specification of the measurement objects for a virtual measurement channel
#[derive(Clone)]
pub struct Virtual {
    pub measuring_channel_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(Vec<u32>, ())>,
}

impl std::fmt::Debug for Virtual {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Virtual")
            .field("measuring_channel_list", &self.measuring_channel_list)
            .finish()
    }
}

impl Virtual {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new() -> Self {
        Self {
            measuring_channel_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (Vec::<u32>::new(), ()),
            },
        }
    }
}

impl PartialEq for Virtual {
    fn eq(&self, other: &Self) -> bool {
        self.measuring_channel_list == other.measuring_channel_list
    }
}

impl A2lObject<(Vec<u32>, ())> for Virtual {
    fn get_layout(&self) -> &BlockInfo<(Vec<u32>, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(Vec<u32>, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for Virtual {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let mut measuring_channel_list = Vec::new();
        let mut __measuring_channel_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    measuring_channel_list.push(value);
                    __measuring_channel_list_location.push(location);
                }
            }
        }
        let __dummy = ();
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__measuring_channel_list_location, __dummy),
            },
            measuring_channel_list,
        })
    }
}

impl Virtual {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        for (seqidx0, seqitem0) in self.measuring_channel_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.0.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// defines characteristics that are not deposited in the memory of the control unit, but can be used to indirectly calibrate other characteristic values
#[derive(Clone)]
pub struct VirtualCharacteristic {
    pub formula: String,
    pub characteristic_list: Vec<String>,
    pub(crate) __block_info: BlockInfo<(u32, Vec<u32>)>,
}

impl std::fmt::Debug for VirtualCharacteristic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("VirtualCharacteristic")
            .field("formula", &self.formula)
            .field("characteristic_list", &self.characteristic_list)
            .finish()
    }
}

impl VirtualCharacteristic {
    #[allow(clippy::too_many_arguments)]
    #[must_use]
    pub fn new(formula: String) -> Self {
        Self {
            formula,
            characteristic_list: Vec::new(),
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 2u32,
                end_offset: 1,
                item_location: (1u32, Vec::<u32>::new()),
            },
        }
    }
}

impl PartialEq for VirtualCharacteristic {
    fn eq(&self, other: &Self) -> bool {
        (self.formula == other.formula) && (self.characteristic_list == other.characteristic_list)
    }
}

impl A2lObject<(u32, Vec<u32>)> for VirtualCharacteristic {
    fn get_layout(&self) -> &BlockInfo<(u32, Vec<u32>)> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, Vec<u32>)> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl ParseableA2lObject for VirtualCharacteristic {
    fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        __start_offset: u32,
    ) -> Result<Self, ParserError> {
        let __location_incfile = parser.get_incfilename(context.fileid);
        let __location_line = context.line;
        let __uid = parser.get_next_id();
        let (__formula_location, formula) = (
            parser.get_current_line_offset(),
            parser.get_string(context)?,
        );
        let mut characteristic_list = Vec::new();
        let mut __characteristic_list_location = Vec::new();
        let mut done = false;
        while !done {
            let current_token = parser.get_tokenpos();
            let sequence_item = {
                |parser: &mut ParserState, context: &ParseContext| {
                    Ok((
                        parser.get_current_line_offset(),
                        parser.get_identifier(context)?,
                    ))
                }
            }(parser, context);
            if sequence_item.is_err() {
                parser.set_tokenpos(current_token);
                done = true;
            } else {
                let (location, value) = sequence_item?;
                {
                    characteristic_list.push(value);
                    __characteristic_list_location.push(location);
                }
            }
        }
        let __end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != context.element {
            parser.error_or_log(ParserError::incorrect_end_tag(parser, context, &ident))?;
        }
        Ok(Self {
            __block_info: BlockInfo {
                incfile: __location_incfile,
                line: __location_line,
                uid: __uid,
                start_offset: __start_offset,
                end_offset: __end_offset,
                item_location: (__formula_location, __characteristic_list_location),
            },
            formula,
            characteristic_list,
        })
    }
}

impl VirtualCharacteristic {
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        writer.add_quoted_string(&self.formula, self.__block_info.item_location.0);
        for (seqidx0, seqitem0) in self.characteristic_list.iter().enumerate() {
            writer.add_str(
                seqitem0,
                *self.__block_info.item_location.1.get(seqidx0).unwrap_or(&0),
            );
        }
        writer.finish()
    }
}

/// A2ML is a special case in the specification.
/// It contains the ASAP2 metalanguage code that describes the content of `IF_DATA` blocks
#[derive(Clone)]
pub struct A2ml {
    pub a2ml_text: String,
    merged_a2ml_text: String,
    pub(crate) __block_info: BlockInfo<(u32, ())>,
}

impl std::fmt::Debug for A2ml {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("A2ml")
            .field("a2ml_text", &self.a2ml_text)
            .finish()
    }
}

impl A2ml {
    #[must_use]
    pub fn new(a2ml_text: String) -> Self {
        let merged_a2ml_text = a2ml_text.clone();
        Self {
            a2ml_text,
            merged_a2ml_text,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1,
                end_offset: 1,
                item_location: (0, ()),
            },
        }
    }
    pub(crate) fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        start_offset: u32,
    ) -> Result<Self, ParserError> {
        let fileid = parser.get_incfilename(context.fileid);
        let line = context.line;
        let uid = parser.get_next_id();
        let __a2ml_text_location = parser.get_current_line_offset();
        let token = parser.expect_token(context, A2lTokenType::String)?;
        let a2ml_text = parser.get_token_text(token).to_string();
        let filename = &parser.filenames[context.fileid];
        let merged_a2ml_text;
        match a2ml::parse_a2ml(filename, &a2ml_text) {
            Ok((a2mlspec, computed_merged_a2ml_text)) => {
                parser.file_a2mlspec = Some(a2mlspec);
                merged_a2ml_text = computed_merged_a2ml_text;
            }
            Err(errmsg) => {
                parser.error_or_log(ParserError::A2mlError {
                    filename: filename.to_string(),
                    error_line: parser.last_token_position,
                    errmsg,
                })?;
                merged_a2ml_text = String::new();
            }
        }
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != "A2ML" {
            parser.error_or_log(ParserError::IncorrectEndTag {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                tag: ident.clone(),
                block: context.element.clone(),
                block_line: context.line,
            })?;
        }
        Ok(A2ml {
            a2ml_text,
            merged_a2ml_text,
            __block_info: BlockInfo {
                incfile: fileid,
                line,
                uid,
                start_offset,
                end_offset: 1,
                item_location: (__a2ml_text_location, ()),
            },
        })
    }
    pub(crate) fn stringify(&self, indent: usize) -> String {
        let mut writer = writer::Writer::new(indent);
        let text_fixed = self
            .a2ml_text
            .split("\r\n")
            .collect::<Vec<&str>>()
            .join("\n");
        writer.add_str_raw(&text_fixed, self.__block_info.item_location.0);
        writer.finish()
    }
}

impl A2lObject<(u32, ())> for A2ml {
    fn get_layout(&self) -> &BlockInfo<(u32, ())> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<(u32, ())> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        self.a2ml_text = self.merged_a2ml_text.clone();
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl PartialEq for A2ml {
    fn eq(&self, other: &Self) -> bool {
        self.a2ml_text == other.a2ml_text
    }
}

/// The content of `IF_DATA` blocks is not directly described in the specification.
/// Instead the content description is provided at runtime through the A2ML block.
#[derive(Clone)]
pub struct IfData {
    /// contains the content of the `IF_DATA` in generic form
    pub ifdata_items: Option<a2ml::GenericIfData>,
    /// `ifdata_valid` indicates if the data matched an A2ML specification during parsing or not
    pub ifdata_valid: bool,
    pub(crate) __block_info: BlockInfo<()>,
}

impl std::fmt::Debug for IfData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("IfData")
            .field("ifdata_items", &self.ifdata_items)
            .finish()
    }
}

impl IfData {
    #[must_use]
    pub fn new() -> Self {
        Self {
            ifdata_items: None,
            ifdata_valid: false,
            __block_info: BlockInfo {
                incfile: None,
                line: 0,
                uid: 0,
                start_offset: 1,
                end_offset: 1,
                item_location: (),
            },
        }
    }
    pub(crate) fn parse(
        parser: &mut ParserState,
        context: &ParseContext,
        start_offset: u32,
    ) -> Result<Self, ParserError> {
        let fileid = parser.get_incfilename(context.fileid);
        let line = context.line;
        let uid = parser.get_next_id();
        let (ifdata_items, ifdata_valid) = ifdata::parse_ifdata(parser, context)?;
        let end_offset = parser.get_current_line_offset();
        parser.expect_token(context, A2lTokenType::End)?;
        let ident = parser.get_identifier(context)?;
        if ident != "IF_DATA" {
            parser.error_or_log(ParserError::IncorrectEndTag {
                filename: parser.filenames[context.fileid].to_string(),
                error_line: parser.last_token_position,
                tag: ident.clone(),
                block: context.element.clone(),
                block_line: context.line,
            })?;
        }
        Ok(IfData {
            ifdata_items,
            ifdata_valid,
            __block_info: BlockInfo {
                incfile: fileid,
                line,
                uid,
                start_offset,
                end_offset,
                item_location: (),
            },
        })
    }
    pub(crate) fn stringify(&self, indent: usize) -> String {
        if let Some(ifdata_items) = &self.ifdata_items {
            ifdata_items.write(indent - 1)
        } else {
            String::new()
        }
    }
}

impl Default for IfData {
    fn default() -> Self {
        Self::new()
    }
}

impl A2lObject<()> for IfData {
    fn get_layout(&self) -> &BlockInfo<()> {
        &self.__block_info
    }
    fn get_layout_mut(&mut self) -> &mut BlockInfo<()> {
        &mut self.__block_info
    }
    fn reset_location(&mut self) {
        self.merge_includes();
        self.__block_info.uid = 0;
    }
    fn merge_includes(&mut self) {
        self.__block_info.incfile = None;
        if let Some(ifdata_items) = &mut self.ifdata_items {
            ifdata_items.merge_includes();
        }
    }
    fn get_line(&self) -> u32 {
        self.__block_info.line
    }
}

impl PartialEq for IfData {
    fn eq(&self, other: &Self) -> bool {
        self.ifdata_items == other.ifdata_items
    }
}

impl PositionRestricted for Asap2Version {
    fn pos_restrict(&self) -> Option<u16> {
        Some(1)
    }
}

impl PositionRestricted for A2mlVersion {
    fn pos_restrict(&self) -> Option<u16> {
        Some(2)
    }
}

impl PositionRestricted for Project {
    fn pos_restrict(&self) -> Option<u16> {
        Some(3)
    }
}

impl PositionRestricted for AxisPtsDim {
    fn pos_restrict(&self) -> Option<u16> {
        Some(self.position)
    }
}

impl PositionRestricted for AxisRescaleDim {
    fn pos_restrict(&self) -> Option<u16> {
        Some(self.position)
    }
}

impl PositionRestricted for DistOpDim {
    fn pos_restrict(&self) -> Option<u16> {
        Some(self.position)
    }
}

impl PositionRestricted for FncValues {
    fn pos_restrict(&self) -> Option<u16> {
        Some(self.position)
    }
}

impl PositionRestricted for Identification {
    fn pos_restrict(&self) -> Option<u16> {
        Some(self.position)
    }
}

impl PositionRestricted for NoAxisPtsDim {
    fn pos_restrict(&self) -> Option<u16> {
        Some(self.position)
    }
}

impl PositionRestricted for NoRescaleDim {
    fn pos_restrict(&self) -> Option<u16> {
        Some(self.position)
    }
}

impl PositionRestricted for OffsetDim {
    fn pos_restrict(&self) -> Option<u16> {
        Some(self.position)
    }
}

impl PositionRestricted for Reserved {
    fn pos_restrict(&self) -> Option<u16> {
        Some(self.position)
    }
}

impl PositionRestricted for RipAddrDim {
    fn pos_restrict(&self) -> Option<u16> {
        Some(self.position)
    }
}

impl PositionRestricted for ShiftOpDim {
    fn pos_restrict(&self) -> Option<u16> {
        Some(self.position)
    }
}

impl PositionRestricted for SrcAddrDim {
    fn pos_restrict(&self) -> Option<u16> {
        Some(self.position)
    }
}

impl PositionRestricted for A2lFile {}
impl PositionRestricted for A2ml {}
impl PositionRestricted for AddrEpk {}
impl PositionRestricted for AddressType {}
impl PositionRestricted for AlignmentByte {}
impl PositionRestricted for AlignmentFloat16Ieee {}
impl PositionRestricted for AlignmentFloat32Ieee {}
impl PositionRestricted for AlignmentFloat64Ieee {}
impl PositionRestricted for AlignmentInt64 {}
impl PositionRestricted for AlignmentLong {}
impl PositionRestricted for AlignmentWord {}
impl PositionRestricted for Annotation {}
impl PositionRestricted for AnnotationLabel {}
impl PositionRestricted for AnnotationOrigin {}
impl PositionRestricted for AnnotationText {}
impl PositionRestricted for ArComponent {}
impl PositionRestricted for ArPrototypeOf {}
impl PositionRestricted for ArraySize {}
impl PositionRestricted for AxisDescr {}
impl PositionRestricted for AxisPts {}
impl PositionRestricted for AxisPtsRef {}
impl PositionRestricted for BitMask {}
impl PositionRestricted for BitOperation {}
impl PositionRestricted for Blob {}
impl PositionRestricted for ByteOrder {}
impl PositionRestricted for CalibrationAccess {}
impl PositionRestricted for CalibrationHandle {}
impl PositionRestricted for CalibrationHandleText {}
impl PositionRestricted for CalibrationMethod {}
impl PositionRestricted for Characteristic {}
impl PositionRestricted for Coeffs {}
impl PositionRestricted for CoeffsLinear {}
impl PositionRestricted for ComparisonQuantity {}
impl PositionRestricted for CompuMethod {}
impl PositionRestricted for CompuTab {}
impl PositionRestricted for CompuTabRef {}
impl PositionRestricted for CompuVtab {}
impl PositionRestricted for CompuVtabRange {}
impl PositionRestricted for ConsistentExchange {}
impl PositionRestricted for Conversion {}
impl PositionRestricted for CpuType {}
impl PositionRestricted for CurveAxisRef {}
impl PositionRestricted for Customer {}
impl PositionRestricted for CustomerNo {}
impl PositionRestricted for DataSize {}
impl PositionRestricted for DefCharacteristic {}
impl PositionRestricted for DefaultValue {}
impl PositionRestricted for DefaultValueNumeric {}
impl PositionRestricted for DependentCharacteristic {}
impl PositionRestricted for Deposit {}
impl PositionRestricted for Discrete {}
impl PositionRestricted for DisplayIdentifier {}
impl PositionRestricted for Ecu {}
impl PositionRestricted for EcuAddress {}
impl PositionRestricted for EcuAddressExtension {}
impl PositionRestricted for EcuCalibrationOffset {}
impl PositionRestricted for Encoding {}
impl PositionRestricted for Epk {}
impl PositionRestricted for ErrorMask {}
impl PositionRestricted for ExtendedLimits {}
impl PositionRestricted for FixAxisPar {}
impl PositionRestricted for FixAxisParDist {}
impl PositionRestricted for FixAxisParList {}
impl PositionRestricted for FixNoAxisPtsDim {}
impl PositionRestricted for Format {}
impl PositionRestricted for Formula {}
impl PositionRestricted for FormulaInv {}
impl PositionRestricted for Frame {}
impl PositionRestricted for FrameMeasurement {}
impl PositionRestricted for Function {}
impl PositionRestricted for FunctionList {}
impl PositionRestricted for FunctionVersion {}
impl PositionRestricted for Group {}
impl PositionRestricted for GuardRails {}
impl PositionRestricted for Header {}
impl PositionRestricted for IfData {}
impl PositionRestricted for InMeasurement {}
impl PositionRestricted for InputQuantity {}
impl PositionRestricted for Instance {}
impl PositionRestricted for Layout {}
impl PositionRestricted for LeftShift {}
impl PositionRestricted for Limits {}
impl PositionRestricted for LocMeasurement {}
impl PositionRestricted for MapList {}
impl PositionRestricted for MatrixDim {}
impl PositionRestricted for MaxGrad {}
impl PositionRestricted for MaxRefresh {}
impl PositionRestricted for Measurement {}
impl PositionRestricted for MemoryLayout {}
impl PositionRestricted for MemorySegment {}
impl PositionRestricted for ModCommon {}
impl PositionRestricted for ModPar {}
impl PositionRestricted for ModelLink {}
impl PositionRestricted for Module {}
impl PositionRestricted for Monotony {}
impl PositionRestricted for NoOfInterfaces {}
impl PositionRestricted for Number {}
impl PositionRestricted for OutMeasurement {}
impl PositionRestricted for Overwrite {}
impl PositionRestricted for PhoneNo {}
impl PositionRestricted for PhysUnit {}
impl PositionRestricted for ProjectNo {}
impl PositionRestricted for ReadOnly {}
impl PositionRestricted for ReadWrite {}
impl PositionRestricted for RecordLayout {}
impl PositionRestricted for RefCharacteristic {}
impl PositionRestricted for RefGroup {}
impl PositionRestricted for RefMeasurement {}
impl PositionRestricted for RefMemorySegment {}
impl PositionRestricted for RefUnit {}
impl PositionRestricted for RightShift {}
impl PositionRestricted for Root {}
impl PositionRestricted for SRecLayout {}
impl PositionRestricted for SiExponents {}
impl PositionRestricted for SignExtend {}
impl PositionRestricted for StaticAddressOffsets {}
impl PositionRestricted for StaticRecordLayout {}
impl PositionRestricted for StatusStringRef {}
impl PositionRestricted for StepSize {}
impl PositionRestricted for StructureComponent {}
impl PositionRestricted for SubFunction {}
impl PositionRestricted for SubGroup {}
impl PositionRestricted for Supplier {}
impl PositionRestricted for SymbolLink {}
impl PositionRestricted for SymbolTypeLink {}
impl PositionRestricted for SystemConstant {}
impl PositionRestricted for Transformer {}
impl PositionRestricted for TransformerInObjects {}
impl PositionRestricted for TransformerOutObjects {}
impl PositionRestricted for TypedefAxis {}
impl PositionRestricted for TypedefBlob {}
impl PositionRestricted for TypedefCharacteristic {}
impl PositionRestricted for TypedefMeasurement {}
impl PositionRestricted for TypedefStructure {}
impl PositionRestricted for Unit {}
impl PositionRestricted for UnitConversion {}
impl PositionRestricted for User {}
impl PositionRestricted for UserRights {}
impl PositionRestricted for VarAddress {}
impl PositionRestricted for VarCharacteristic {}
impl PositionRestricted for VarCriterion {}
impl PositionRestricted for VarForbiddenComb {}
impl PositionRestricted for VarMeasurement {}
impl PositionRestricted for VarNaming {}
impl PositionRestricted for VarSelectionCharacteristic {}
impl PositionRestricted for VarSeparator {}
impl PositionRestricted for VariantCoding {}
impl PositionRestricted for Version {}
impl PositionRestricted for Virtual {}
impl PositionRestricted for VirtualCharacteristic {}

#[cfg(test)]
mod test {
    use super::*;
    use crate::Filename;

    fn trait_test_helper<
        L,
        T: std::fmt::Debug + A2lObject<L> + PartialEq + Clone + PositionRestricted,
    >(
        item: &mut T,
    ) {
        item.get_layout_mut().uid = 1;
        assert_eq!(item.get_layout().uid, 1);

        item.reset_location();
        assert_eq!(item.get_layout().uid, 0);

        assert_eq!(item.get_line(), 0);

        item.merge_includes();

        let _res = item.pos_restrict();

        let dbg_disp = format!("{item:#?}");
        assert!(!dbg_disp.is_empty());

        let item2 = item.clone();
        assert_eq!(item, &item2);
    }

    fn trait_test_helper_unrestricted<L, T: std::fmt::Debug + A2lObject<L> + PartialEq + Clone>(
        item: &mut T,
    ) {
        item.get_layout_mut().uid = 1;
        assert_eq!(item.get_layout().uid, 1);

        item.reset_location();
        assert_eq!(item.get_layout().uid, 0);

        assert_eq!(item.get_line(), 0);

        item.merge_includes();

        let dbg_disp = format!("{item:#?}");
        assert!(!dbg_disp.is_empty());

        let item2 = item.clone();
        assert_eq!(item, &item2);
    }

    #[test]
    fn traits_test() {
        let mut item = A2lFile::new(Project::new("name".to_string(), "".to_string()));
        trait_test_helper(&mut item);
        let mut item = A2ml::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = A2mlVersion::new(0, 0);
        trait_test_helper(&mut item);
        let mut item = AddrEpk::new(0);
        trait_test_helper(&mut item);
        let mut item = AddressType::new(AddrType::Direct);
        trait_test_helper(&mut item);
        let mut item = AlignmentByte::new(0);
        trait_test_helper(&mut item);
        let mut item = AlignmentFloat16Ieee::new(0);
        trait_test_helper(&mut item);
        let mut item = AlignmentFloat32Ieee::new(0);
        trait_test_helper(&mut item);
        let mut item = AlignmentFloat64Ieee::new(0);
        trait_test_helper(&mut item);
        let mut item = AlignmentInt64::new(0);
        trait_test_helper(&mut item);
        let mut item = AlignmentLong::new(0);
        trait_test_helper(&mut item);
        let mut item = AlignmentWord::new(0);
        trait_test_helper(&mut item);
        let mut item = Annotation::new();
        trait_test_helper(&mut item);
        let mut item = AnnotationLabel::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = AnnotationOrigin::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = AnnotationText::new();
        trait_test_helper(&mut item);
        let mut item = ArComponent::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = ArPrototypeOf::new("name".to_string());
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = ArraySize::new(0);
        trait_test_helper(&mut item);
        let mut item = Asap2Version::new(0, 0);
        trait_test_helper(&mut item);
        let mut item = AxisDescr::new(
            AxisDescrAttribute::StdAxis,
            "".to_string(),
            "".to_string(),
            0,
            0.0,
            0.0,
        );
        trait_test_helper(&mut item);
        let mut item = AxisPts::new(
            "name".to_string(),
            "".to_string(),
            0,
            "".to_string(),
            "".to_string(),
            0.0,
            "".to_string(),
            0,
            0.0,
            0.0,
        );
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = AxisPtsDim::new(0, DataType::Ubyte, IndexOrder::IndexIncr, AddrType::Direct);
        trait_test_helper(&mut item);
        let mut item = AxisPtsRef::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = AxisRescaleDim::new(
            0,
            DataType::Float16Ieee,
            0,
            IndexOrder::IndexIncr,
            AddrType::Direct,
        );
        trait_test_helper(&mut item);
        let mut item = BitMask::new(0);
        trait_test_helper(&mut item);
        let mut item = BitOperation::new();
        trait_test_helper(&mut item);
        let mut item = Blob::new("".to_string(), "".to_string(), 0, 0);
        trait_test_helper(&mut item);
        let mut item = ByteOrder::new(ByteOrderEnum::MsbFirst);
        trait_test_helper(&mut item);
        let mut item = CalibrationAccess::new(CalibrationAccessEnum::Calibration);
        trait_test_helper(&mut item);
        let mut item = CalibrationHandle::new();
        trait_test_helper(&mut item);
        let mut item = CalibrationHandleText::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = CalibrationMethod::new("".to_string(), 0);
        trait_test_helper(&mut item);
        let mut item = Characteristic::new(
            "name".to_string(),
            "".to_string(),
            CharacteristicType::Value,
            0,
            "".to_string(),
            0.0,
            "".to_string(),
            0.0,
            0.0,
        );
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = Coeffs::new(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
        trait_test_helper(&mut item);
        let mut item = CoeffsLinear::new(0.0, 0.0);
        trait_test_helper(&mut item);
        let mut item = CombinationStruct::new("".to_string(), "".to_string());
        trait_test_helper_unrestricted(&mut item);
        let mut item = ComparisonQuantity::new("name".to_string());
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = CompuMethod::new(
            "name".to_string(),
            "".to_string(),
            ConversionType::Identical,
            "".to_string(),
            "".to_string(),
        );
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = CompuTab::new(
            "name".to_string(),
            "".to_string(),
            ConversionType::Identical,
            0,
        );
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = CompuTabRef::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = CompuVtab::new(
            "name".to_string(),
            "".to_string(),
            ConversionType::Identical,
            0,
        );
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = CompuVtabRange::new("name".to_string(), "".to_string(), 0);
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = ConsistentExchange::new();
        trait_test_helper(&mut item);
        let mut item = Conversion::new("name".to_string());
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = CpuType::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = CurveAxisRef::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = Customer::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = CustomerNo::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = DataSize::new(0);
        trait_test_helper(&mut item);
        let mut item = DefCharacteristic::new();
        trait_test_helper(&mut item);
        let mut item = DefaultValue::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = DefaultValueNumeric::new(0.0);
        trait_test_helper(&mut item);
        let mut item = DependentCharacteristic::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = Deposit::new(DepositMode::Absolute);
        trait_test_helper(&mut item);
        let mut item = Discrete::new();
        trait_test_helper(&mut item);
        let mut item = DisplayIdentifier::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = DistOpDim::new(0, DataType::AUint64);
        trait_test_helper(&mut item);
        let mut item = Ecu::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = EcuAddress::new(0);
        trait_test_helper(&mut item);
        let mut item = EcuAddressExtension::new(0);
        trait_test_helper(&mut item);
        let mut item = EcuCalibrationOffset::new(0);
        trait_test_helper(&mut item);
        let mut item = Encoding::new(CharacterEncoding::Utf8);
        trait_test_helper(&mut item);
        let mut item = Epk::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = ErrorMask::new(0);
        trait_test_helper(&mut item);
        let mut item = ExtendedLimits::new(0.0, 0.0);
        trait_test_helper(&mut item);
        let mut item = FixAxisPar::new(0, 0, 0);
        trait_test_helper(&mut item);
        let mut item = FixAxisParDist::new(0, 0, 0);
        trait_test_helper(&mut item);
        let mut item = FixAxisParList::new();
        trait_test_helper(&mut item);
        let mut item = FixNoAxisPtsDim::new(0);
        trait_test_helper(&mut item);
        let mut item = FncValues::new(0, DataType::AUint64, IndexMode::RowDir, AddrType::Direct);
        trait_test_helper(&mut item);
        let mut item = Format::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = Formula::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = FormulaInv::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = Frame::new("name".to_string(), "".to_string(), 0, 0);
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = FrameMeasurement::new();
        trait_test_helper(&mut item);
        let mut item = Function::new("name".to_string(), "".to_string());
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = FunctionList::new();
        trait_test_helper(&mut item);
        let mut item = FunctionVersion::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = Group::new("name".to_string(), "".to_string());
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = GuardRails::new();
        trait_test_helper(&mut item);
        let mut item = Header::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = Identification::new(0, DataType::Sbyte);
        trait_test_helper(&mut item);
        let mut item = IfData::default();
        trait_test_helper(&mut item);
        let mut item = InMeasurement::new();
        trait_test_helper(&mut item);
        let mut item = InputQuantity::new("name".to_string());
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = Instance::new("name".to_string(), "".to_string(), "".to_string(), 0);
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = Layout::new(IndexMode::RowDir);
        trait_test_helper(&mut item);
        let mut item = LeftShift::new(0);
        trait_test_helper(&mut item);
        let mut item = Limits::new(0.0, 0.0);
        trait_test_helper(&mut item);
        let mut item = LocMeasurement::new();
        trait_test_helper(&mut item);
        let mut item = MapList::new();
        trait_test_helper(&mut item);
        let mut item = MatrixDim::new();
        trait_test_helper(&mut item);
        let mut item = MaxGrad::new(0.0);
        trait_test_helper(&mut item);
        let mut item = MaxRefresh::new(0, 0);
        trait_test_helper(&mut item);
        let mut item = Measurement::new(
            "name".to_string(),
            "".to_string(),
            DataType::Sword,
            "".to_string(),
            0,
            0.0,
            0.0,
            0.0,
        );
        assert_eq!(item.get_name(), "name");
        trait_test_helper(&mut item);
        let mut item = MemoryLayout::new(ProgType::PrgReserved, 0, 0, [0, 0, 0, 0, 0]);
        trait_test_helper(&mut item);
        let mut item = MemorySegment::new(
            "name".to_string(),
            "".to_string(),
            PrgType::Code,
            MemoryType::Flash,
            MemoryAttribute::Extern,
            0,
            0,
            [0, 0, 0, 0, 0],
        );
        assert_eq!(item.get_name(), "name");
        trait_test_helper(&mut item);
        let mut item = ModCommon::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = ModPar::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = ModelLink::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = Module::new("name".to_string(), "".to_string());
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = Monotony::new(MonotonyType::MonIncrease);
        trait_test_helper(&mut item);
        let mut item = NoAxisPtsDim::new(0, DataType::Ubyte);
        trait_test_helper(&mut item);
        let mut item = NoOfInterfaces::new(0);
        trait_test_helper(&mut item);
        let mut item = NoRescaleDim::new(0, DataType::Float32Ieee);
        trait_test_helper(&mut item);
        let mut item = Number::new(0);
        trait_test_helper(&mut item);
        let mut item = OffsetDim::new(0, DataType::Ulong);
        trait_test_helper(&mut item);
        let mut item = OutMeasurement::new();
        trait_test_helper(&mut item);
        let mut item = Overwrite::new("name".to_string(), 0);
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = PhoneNo::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = PhysUnit::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = Project::new("name".to_string(), "".to_string());
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = ProjectNo::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = ReadOnly::new();
        trait_test_helper(&mut item);
        let mut item = ReadWrite::new();
        trait_test_helper(&mut item);
        let mut item = RecordLayout::new("name".to_string());
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = RefCharacteristic::new();
        trait_test_helper(&mut item);
        let mut item = RefGroup::new();
        trait_test_helper(&mut item);
        let mut item = RefMeasurement::new();
        trait_test_helper(&mut item);
        let mut item = RefMemorySegment::new("name".to_string());
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = RefUnit::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = Reserved::new(0, DataTypeSize::Long);
        trait_test_helper(&mut item);
        let mut item = RightShift::new(0);
        trait_test_helper(&mut item);
        let mut item = RipAddrDim::new(0, DataType::Ubyte);
        trait_test_helper(&mut item);
        let mut item = Root::new();
        trait_test_helper(&mut item);
        let mut item = SRecLayout::new("name".to_string());
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = ShiftOpDim::new(0, DataType::Slong);
        trait_test_helper(&mut item);
        let mut item = SiExponents::new(0, 0, 0, 0, 0, 0, 0);
        trait_test_helper(&mut item);
        let mut item = SignExtend::new();
        trait_test_helper(&mut item);
        let mut item = SrcAddrDim::new(0, DataType::Sbyte);
        trait_test_helper(&mut item);
        let mut item = StaticAddressOffsets::new();
        trait_test_helper(&mut item);
        let mut item = StaticRecordLayout::new();
        trait_test_helper(&mut item);
        let mut item = StatusStringRef::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = StepSize::new(0.0);
        trait_test_helper(&mut item);
        let mut item = StructureComponent::new("".to_string(), "".to_string(), 0);
        trait_test_helper(&mut item);
        let mut item = SubFunction::new();
        trait_test_helper(&mut item);
        let mut item = SubGroup::new();
        trait_test_helper(&mut item);
        let mut item = Supplier::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = SymbolLink::new("".to_string(), 0);
        trait_test_helper(&mut item);
        let mut item = SymbolTypeLink::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = SystemConstant::new("name".to_string(), "".to_string());
        trait_test_helper(&mut item);
        let mut item = TabEntryStruct::new(0.0, 1.0);
        trait_test_helper_unrestricted(&mut item);
        let mut item = Transformer::new(
            "name".to_string(),
            "".to_string(),
            "".to_string(),
            "".to_string(),
            0,
            TransformerTrigger::OnChange,
            "".to_string(),
        );
        assert_eq!(item.get_name(), "name");
        trait_test_helper(&mut item);
        let mut item = TransformerInObjects::new();
        trait_test_helper(&mut item);
        let mut item = TransformerOutObjects::new();
        trait_test_helper(&mut item);
        let mut item = TypedefAxis::new(
            "name".to_string(),
            "".to_string(),
            "".to_string(),
            "".to_string(),
            0.0,
            "".to_string(),
            0,
            0.0,
            0.0,
        );
        assert_eq!(item.get_name(), "name");
        trait_test_helper(&mut item);
        let mut item = TypedefBlob::new("name".to_string(), "".to_string(), 0);
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = TypedefCharacteristic::new(
            "name".to_string(),
            "".to_string(),
            CharacteristicType::Value,
            "".to_string(),
            0.0,
            "".to_string(),
            0.0,
            0.0,
        );
        assert_eq!(item.get_name(), "name");
        trait_test_helper(&mut item);
        let mut item = TypedefMeasurement::new(
            "name".to_string(),
            "".to_string(),
            DataType::Ubyte,
            "".to_string(),
            0,
            0.0,
            0.0,
            0.0,
        );
        assert_eq!(item.get_name(), "name");
        trait_test_helper(&mut item);
        let mut item = TypedefStructure::new("name".to_string(), "".to_string(), 0);
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = Unit::new(
            "name".to_string(),
            "".to_string(),
            "".to_string(),
            UnitType::Derived,
        );
        assert_eq!(item.get_name(), "name");
        trait_test_helper(&mut item);
        let mut item = UnitConversion::new(0.0, 0.0);
        trait_test_helper(&mut item);
        let mut item = User::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = UserRights::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = ValuePairsStruct::new(0.0, "".to_string());
        trait_test_helper_unrestricted(&mut item);
        let mut item = ValueTriplesStruct::new(0.0, 0.0, "".to_string());
        trait_test_helper_unrestricted(&mut item);
        let mut item = VarAddress::new();
        trait_test_helper(&mut item);
        let mut item = VarCharacteristic::new("name".to_string());
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = VarCriterion::new("name".to_string(), "".to_string());
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = VarForbiddenComb::new();
        trait_test_helper(&mut item);
        let mut item = VarMeasurement::new("name".to_string());
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = VarNaming::new(VarNamingTag::Numeric);
        trait_test_helper(&mut item);
        let mut item = VarSelectionCharacteristic::new("name".to_string());
        trait_test_helper(&mut item);
        assert_eq!(item.get_name(), "name");
        let mut item = VarSeparator::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = VariantCoding::new();
        trait_test_helper(&mut item);
        let mut item = Version::new("".to_string());
        trait_test_helper(&mut item);
        let mut item = Virtual::new();
        trait_test_helper(&mut item);
        let mut item = VirtualCharacteristic::new("".to_string());
        trait_test_helper(&mut item);
    }

    fn parse_helper<T: ParseableA2lObject>(
        data: &'static str,
        itemname: &str,
        strict: bool,
    ) -> Result<T, ParserError> {
        let mut log_msgs = Vec::new();
        let filedatas = [data.to_string()];
        let filenames = [Filename::from("test")];
        let token_result = crate::tokenizer::tokenize(&Filename::from("test"), 0, data).unwrap();
        let context = ParseContext {
            element: itemname.to_string(),
            fileid: 0,
            line: 1,
        };
        let mut parser = ParserState::new_internal(
            &token_result.tokens,
            &filedatas,
            &filenames,
            &mut log_msgs,
            strict,
        );
        T::parse(&mut parser, &context, 0)
    }

    #[test]
    fn test_parse_a2lfile() {
        // parse an A2lFile element - correct input
        static DATA: &str = r#"
            ASAP2_VERSION 1 71
            A2ML_VERSION 1 31
            /begin PROJECT p1 ""
                /begin MODULE m1 ""
                /end MODULE
            /end PROJECT"#;

        let result = parse_helper::<A2lFile>(DATA, "A2LFILE", true);
        assert!(result.is_ok());
        let a2l_file = result.unwrap();
        assert_eq!(a2l_file.project.name, "p1");
        assert_eq!(a2l_file.asap2_version.as_ref().unwrap().version_no, 1);
        assert_eq!(a2l_file.asap2_version.as_ref().unwrap().upgrade_no, 71);
        assert_eq!(a2l_file.a2ml_version.as_ref().unwrap().version_no, 1);
        assert_eq!(a2l_file.a2ml_version.as_ref().unwrap().upgrade_no, 31);
        assert_eq!(a2l_file.project.module.len(), 1);

        // parse an A2lFile element - incorrect input: Project is not a block
        static DATA2: &str = r#"
            ASAP2_VERSION 1 71
            A2ML_VERSION 1 31
            PROJECT p1 ""
                /begin MODULE m1 ""
                /end MODULE
            "#;
        // parse the A2lFile element
        let result = parse_helper::<A2lFile>(DATA2, "A2LFILE", true);
        assert!(result.is_err());

        // parse an A2lFile element - incorrect input: ASAP2_VERSION is a block
        static DATA3: &str = r#"
            /begin ASAP2_VERSION 1 71 /end ASAP2_VERSION
            A2ML_VERSION 1 31
            /begin PROJECT p1 ""
                /begin MODULE m1 ""
                /end MODULE
            /end PROJECT"#;
        // parse the A2lFile element
        let result = parse_helper::<A2lFile>(DATA3, "A2LFILE", true);
        assert!(result.is_err());

        // parse an A2lFile element - incorrect input: Unknown element
        static DATA4: &str = r#"
            ASAP2_VERSION 1 71
            A2ML_VERSION 1 31
            /begin UNKNOWN_ITEM /end UNKNOWN_ITEM
            /begin PROJECT p1 ""
                /begin MODULE m1 ""
                /end MODULE
            /end PROJECT"#;
        // parse the A2lFile element
        let result = parse_helper::<A2lFile>(DATA4, "A2LFILE", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_asap2_version() {
        // parse an ASAP2_VERSION element
        let asap2_version = parse_helper::<Asap2Version>("1 71", "ASAP2_VERSION", true).unwrap();
        assert_eq!(asap2_version.version_no, 1);
        assert_eq!(asap2_version.upgrade_no, 71);

        // parse an ASAP2_VERSION element - incorrect input: not enough arguments
        let result = parse_helper::<Asap2Version>("1", "ASAP2_VERSION", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_addr_epk() {
        // parse an ADDR_EPK element
        let addr_epk = parse_helper::<AddrEpk>("0", "ADDR_EPK", true).unwrap();
        assert_eq!(addr_epk.address, 0);

        // parse an ADDR_EPK element - incorrect input: bad token
        let result = parse_helper::<AddrEpk>("A", "ADDR_EPK", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_addrtype() {
        // parse an ADDR_TYPE element
        let addr_type = parse_helper::<AddrType>("DIRECT", "ADDR_TYPE", true).unwrap();
        assert_eq!(addr_type, AddrType::Direct);
        let addr_type = parse_helper::<AddrType>("PBYTE", "ADDR_TYPE", true).unwrap();
        assert_eq!(addr_type, AddrType::Pbyte);
        let addr_type = parse_helper::<AddrType>("PWORD", "ADDR_TYPE", true).unwrap();
        assert_eq!(addr_type, AddrType::Pword);
        let addr_type = parse_helper::<AddrType>("PLONG", "ADDR_TYPE", true).unwrap();
        assert_eq!(addr_type, AddrType::Plong);
        let addr_type = parse_helper::<AddrType>("PLONGLONG", "ADDR_TYPE", true).unwrap();
        assert_eq!(addr_type, AddrType::Plonglong);

        let result = parse_helper::<AddrType>("UNKNOWN", "ADDR_TYPE", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_annotation() {
        // parse an ANNOTATION element
        let data = r#"
                ANNOTATION_LABEL "label"
                ANNOTATION_ORIGIN "origin"
                /begin ANNOTATION_TEXT
                    "text"
                /end ANNOTATION_TEXT
            /end ANNOTATION"#;
        let annotation = parse_helper::<Annotation>(data, "ANNOTATION", true).unwrap();
        assert!(annotation.annotation_label.is_some());
        assert!(annotation.annotation_origin.is_some());

        // parse an ANNOTATION element - incorrect input: ANNOTATION_LABEL is a block
        let data = r#"
                /begin ANNOTATION_LABEL "label" /end ANNOTATION_LABEL
                ANNOTATION_ORIGIN "origin"
                /begin ANNOTATION_TEXT
                    "text"
                /end ANNOTATION_TEXT
            /end ANNOTATION"#;
        let result = parse_helper::<Annotation>(data, "ANNOTATION", true);
        assert!(result.is_err());

        // parse an ANNOTATION element - incorrect input: ANNOTATION_TEXT is not a block
        let data = r#"
                ANNOTATION_LABEL "label"
                ANNOTATION_ORIGIN "origin"
                ANNOTATION_TEXT "text"
            /end ANNOTATION"#;
        let result = parse_helper::<Annotation>(data, "ANNOTATION", true);
        assert!(result.is_err());

        // parse an ANNOTATION element - incorrect input: Unknown element
        let data = r#"
                ANNOTATION_LABEL "label"
                ANNOTATION_ORIGIN "origin"
                /begin UNKNOWN_ITEM /end UNKNOWN_ITEM
            /end ANNOTATION"#;
        let result = parse_helper::<Annotation>(data, "ANNOTATION", true);
        assert!(result.is_err());

        // parse an ANNOTATION element - incorrect input: Incorect end tag
        let data = r#"
                ANNOTATION_LABEL "label"
                ANNOTATION_ORIGIN "origin"
                /end INCORRECT"#;
        let result = parse_helper::<Annotation>(data, "ANNOTATION", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_annotation_text() {
        // parse an ANNOTATION_TEXT element
        let data = r#"
            "text"
            /end ANNOTATION_TEXT"#;
        let annotation_text =
            parse_helper::<AnnotationText>(data, "ANNOTATION_TEXT", true).unwrap();
        assert_eq!(annotation_text.annotation_text_list, &["text"]);

        // parse an ANNOTATION_TEXT element - incorrect input: Incorrect end tag
        let data = r#"
            "text"
            /end INCORRECT"#;
        let result = parse_helper::<AnnotationText>(data, "ANNOTATION_TEXT", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_ar_component() {
        // parse an AR_COMPONENT element
        let data = r#"
            "ar_component"
            AR_PROTOTYPE_OF function
            /end AR_COMPONENT"#;
        let ar_component = parse_helper::<ArComponent>(data, "AR_COMPONENT", true).unwrap();
        assert_eq!(ar_component.component_type, "ar_component");
        assert!(ar_component.ar_prototype_of.is_some());

        // parse an AR_COMPONENT element - incorrect input: AR_PROTOTYPE_OF is a block
        let data = r#"
            "ar_component"
            /begin AR_PROTOTYPE_OF function /end AR_PROTOTYPE_OF
            /end AR_COMPONENT"#;
        let result = parse_helper::<ArComponent>(data, "AR_COMPONENT", true);
        assert!(result.is_err());

        // parse an AR_COMPONENT element - incorrect input: Unknown element
        let data = r#"
            "ar_component"
            /begin UNKNOWN_ITEM /end UNKNOWN_ITEM
            /end AR_COMPONENT"#;
        let result = parse_helper::<ArComponent>(data, "AR_COMPONENT", true);
        assert!(result.is_err());

        // parse an AR_COMPONENT element - incorrect input: bad end tag
        let data = r#"
            "ar_component"
            /end INCORRECT"#;
        let result = parse_helper::<ArComponent>(data, "AR_COMPONENT", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_axis_descr() {
        // parse an AXIS_DESCR element
        let data = r#"
            COM_AXIS measurement_name compu_method_name 1 0 100
            /end AXIS_DESCR"#;
        let axis_descr = parse_helper::<AxisDescr>(data, "AXIS_DESCR", true).unwrap();
        assert_eq!(axis_descr.max_axis_points, 1);

        // parse an AXIS_DESCR element - incorrect input: unknown element
        let data = r#"
            COM_AXIS measurement_name compu_method_name 1 0 100
            UNKNOWN_ITEM
            /end AXIS_DESCR"#;
        let result = parse_helper::<AxisDescr>(data, "AXIS_DESCR", true);
        assert!(result.is_err());

        // parse an AXIS_DESCR element - incorrect input: bad end tag
        let data = r#"
            COM_AXIS measurement_name compu_method_name 1 0 100
            /end INCORRECT"#;
        let result = parse_helper::<AxisDescr>(data, "AXIS_DESCR", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_axis_descr_attribute() {
        // parse an AXIS_DESCR_ATTRIBUTE element
        let axis_descr_attribute =
            parse_helper::<AxisDescrAttribute>("STD_AXIS", "", true).unwrap();
        assert_eq!(axis_descr_attribute, AxisDescrAttribute::StdAxis);
        assert_eq!(format!("{axis_descr_attribute}"), "STD_AXIS");
        let axis_descr_attribute =
            parse_helper::<AxisDescrAttribute>("COM_AXIS", "", true).unwrap();
        assert_eq!(axis_descr_attribute, AxisDescrAttribute::ComAxis);
        assert_eq!(format!("{axis_descr_attribute}"), "COM_AXIS");
        let axis_descr_attribute =
            parse_helper::<AxisDescrAttribute>("FIX_AXIS", "", true).unwrap();
        assert_eq!(axis_descr_attribute, AxisDescrAttribute::FixAxis);
        assert_eq!(format!("{axis_descr_attribute}"), "FIX_AXIS");
        let axis_descr_attribute =
            parse_helper::<AxisDescrAttribute>("RES_AXIS", "", true).unwrap();
        assert_eq!(axis_descr_attribute, AxisDescrAttribute::ResAxis);
        assert_eq!(format!("{axis_descr_attribute}"), "RES_AXIS");
        let axis_descr_attribute =
            parse_helper::<AxisDescrAttribute>("CURVE_AXIS", "", true).unwrap();
        assert_eq!(axis_descr_attribute, AxisDescrAttribute::CurveAxis);
        assert_eq!(format!("{axis_descr_attribute}"), "CURVE_AXIS");

        // parse an AXIS_DESCR_ATTRIBUTE element - incorrect input: unknown element
        let result = parse_helper::<AxisDescrAttribute>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_axis_pts() {
        // parse an AXIS_PTS element
        let data = r#"
            axispts_name "" 0x1234 measurement_name record_layout_name 0 compu_method_name 3 0.0 10.0
            /end AXIS_PTS"#;
        let axis_pts = parse_helper::<AxisPts>(data, "AXIS_PTS", true).unwrap();
        assert_eq!(axis_pts.max_axis_points, 3);

        // parse an AXIS_PTS element - incorrect input: unknown element
        let data = r#"
            axispts_name "" 0x1234 measurement_name record_layout_name 0 compu_method_name 3 0.0 10.0
            UNKNOWN_ITEM
            /end AXIS_PTS"#;
        let result = parse_helper::<AxisPts>(data, "AXIS_PTS", true);
        assert!(result.is_err());

        // parse an AXIS_PTS element - incorrect input: bad end tag
        let data = r#"
            axispts_name "" 0x1234 measurement_name record_layout_name 0 compu_method_name 3 0.0 10.0
            /end INCORRECT"#;
        let result = parse_helper::<AxisPts>(data, "AXIS_PTS", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_bit_operation() {
        // parse a BIT_OPERATION element
        let data = r#"
            LEFT_SHIFT 1
            /end BIT_OPERATION"#;
        let bit_operation = parse_helper::<BitOperation>(data, "BIT_OPERATION", true).unwrap();
        assert_eq!(bit_operation.left_shift.as_ref().unwrap().bitcount, 1);

        // parse a BIT_OPERATION element - incorrect input: unknown element
        let data = r#"
            RIGHT_SHIFT 1
            UNKNOWN_ITEM
            /end BIT_OPERATION"#;
        let result = parse_helper::<BitOperation>(data, "BIT_OPERATION", true);
        assert!(result.is_err());

        // parse a BIT_OPERATION element - incorrect input: bad end tag
        let data = r#"
            /end INCORRECT"#;
        let result = parse_helper::<BitOperation>(data, "BIT_OPERATION", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_byte_order() {
        let byte_order = parse_helper::<ByteOrderEnum>("MSB_FIRST", "", true).unwrap();
        assert_eq!(byte_order, ByteOrderEnum::MsbFirst);
        assert_eq!(format!("{byte_order}"), "MSB_FIRST");
        let byte_order = parse_helper::<ByteOrderEnum>("MSB_LAST", "", true).unwrap();
        assert_eq!(byte_order, ByteOrderEnum::MsbLast);
        assert_eq!(format!("{byte_order}"), "MSB_LAST");
        let byte_order = parse_helper::<ByteOrderEnum>("MSB_FIRST_MSW_LAST", "", true).unwrap();
        assert_eq!(byte_order, ByteOrderEnum::MsbFirstMswLast);
        assert_eq!(format!("{byte_order}"), "MSB_FIRST_MSW_LAST");
        let byte_order = parse_helper::<ByteOrderEnum>("MSB_LAST_MSW_FIRST", "", true).unwrap();
        assert_eq!(byte_order, ByteOrderEnum::MsbLastMswFirst);
        assert_eq!(format!("{byte_order}"), "MSB_LAST_MSW_FIRST");
        let byte_order = parse_helper::<ByteOrderEnum>("LITTLE_ENDIAN", "", false).unwrap();
        assert_eq!(byte_order, ByteOrderEnum::LittleEndian);
        assert_eq!(format!("{byte_order}"), "LITTLE_ENDIAN");
        let byte_order = parse_helper::<ByteOrderEnum>("BIG_ENDIAN", "", false).unwrap();
        assert_eq!(byte_order, ByteOrderEnum::BigEndian);
        assert_eq!(format!("{byte_order}"), "BIG_ENDIAN");

        // parse a BYTE_ORDER element - incorrect input: unknown element
        let result = parse_helper::<ByteOrder>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_calibration_access_enum() {
        let calibration_access =
            parse_helper::<CalibrationAccessEnum>("CALIBRATION", "", true).unwrap();
        assert_eq!(calibration_access, CalibrationAccessEnum::Calibration);
        assert_eq!(format!("{calibration_access}"), "CALIBRATION");
        let calibration_access =
            parse_helper::<CalibrationAccessEnum>("NO_CALIBRATION", "", true).unwrap();
        assert_eq!(calibration_access, CalibrationAccessEnum::NoCalibration);
        assert_eq!(format!("{calibration_access}"), "NO_CALIBRATION");
        let calibration_access =
            parse_helper::<CalibrationAccessEnum>("NOT_IN_MCD_SYSTEM", "", true).unwrap();
        assert_eq!(calibration_access, CalibrationAccessEnum::NotInMcdSystem);
        assert_eq!(format!("{calibration_access}"), "NOT_IN_MCD_SYSTEM");
        let calibration_access =
            parse_helper::<CalibrationAccessEnum>("OFFLINE_CALIBRATION", "", true).unwrap();
        assert_eq!(
            calibration_access,
            CalibrationAccessEnum::OfflineCalibration
        );
        assert_eq!(format!("{calibration_access}"), "OFFLINE_CALIBRATION");

        // parse a CALIBRATION_ACCESS element - incorrect input: unknown element
        let result = parse_helper::<CalibrationAccess>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_character_encoding() {
        let character_encoding = parse_helper::<CharacterEncoding>("UTF8", "", true).unwrap();
        assert_eq!(character_encoding, CharacterEncoding::Utf8);
        assert_eq!(format!("{character_encoding}"), "UTF8");
        let character_encoding = parse_helper::<CharacterEncoding>("UTF16", "", true).unwrap();
        assert_eq!(character_encoding, CharacterEncoding::Utf16);
        assert_eq!(format!("{character_encoding}"), "UTF16");
        let character_encoding = parse_helper::<CharacterEncoding>("UTF32", "", true).unwrap();
        assert_eq!(character_encoding, CharacterEncoding::Utf32);
        assert_eq!(format!("{character_encoding}"), "UTF32");

        // parse a CHARACTER_ENCODING element - incorrect input: unknown element
        let result = parse_helper::<CharacterEncoding>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_characteristic_type() {
        let characteristic_type = parse_helper::<CharacteristicType>("ASCII", "", true).unwrap();
        assert_eq!(characteristic_type, CharacteristicType::Ascii);
        assert_eq!(format!("{characteristic_type}"), "ASCII");
        let characteristic_type = parse_helper::<CharacteristicType>("VALUE", "", true).unwrap();
        assert_eq!(characteristic_type, CharacteristicType::Value);
        assert_eq!(format!("{characteristic_type}"), "VALUE");
        let characteristic_type = parse_helper::<CharacteristicType>("VAL_BLK", "", true).unwrap();
        assert_eq!(characteristic_type, CharacteristicType::ValBlk);
        assert_eq!(format!("{characteristic_type}"), "VAL_BLK");
        let characteristic_type = parse_helper::<CharacteristicType>("CURVE", "", true).unwrap();
        assert_eq!(characteristic_type, CharacteristicType::Curve);
        assert_eq!(format!("{characteristic_type}"), "CURVE");
        let characteristic_type = parse_helper::<CharacteristicType>("MAP", "", true).unwrap();
        assert_eq!(characteristic_type, CharacteristicType::Map);
        assert_eq!(format!("{characteristic_type}"), "MAP");
        let characteristic_type = parse_helper::<CharacteristicType>("CUBOID", "", true).unwrap();
        assert_eq!(characteristic_type, CharacteristicType::Cuboid);
        assert_eq!(format!("{characteristic_type}"), "CUBOID");
        let characteristic_type = parse_helper::<CharacteristicType>("CUBE_4", "", true).unwrap();
        assert_eq!(characteristic_type, CharacteristicType::Cube4);
        assert_eq!(format!("{characteristic_type}"), "CUBE_4");
        let characteristic_type = parse_helper::<CharacteristicType>("CUBE_5", "", true).unwrap();
        assert_eq!(characteristic_type, CharacteristicType::Cube5);
        assert_eq!(format!("{characteristic_type}"), "CUBE_5");

        // parse a CHARACTERISTIC_TYPE element - incorrect input: unknown element
        let result = parse_helper::<CharacteristicType>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_conversion_type() {
        let conversion_type = parse_helper::<ConversionType>("IDENTICAL", "", true).unwrap();
        assert_eq!(conversion_type, ConversionType::Identical);
        assert_eq!(format!("{conversion_type}"), "IDENTICAL");
        let conversion_type = parse_helper::<ConversionType>("LINEAR", "", true).unwrap();
        assert_eq!(conversion_type, ConversionType::Linear);
        assert_eq!(format!("{conversion_type}"), "LINEAR");
        let conversion_type = parse_helper::<ConversionType>("RAT_FUNC", "", true).unwrap();
        assert_eq!(conversion_type, ConversionType::RatFunc);
        assert_eq!(format!("{conversion_type}"), "RAT_FUNC");
        let conversion_type = parse_helper::<ConversionType>("TAB_INTP", "", true).unwrap();
        assert_eq!(conversion_type, ConversionType::TabIntp);
        assert_eq!(format!("{conversion_type}"), "TAB_INTP");
        let conversion_type = parse_helper::<ConversionType>("TAB_NOINTP", "", true).unwrap();
        assert_eq!(conversion_type, ConversionType::TabNointp);
        assert_eq!(format!("{conversion_type}"), "TAB_NOINTP");
        let conversion_type = parse_helper::<ConversionType>("FORM", "", true).unwrap();
        assert_eq!(conversion_type, ConversionType::Form);
        assert_eq!(format!("{conversion_type}"), "FORM");
        let conversion_type = parse_helper::<ConversionType>("TAB_VERB", "", true).unwrap();
        assert_eq!(conversion_type, ConversionType::TabVerb);
        assert_eq!(format!("{conversion_type}"), "TAB_VERB");

        // parse a CONVERSION_TYPE element - incorrect input: unknown element
        let result = parse_helper::<ConversionType>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_datatype() {
        let datatype = parse_helper::<DataType>("UWORD", "", true).unwrap();
        assert_eq!(datatype, DataType::Uword);
        assert_eq!(format!("{datatype}"), "UWORD");
        let datatype = parse_helper::<DataType>("SWORD", "", true).unwrap();
        assert_eq!(datatype, DataType::Sword);
        assert_eq!(format!("{datatype}"), "SWORD");
        let datatype = parse_helper::<DataType>("UBYTE", "", true).unwrap();
        assert_eq!(datatype, DataType::Ubyte);
        assert_eq!(format!("{datatype}"), "UBYTE");
        let datatype = parse_helper::<DataType>("SBYTE", "", true).unwrap();
        assert_eq!(datatype, DataType::Sbyte);
        assert_eq!(format!("{datatype}"), "SBYTE");
        let datatype = parse_helper::<DataType>("ULONG", "", true).unwrap();
        assert_eq!(datatype, DataType::Ulong);
        assert_eq!(format!("{datatype}"), "ULONG");
        let datatype = parse_helper::<DataType>("SLONG", "", true).unwrap();
        assert_eq!(datatype, DataType::Slong);
        assert_eq!(format!("{datatype}"), "SLONG");
        let datatype = parse_helper::<DataType>("FLOAT32_IEEE", "", true).unwrap();
        assert_eq!(datatype, DataType::Float32Ieee);
        assert_eq!(format!("{datatype}"), "FLOAT32_IEEE");
        let datatype = parse_helper::<DataType>("FLOAT64_IEEE", "", true).unwrap();
        assert_eq!(datatype, DataType::Float64Ieee);
        assert_eq!(format!("{datatype}"), "FLOAT64_IEEE");
        let datatype = parse_helper::<DataType>("A_UINT64", "", true).unwrap();
        assert_eq!(datatype, DataType::AUint64);
        assert_eq!(format!("{datatype}"), "A_UINT64");
        let datatype = parse_helper::<DataType>("A_INT64", "", true).unwrap();
        assert_eq!(datatype, DataType::AInt64);
        assert_eq!(format!("{datatype}"), "A_INT64");

        // parse a DATATYPE element - incorrect
        let result = parse_helper::<DataType>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_datatype_size() {
        let datatype_size = parse_helper::<DataTypeSize>("BYTE", "", true).unwrap();
        assert_eq!(datatype_size, DataTypeSize::Byte);
        assert_eq!(format!("{datatype_size}"), "BYTE");
        let datatype_size = parse_helper::<DataTypeSize>("WORD", "", true).unwrap();
        assert_eq!(datatype_size, DataTypeSize::Word);
        assert_eq!(format!("{datatype_size}"), "WORD");
        let datatype_size = parse_helper::<DataTypeSize>("LONG", "", true).unwrap();
        assert_eq!(datatype_size, DataTypeSize::Long);
        assert_eq!(format!("{datatype_size}"), "LONG");

        // parse a DATATYPE_SIZE element - incorrect
        let result = parse_helper::<DataTypeSize>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_deposit_mode() {
        let deposit_mode = parse_helper::<DepositMode>("ABSOLUTE", "", true).unwrap();
        assert_eq!(deposit_mode, DepositMode::Absolute);
        assert_eq!(format!("{deposit_mode}"), "ABSOLUTE");
        let deposit_mode = parse_helper::<DepositMode>("DIFFERENCE", "", true).unwrap();
        assert_eq!(deposit_mode, DepositMode::Difference);
        assert_eq!(format!("{deposit_mode}"), "DIFFERENCE");

        // parse a DEPOSIT_MODE element - incorrect
        let result = parse_helper::<DepositMode>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_indexmode() {
        let indexmode = parse_helper::<IndexMode>("ROW_DIR", "", true).unwrap();
        assert_eq!(indexmode, IndexMode::RowDir);
        assert_eq!(format!("{indexmode}"), "ROW_DIR");
        let indexmode = parse_helper::<IndexMode>("COLUMN_DIR", "", true).unwrap();
        assert_eq!(indexmode, IndexMode::ColumnDir);
        assert_eq!(format!("{indexmode}"), "COLUMN_DIR");
        let indexmode = parse_helper::<IndexMode>("ALTERNATE_CURVES", "", true).unwrap();
        assert_eq!(indexmode, IndexMode::AlternateCurves);
        assert_eq!(format!("{indexmode}"), "ALTERNATE_CURVES");
        let indexmode = parse_helper::<IndexMode>("ALTERNATE_WITH_X", "", true).unwrap();
        assert_eq!(indexmode, IndexMode::AlternateWithX);
        assert_eq!(format!("{indexmode}"), "ALTERNATE_WITH_X");
        let indexmode = parse_helper::<IndexMode>("ALTERNATE_WITH_Y", "", true).unwrap();
        assert_eq!(indexmode, IndexMode::AlternateWithY);
        assert_eq!(format!("{indexmode}"), "ALTERNATE_WITH_Y");

        // parse a INDEXMODE element - incorrect
        let result = parse_helper::<IndexMode>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_indexorder() {
        let indexorder = parse_helper::<IndexOrder>("INDEX_DECR", "", true).unwrap();
        assert_eq!(indexorder, IndexOrder::IndexDecr);
        assert_eq!(format!("{indexorder}"), "INDEX_DECR");
        let indexorder = parse_helper::<IndexOrder>("INDEX_INCR", "", true).unwrap();
        assert_eq!(indexorder, IndexOrder::IndexIncr);
        assert_eq!(format!("{indexorder}"), "INDEX_INCR");

        // parse a INDEXORDER element - incorrect
        let result = parse_helper::<IndexOrder>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_memory_attribute() {
        let memory_attribute = parse_helper::<MemoryAttribute>("EXTERN", "", true).unwrap();
        assert_eq!(memory_attribute, MemoryAttribute::Extern);
        assert_eq!(format!("{memory_attribute}"), "EXTERN");
        let memory_attribute = parse_helper::<MemoryAttribute>("INTERN", "", true).unwrap();
        assert_eq!(memory_attribute, MemoryAttribute::Intern);
        assert_eq!(format!("{memory_attribute}"), "INTERN");

        // parse a MEMORY_ATTRIBUTE element - incorrect
        let result = parse_helper::<MemoryAttribute>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_memory_type() {
        let memory_type = parse_helper::<MemoryType>("EEPROM", "", true).unwrap();
        assert_eq!(memory_type, MemoryType::Eeprom);
        assert_eq!(format!("{memory_type}"), "EEPROM");
        let memory_type = parse_helper::<MemoryType>("EPROM", "", true).unwrap();
        assert_eq!(memory_type, MemoryType::Eprom);
        assert_eq!(format!("{memory_type}"), "EPROM");
        let memory_type = parse_helper::<MemoryType>("FLASH", "", true).unwrap();
        assert_eq!(memory_type, MemoryType::Flash);
        assert_eq!(format!("{memory_type}"), "FLASH");
        let memory_type = parse_helper::<MemoryType>("RAM", "", true).unwrap();
        assert_eq!(memory_type, MemoryType::Ram);
        assert_eq!(format!("{memory_type}"), "RAM");
        let memory_type = parse_helper::<MemoryType>("ROM", "", true).unwrap();
        assert_eq!(memory_type, MemoryType::Rom);
        assert_eq!(format!("{memory_type}"), "ROM");
        let memory_type = parse_helper::<MemoryType>("REGISTER", "", true).unwrap();
        assert_eq!(memory_type, MemoryType::Register);
        assert_eq!(format!("{memory_type}"), "REGISTER");
        let memory_type = parse_helper::<MemoryType>("NOT_IN_ECU", "", true).unwrap();
        assert_eq!(memory_type, MemoryType::NotInEcu);
        assert_eq!(format!("{memory_type}"), "NOT_IN_ECU");

        // parse a MEMORY_TYPE element - incorrect
        let result = parse_helper::<MemoryType>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_monotony_type() {
        let monotony_type = parse_helper::<MonotonyType>("MON_DECREASE", "", true).unwrap();
        assert_eq!(monotony_type, MonotonyType::MonDecrease);
        assert_eq!(format!("{monotony_type}"), "MON_DECREASE");
        let monotony_type = parse_helper::<MonotonyType>("MON_INCREASE", "", true).unwrap();
        assert_eq!(monotony_type, MonotonyType::MonIncrease);
        assert_eq!(format!("{monotony_type}"), "MON_INCREASE");
        let monotony_type = parse_helper::<MonotonyType>("MONOTONOUS", "", true).unwrap();
        assert_eq!(monotony_type, MonotonyType::Monotonous);
        assert_eq!(format!("{monotony_type}"), "MONOTONOUS");
        let monotony_type = parse_helper::<MonotonyType>("STRICT_DECREASE", "", true).unwrap();
        assert_eq!(monotony_type, MonotonyType::StrictDecrease);
        assert_eq!(format!("{monotony_type}"), "STRICT_DECREASE");
        let monotony_type = parse_helper::<MonotonyType>("STRICT_INCREASE", "", true).unwrap();
        assert_eq!(monotony_type, MonotonyType::StrictIncrease);
        assert_eq!(format!("{monotony_type}"), "STRICT_INCREASE");
        let monotony_type = parse_helper::<MonotonyType>("STRICT_MON", "", true).unwrap();
        assert_eq!(monotony_type, MonotonyType::StrictMon);
        assert_eq!(format!("{monotony_type}"), "STRICT_MON");
        let monotony_type = parse_helper::<MonotonyType>("NOT_MON", "", true).unwrap();
        assert_eq!(monotony_type, MonotonyType::NotMon);
        assert_eq!(format!("{monotony_type}"), "NOT_MON");

        // parse a MONOTONY_TYPE element - incorrect
        let result = parse_helper::<MonotonyType>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_prg_type() {
        let prg_type = parse_helper::<PrgType>("CALIBRATION_VARIABLES", "", true).unwrap();
        assert_eq!(prg_type, PrgType::CalibrationVariables);
        assert_eq!(format!("{prg_type}"), "CALIBRATION_VARIABLES");
        let prg_type = parse_helper::<PrgType>("CODE", "", true).unwrap();
        assert_eq!(prg_type, PrgType::Code);
        assert_eq!(format!("{prg_type}"), "CODE");
        let prg_type = parse_helper::<PrgType>("DATA", "", true).unwrap();
        assert_eq!(prg_type, PrgType::Data);
        assert_eq!(format!("{prg_type}"), "DATA");
        let prg_type = parse_helper::<PrgType>("EXCLUDE_FROM_FLASH", "", true).unwrap();
        assert_eq!(prg_type, PrgType::ExcludeFromFlash);
        assert_eq!(format!("{prg_type}"), "EXCLUDE_FROM_FLASH");
        let prg_type = parse_helper::<PrgType>("OFFLINE_DATA", "", true).unwrap();
        assert_eq!(prg_type, PrgType::OfflineData);
        assert_eq!(format!("{prg_type}"), "OFFLINE_DATA");
        let prg_type = parse_helper::<PrgType>("SERAM", "", true).unwrap();
        assert_eq!(prg_type, PrgType::Seram);
        assert_eq!(format!("{prg_type}"), "SERAM");
        let prg_type = parse_helper::<PrgType>("VARIABLES", "", true).unwrap();
        assert_eq!(prg_type, PrgType::Variables);
        assert_eq!(format!("{prg_type}"), "VARIABLES");
        let prg_type = parse_helper::<PrgType>("RESERVED", "", true).unwrap();
        assert_eq!(prg_type, PrgType::Reserved);
        assert_eq!(format!("{prg_type}"), "RESERVED");

        // parse a PRG_TYPE element - incorrect
        let result = parse_helper::<PrgType>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_prog_type() {
        let prog_type = parse_helper::<ProgType>("PRG_CODE", "", true).unwrap();
        assert_eq!(prog_type, ProgType::PrgCode);
        assert_eq!(format!("{prog_type}"), "PRG_CODE");
        let prog_type = parse_helper::<ProgType>("PRG_DATA", "", true).unwrap();
        assert_eq!(prog_type, ProgType::PrgData);
        assert_eq!(format!("{prog_type}"), "PRG_DATA");
        let prog_type = parse_helper::<ProgType>("PRG_RESERVED", "", true).unwrap();
        assert_eq!(prog_type, ProgType::PrgReserved);
        assert_eq!(format!("{prog_type}"), "PRG_RESERVED");

        // parse a PROG_TYPE element - incorrect
        let result = parse_helper::<ProgType>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_transformer_trigger() {
        let transformer_trigger =
            parse_helper::<TransformerTrigger>("ON_USER_REQUEST", "", true).unwrap();
        assert_eq!(transformer_trigger, TransformerTrigger::OnUserRequest);
        assert_eq!(format!("{transformer_trigger}"), "ON_USER_REQUEST");
        let transformer_trigger =
            parse_helper::<TransformerTrigger>("ON_CHANGE", "", true).unwrap();
        assert_eq!(transformer_trigger, TransformerTrigger::OnChange);
        assert_eq!(format!("{transformer_trigger}"), "ON_CHANGE");

        // parse a TRANSFORMER_TRIGGER element - incorrect
        let result = parse_helper::<TransformerTrigger>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_unit_type() {
        let unit_type = parse_helper::<UnitType>("EXTENDED_SI", "", true).unwrap();
        assert_eq!(unit_type, UnitType::ExtendedSi);
        assert_eq!(format!("{unit_type}"), "EXTENDED_SI");
        let unit_type = parse_helper::<UnitType>("DERIVED", "", true).unwrap();
        assert_eq!(unit_type, UnitType::Derived);
        assert_eq!(format!("{unit_type}"), "DERIVED");

        // parse a UNIT_TYPE element - incorrect
        let result = parse_helper::<UnitType>("UNKNOWN", "", true);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_var_naming_tag() {
        let var_naming_tag = parse_helper::<VarNamingTag>("NUMERIC", "", true).unwrap();
        assert_eq!(var_naming_tag, VarNamingTag::Numeric);
        assert_eq!(format!("{var_naming_tag}"), "NUMERIC");

        // parse a VAR_NAMING_TAG element - incorrect
        let result = parse_helper::<VarNamingTag>("UNKNOWN", "", true);
        assert!(result.is_err());
    }
}
